
\section{Análise Semantica (\texttt{checker})} \label{section-checker}
O processo de validação semântica no compilador é crucial para garantir a corretude das equações, a consistência de tipos em operações e a resolução adequada de símbolos. Ele é estruturado em dois mecanismos principais: validação de definições de funções e validação de declarações. Esses mecanismos trabalham de forma integrada para garantir que a estrutura do programa esteja em conformidade com as regras semânticas da \texttt{EquationLang}.

Nesta seção, abordamos essas regras e discutimos como são validadas expressões envolvendo vetores, redefinições de equações e possíveis erros nas definições de BRDFs que inviabilizem a geração de código. A conclusão bem-sucedida dessa etapa de inferência e validação indica que o programa está apto a prosseguir para a fase de geração de código GLSL, conduzida pelo pacote \texttt{emitter}.


\subsection{Funções do Pacote \texttt{checker}}

O pacote \texttt{checker} é responsável por realizar diversas tarefas fundamentais para a validação semântica do compilador. Essas tarefas são descritas detalhadamente a seguir:

\begin{enumerate}
    \item \textbf{Inferência e Anotação de Tipos}:
    Cada expressão na AST possui um campo \verb"ty_inferred" que deve ser preenchido durante essa etapa. Para determinar esses tipos, é necessário realizar a inferência de tipos. Essa tarefa é detalhada na \autoref{subsection-type-inference}. Os tipos possíveis incluem números (\verb"float"), vetores (\verb"vector") e funções.
        O tipo de uma função é representada por um domínio (tipos dos argumentos de entrada) e um contradomínio (tipo do valor de retorno). Exemplos incluem:
        \begin{itemize}
            \item Uma função $f(a, b) = a \cdot b \cdot \vec{1,1,1}$, que recebe dois valores reais e retorna um vetor tridimensional, possui a assinatura:
            \[
            f : \mathbb{R} \times \mathbb{R} \to \mathbb{R}^3.
            \]
            \item O produto vetorial, que combina dois vetores tridimensionais, possui a assinatura:
            \[
            \times : \mathbb{R}^3 \times \mathbb{R}^3 \to \mathbb{R}^3.
            \]
        \end{itemize}
        Essas assinaturas são coletadas durante o processo de inferência para garantir a consistência em expressões de chamada de funções.

    \item \textbf{Compatibilidade de Tipos}:
    O \texttt{checker} também verifica a compatibilidade entre tipos em diferentes contextos do programa. Essa validação assegura que:
    \begin{itemize}
        \item Não sejam realizadas operações não definidas por \texttt{EquationLang}, como a multiplicação entre dois vetores. Por exemplo, $\vec{u} * \vec{v}$ seria inválido para uma multiplicação direta, mas pode ser válido para um produto escalar ou vetorial.

        \item Não sejam aplicados operadores em tipos incompatíveis, como elevar um número a um vetor ($2^{\vec{n}}$).

        \item Os argumentos de uma função pertençam ao domínio da função. Por exemplo, se a função $\texttt{normalize}(\vec{u})$ retorna um vetor tridimensional ($\mathbb{R}^3$), usá-lo como argumento para funlção seno, que espera um número escalar ($\mathbb{R}$). Então, $\sin(\texttt{normalize}(\vec{u}))$ seria inválido.
        \item O tipo do valor de retorno de uma função seja adequado ao contexto onde é utilizado.
    \end{itemize}

    \item \textbf{Validação de Definições de Símbolos}:
        Outro papel fundamental do \texttt{checker} é garantir que todos os identificadores, abstraido em símbolos na \autoref{subsection-symbols-scopes}, utilizados no programa estejam devidamente definidos antes de serem usados. Essa etapa inclui:
    \begin{itemize}
        \item Identificar declarações ausentes.
        \item Identificar dependencia circular.
        \item Certificar-se de que funções obrigatórias, como a BRDF $f$, estejam presentes.
    \end{itemize}
\end{enumerate}

Essas validações são realizadas utilizando o padrão \textit{Visitor}, detalhado na \autoref{subsection-walker} e os erros encontrados são reportados usando as funções de erros introduzida na \autoref{section-lexer} (\label{function-errors}).

\subsection{Uso do Padrão Visitor}
@@@ Prefisamos manter essa subseção se já vamos detalhar mais pra frente?@@

Para realizar a validação semântica, o pacote \texttt{walker} é reutilizado, permitindo a travessia modular da AST. Essa abordagem facilita a aplicação recursiva de inferência de tipos, provida pelo, mesmo em expressões aninhadas.

Validações ocorrem nessa traversia e basedo no tipo do nó, a inferencia é feita, discutido na \autoref{subsection-inferencia-tipos} uma operação binária de multiplicação:
\begin{itemize}
    \item Se ambos os operandos forem números reais, o resultado também será um número real.
    \item Se um dos operandos for um vetor tridimensional, o resultado dependerá do outro operando (por exemplo, um escalar ou outro vetor).
\end{itemize}

Como a esquerda ou a direita de uma operação binária podem ser expressões aninhadas (outras operações binárias, chamadas de funções, etc.), o padrão visitor permite aplicar a inferência de tipos recursivamente. Esse processo garante que o tipo de cada subexpressão seja determinado de forma consistente e confiável.


\subsection{Tipos, Simbolos e Escopos} \label{subsection-symbols-scopes}

Cada expressão na AST possui um tipo associado, modelado como uma união de estruturas na linguagem Odin, conforme mostrado na \autoref{cod-types-structs}. Essa união permite representar as seguintes categorias semânticas: tipos primitivos fundamentais, como números e vetores; assinaturas de funções, que capturam o domínio e o contradomínio. Por exemplo, o produto vetorial possui a assinatura $\mathbb{R}^3 \times \mathbb{R}^3 \to \mathbb{R}^3$. Já o vetor normal ($\vec{n}$), possui tipo primitivo de número ($\mathbb{R}$). A modelagem clara de tipos e o conceito de escopos e símbolos é essencial para validar expressões em diferentes contextos, verificar compatibilidade de operações e garantir a consistência semântica do programa.


\subsubsection{Tipos}
No \autoref{cod-types-structs}, temos a representação de tipos segue uma modelagem hierárquica o \textbf{Tipo Base} contém metadados comuns
como referência ao nó na arvóre sintática, identificador de tipo concreto. Os \textbf{Tipos Derivados} são enumerados a seguir:

\begin{enumerate}
    \item \textit{Tipo Básico:} Categorização primitiva (número)
    \item \textit{Tipo Vetorial:}
    \begin{itemize}
        \item Dimensionalidade
        \item Tipo de elemento
    \end{itemize}
    \item \textit{Tipo Funcional:}
    \begin{itemize}
        \item Parâmetros
        \item Resultados
    \end{itemize}
\end{enumerate}

\begin{codigo}[htb]
    \caption{\small Estruturas que representam o tipo de um expressão da AST. }
    \label{cod-types-structs}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]

Type :: struct {
    node:    ^Node,
    size:    i64,
    derived: Any_Type,

    /* Easy comparison, types aren't equal if they are not even the same odin typeid */
    id:      typeid,
}

Type_Vector :: struct {
    using _:      Type,
    element_type: ^Type,
    dimensions:   int,
}


Type_Basic :: struct {
    using _: Type,
    basic_kind : Basic_Kind,
};


Type_Function :: struct {
    using _: Type,
    // node:   ^Expr_Procedure,
    params, results :[]^Type,
};

\end{lstlisting}
\end{codigo}


\subsubsection{Símbolos}

Os símbolos representam entidades nomeadas em \texttt{EquationLang}. A estrutura \texttt{Symbol}, apresentada no \autoref{cod-symbol}, encapsula as informações semânticas necessárias sobre os identificadores para validação da AST e geração de código. Essas informações incluem: \begin{itemize} \item \textbf{Escopo}: o escopo em que o símbolo foi definido. \item \textbf{Nó do identificador}: referência ao nó correspondente na AST para uso futuro. \item \textbf{Definição de função (opcional)}: nó da definição de função, quando aplicável. \item \textbf{Estado de resolução}: indica se o símbolo já foi resolvido. \item \textbf{Tipo associado}: o tipo inferido ou declarado do símbolo. \end{itemize}

O gerenciamento de símbolos é essencial para garantir que o estado de cada símbolo seja mantido durante a resolução, como discutido na \autoref{sec-symbol-resolution}.
\begin{enumerate}
    \item \textbf{Não Resolvido:} Estado inicial
    \item \textbf{Em Progresso:} Resolução em andamento
    \item \textbf{Resolvido:} Completamente processado
\end{enumerate}

\begin{codigo}[htb]
    \caption{\small Esturura do Simbolo. }
    \label{cod-symbol}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
// An Symbol is a named entity in the language
Symbol :: struct  {
    scope:      ^Scope,

    identifier: ^ast.Expr_Identifier, // Can be nullptr
    fn_defn:    ^ast.Expr_Function_Definition, // if the Symbol is a function

    state:      Symbol_State,
    flags:      bit_set[Symbol_Flag; u64],
    type:       ^Type,
    value:      Maybe(Value)
};

\end{lstlisting}
\end{codigo}


\subsection{Escopo e Tabela de Símbolos} \label{section-escope-table}

Nesse projeto, foi desenvolvido também uma tabela de símbolos, cuja implementação é usada análise semântica e na geração de código GLSL. A implementação da tabela de símbolos fornecida aqui é baseada em uma estrutura de escopo hierárquico, onde cada escopo mantém um mapeamento entre os nomes dos símbolos e seus atributos correspondentes. No \autoref{struct-symbol}, a estrutura \texttt{Scope} representa um mapeamento de nomes para objetos de símbolo dentro de um \textbf{único escopo}, e a estrutura \texttt{Scope\_Table} mantém uma \textbf{pilha de escopos}, permitindo aninhamento.

\begin{codigo}[H]
\caption{\small Código da estrutura de símbolos escrito em Odin.}
\label{struct-symbol}
\begin{lstlisting}[language=C]
Scope_Table :: [dynamic]^Scope

SCOPES := Scope_Table{}

Scope :: struct {
/*
 . `node` Is a parent node that created that scope
 . Ex: a block, a function block, a struct or namespace
 . If null, then the scope is the file/global idk yet @LOOK
*/
    parent:   ^Scope,
    children:   [dynamic]^Scope,
    /*
     . It does not need to be a pointer to a map
     . because we don't ever copy a Scope we have only one scope
     . per map elements, and we access this ONLY scope value trought a pointer
    */

    elements: map[string]^Symbol,
    ordered_keys: []string, // bit of a HACK, yeah
};

\end{lstlisting}
\end{codigo}

A tabela de símbolos fornece funções para gerenciar escopos, incluindo:
\begin{itemize}
    \item \texttt{scope\_enter}: entrar em um novo escopo, anexando-o à pilha de escopos.
    \item \texttt{scope\_exit}: sai do escopo atual, removendo-o da pilha de escopos e o retornando.
    \item \texttt{scope\_reset}: redefine a tabela de símbolos limpando todos os escopos.
    \item \texttt{scope\_get}: recupera um símbolo da tabela de símbolos pelo seu identificador.
    \item \texttt{scope\_add}: adiciona um novo símbolo ao escopo atual.
\end{itemize}

Essa tabela de símbolos armazena todas as informações necessárias para a fase de geração do \textit{shader} GLSL.


\subsection{Resolução de Símbolos} \label{subsection-sym-resolution}
A resolução de símbolos é uma etapa fundamental no \texttt{checker}, garantindo que cada símbolo seja corretamente definido e tipado antes de seu uso. Esse processo é especialmente relevante em situações onde a ordem de definição não segue um fluxo linear, como no exemplo da \autoref{eq-preref}).

Um escopo global é criado contendo todos os símbolos definidos, e a validação verifica se cada identificador está presente no escopo atual. Caso contrário, é gerado um erro apropriado. É nesta etapa que verificamos se a função $f$, a BRDF por convenção, existe no escopo global. Identificadores embutidos, definidos pelas convenções deste trabalho como $\omega_i$ e $\theta_d$, são adicionados automaticamente à tabela de símbolos juntamente com seus tipos. A lista completa de embutidos está disponível em \autoref{cod-builtins}. Símbolos de parâmetros são resolvidos no escopo da função correspondente.


%%%%


Nesse caso da \autoref{eq-preref}, \texttt{b} é atribuído a \texttt{a} antes que \texttt{a} seja definido. O \texttt{checker} deve resolver essa dependência, analisando \texttt{a} antes de \texttt{b} para inferir corretamente o tipo de \texttt{b}. Isso é possível por conta da construção de um grafo de dependências entre símbolos (apresentado na \autoref{cod-grafo-simbol-deps}). A partir de uma ordenação topológica desse grafo, o sistema determina uma ordem de avaliação válida, além de identificar dependências circulares que possam impedir a compilação.

\begin{subequations} \label{eq-preref}
\begin{equation}
    b = a
\end{equation}
\begin{equation}
    a = \vec{n}
\end{equation}
\begin{equation}
    f = b
\end{equation}
\end{subequations}


Essa ordenação permite usar símbolos antes de suas equações serem declaradas, desde que definidos em alguma equação posterior. A resolução também considera escopos, parâmetros de funções e identificadores embutidos e matem em memória uma lista da ordem correta de avaliação das declarações. Essa lista é essencial para geração de código GLSL, onde referências a variáveis antes de suas definições são proibidas. 

Para implementar essas funcionalidades, o \texttt{checker} realiza múltiplas passadas na AST, duas são para resolução de símbolos e a última é para validação das equações, na seguinte ordem:

\begin{enumerate}
    \item \textbf{Coleta de Símbolos}:
    \begin{itemize}
        \item Coletar todos identificadores nas declarações
        \item Registrar símbolos nos escopos apropriados
        \item Inicializar estruturas de rastreamento de dependências.     \end{itemize}

    \item \textbf{Análise de Dependências}:
    \begin{itemize}
        \item Construir o grafo de dependências. Estruturas podem ser vistas no \autoref{cod-symbol-graph}, um simples grafo que associa um símbolo a outros símbolos dos quais depende
        \item Validar referências de símbolos, incluindo detectar uso de símbolos que nunca foram definidos
        \item Estabelecer a ordem de avaliação por meio de ordenação topológica
    \end{itemize}

    \item \textbf{Validação Final}:
    \begin{itemize}
        \item Inferência e verificação de tipos
        \item Verificação do ponto de entrada
        \item Validação de definição de funções com uso de escopo
    \end{itemize}
\end{enumerate}

\begin{codigo}[htb]
    \caption{\small Estrutura de grafo de dependencias. }
    \label{cod-symbol-graph}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
Symbol_Dependency :: struct {
    dependencies: [dynamic]^Symbol,
}
Symbol_Graph :: map[^Symbol]Symbol_Dependency
\end{lstlisting}
\end{codigo}

% Cosegue lidar com escopo, parametros de funções e simbolos embutidos, aqueles padrões dinifidos na tabela de convenções de simbolos matematiccos \autoref{@va trabahlhar vagabundo@}. Para isso exist multiplas passadas. A primeira coleta todos os simbolos. A segunda, analisa as dependencias e estabelece a ordem de avaliação. Por ultimo, o \texttt{checker} toma contra do restante das inferencias de tipos e outras validações

\begin{codigo}[htb]
    \caption{\small Entrada para o compilador que gera dependencia circular. }
    \label{cod-grafo-simbol-deps}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
\begin{equation}
    a = f
\end{equation}

\begin{equation}
    f = a
\end{equation}

\end{lstlisting}
\end{codigo}

\begin{figure}[H]
    \caption{\label{label} \small Erro reportado sobre dependencia circular.}
    \begin{center}
        \includegraphics[scale=0.5]{./Imagens/error-circular-deps.png}
    \end{center}
\end{figure}


\subsection{Inferencia de Tipos} \label{subsection-inferencia-tipos}


A função \verb`infer_type` serve para determinar o tipo de uma expressão sintática (representada por \verb`expr`) na AST durante a análise semântica. É usado um conjunto de regras para inferir e atribuir tipos à expressões. A base das regras são matematicas, como multiplicação entre numero real e vetor, produtor vetorial dentre dois vetores, assinatura de funções definidas, entre outras.


Essa função é projetada para lidar com todas construções que são expressões em \texttt{EquationLang}, como identificadores, operadores prefixados e infixados, chamadas de função e literais.

Inicialmente, a função verifica se o tipo da expressão já foi inferido (\verb"expr.ty_inferred"). Se sim, retorna o tipo previamente inferido, evitando processamento redundante. Caso contrário, prossegue com a inferência. O bloco central da função é um \verb"switch" que analisa os diferentes tipos de expressões derivadas de \verb"expr". Um trecho relevante dessa implementação está no \autoref{cod-type-inference}.

Para \textbf{identificadores} (\verb"Expr_Identifier"), verifica se o identificador corresponde a um vetor especial, como $\omega_i$ ou $\vec{v}$. Nesse caso, o tipo é inferido como $\mathbb{R}^3$ (vetor tridimensional). Identificadores específicos, como \verb"\pi" ou \verb"\epsilon", são atribuídos ao tipo numérico real ($\mathbb{R}$). Para outros identificadores, a função consulta o escopo atual para determinar o tipo, usando as estruturas detalhado na sessão \autoref{section-escope-table}.

\input{Content/Desenvolvimento/code/Infer}

Para \textbf{operações prefixadas} (\verb"Expr_Prefix"), como raiz quadrada (\verb"\sqrt") ou funções trigonométricas (\verb"\sin", \verb"\cos"), a função valida se o operando é numérico e atribui o tipo correspondente à expressão. Nas \textbf{operações binárias} (\verb"Expr_Infix"), a função realiza a inferência dos tipos dos operandos esquerdo e direito. Se os tipos não forem compatíveis, aplica regras específicas. Alguma dessas regras são:

\begin{itemize}
    \item A multiplicação de um número por um vetor ($2*\vec{n}$) ou a divisão de um vetor por um número ($\frac{\vec{u}}{\sqrt{\vec{u} \cdot \vec{u}}}$) resultam no tipo vetor ($\mathbb{R}^3$).
    \item Operações entre dois vetores ou dois números seguem as regras padrão associadas ao operador.
\end{itemize}

Outros casos incluem \textbf{literais}, como números (\verb"Expr_Number") e vetores literais (\verb"Expr_Vector_Literal"), cujos tipos são atribuídos diretamente como $\mathbb{R}$ (números reais) e $\mathbb{R}^3$ (vetores tridimensionais), respectivamente.



Para chamadas de função (\verb"Expr_Function_Call"), o tipo da expressão é determinado pelo tipo do primeiro valor retornado pela função. A validação dos argumentos é realizada em outra função, detalhada na \autoref{subsubsection-eq-func-defn}. % ; Essa parte já foi dita
% Além disso, a função realiza validações específicas para evitar inconsistências, como garantir que operações entre vetores sejam semanticamente válidas (e.g., divisão entre vetores não é permitida). 

% Em resumo, \verb`infer_type` é uma implementação robusta e flexível de inferência de tipos, essencial para a análise semântica de um compilador. A função assegura que cada expressão receba um tipo coerente com a semântica da linguagem, lidando com uma ampla gama de construções sintáticas e oferecendo suporte extensível para futuras adições à linguagem.

\subsection{Validação de Equaçoes}


%%%%

Declarações de equações são validadas após a etapa de coleta e ordenação descrita em \autoref{subsection-sym-resolution}, portanto assume-se que o lado esquerdo das equações deve ser um identificador válido ou a definição de uma função. Esse processo também verifica redefinições de símbolos, prevenindo múltiplas declarações do mesmo identificador no mesmo escopo.

Todas as violações semânticas, como incompatibilidades de tipos ou uso de valores escalares onde vetores são esperados, são reportadas ao usuário, juntamente com informações detalhadas sobre o contexto e o local do erro, como descrito na \autoref{subsection-erros}.

A função \verb"check_expr" realiza uma traversia similiar a interencia de tipos e é ser responsável por chamar \texttt{infer\_type}. Nessa função, a análise de expressões que \texttt{infer\_type} deixou de fazer são feitas para todas os tipos de expressões, alguns dessas validações estão listado logo após este paragrafo. O recorte dessa traversia pode ser visto no \autoref{eq-function-check-expr}.

\begin{itemize}
    \item **Expressões de chamada de função (\verb`Expr_Function_Call`)**: Verifica se estamos fazendo a chamada com um identificador, pode ocoprrer o caso de tentar fazer a chamada com um número $123(x,y)$, e isso está incorreto.
    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**: Verifica operadores (\verb`-`, \verb`+`) e funções como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compatíveis, gerando erro caso contrário.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**: Garante que vetores tenham exatamente 3 dimensões, reportando erros para formatos inválidos.
\end{itemize}







\begin{codigo}[htb]
    \caption{\small Identificadores embutidos pela convenção deste trabalho.}
    \label{cod-builtins}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
BUILTIN_IDENTIFIERS :: []string {
    `\max`,
    `\pi`,
    `\epsilon`,
    `\theta{h}`,
    `\vec{n}`,
    `\vec{h}`,
    `\vec{\omega{i}}`,
    `\theta{i}`,
    `\phi{i}`,
    `\vec{\omega{o}}`,
    `\theta{o}`,
    `\phi{o}`,
    `\theta{h}`,
    `\theta{d}`,
}
\end{lstlisting}
\end{codigo}


\input{Content/Desenvolvimento/code/Check}


\subsection{Validação de Funções}
A validação semântica de definições e chamadas de funções segue um processo semelhante ao da análise de expressões, mas com o uso da pilha de escopos.
Nas definições de funções, as variáveis no corpo da função (lado direito da equação) são validadas para assegurar que todos os símbolos usados realmente estejam definidos no escopo da função. Já nas chamadas de funções, os argumentos fornecidos são comparados aos parâmetros esperados para validação.



\subsubsection{Definição de Funções} \label{subsubsection-eq-func-defn}

O procedimento \verb"check_function_definition" implementa a validação para definições de função, garantindo segurança de tipos e consistência de parâmetros. Ela é responsável pelas tarefas à seguir:

\begin{enumerate}
    \item Inferir os tipos para cada parâmetro
    \item Inferir o tipo de retorno com base na expressão final.
    \item Construir o tipo completo da função, incluindo parâmetros e retorno.
    \item Garantir que todos os identificadores utilizados estejam consistentes com seus tipos declarados.
    \item Validar todas as expressões no corpo da função.
    \item Criar um novo escopo para os parâmetros da funçã\textbackslash{}o
\end{enumerate}
%%%

O processo começa com o processamento dos parâmetros e o gerenciamento do escopo, como aparece no \autoref{cod-func-defn}. Quando uma função é definida, o sistema cria um novo escopo para armazenar informações dos parâmetros e da própria função em forma de símbolos a serem adicionados ao escopo atrelado a essa definição.

Esse escopo com simbolos são essencial para validar tanto as chamadas de função quanto as expressões no corpo da função. Cada função tem seu próprio escopo, cujo escopo pai é o global, prevenindo conflitos de identificadores.

O controle de visibilidade de símbolos é feito de forma específica. Na definição de escopo, se o $x$ existe nos parâmetros, primeiro é usado o $x$ do parâmetro antes de tentar acessar um $x$ global. Isso é chamado de \textit{shadowing} ou sombreamento do símbolo, como no caso da equação \autoref{eq-shadowing}, o resultado de $f$ é 3 e não 2.

\begin{align} \label{eq-shadowing}
    &x = 2 \\
    &g(x) = x \\
    &f = g(3)
\end{align}


%%%
Durante a validação dos parâmetros, cada identificador passa por um processo de inferência de tipo. Parâmetros marcados explicitamente com o prefixo \verb"\vec" recebem o tipo padrão $\mathbb{R}^3$ (vetor tridimensional), enquanto os demais são tratados como número real ($\mathbb{R}$).

A validação de identificadores no corpo da função utiliza o escopo da função para realizar três verificações principais: confirmar se o identificador está definido, verificar a compatibilidade do seu tipo com o símbolo no escopo e garantir que não haja violação das regras semânticas.

Por exemplo, um parâmetro $\vec{x}$ é declarado como vetor. Neste caso, todas as operações envolvendo $x$ no corpo da função devem respeitar as operações vetoriais; caso contrário, um erro será automaticamente reportado.

\subsubsection{Chamada de Funções}
Chamadas de função passam por uma validação semelhante: os argumentos têm seus tipos inferidos e são comparados com a assinatura da função chamada (\verb"Type_Function").

No exemplo da \autoref{cod-type-mismatch}, a função $g$ possui a assinatura $\mathbb{R} \times \mathbb{R} \to \mathbb{R}$, significando que espera dois números reais como entrada e retorna um número real. A expressão resultante da chamada de função terá o tipo do contradomínio da função. Também é necessário confirmar que $g$ refere-se a um símbolo do tipo função.

Se a função $f$ esperar dois números reais como argumentos e um vetor for passado no lugar de um deles, um erro será gerado. A \autoref{fig-type-mismatch} ilustra esse erro, indicando precisamente o argumento incompatível. Na hora de passar os argumentos também validamos que o quantidade de argumentos correspondem ao numero de parâmetros esperados.


\begin{codigo}[htb]
    \caption{\small Equação com uso incorreto de tipos na chamada de função. }
    \label{cod-type-mismatch}
\begin{lstlisting}[language=tex, numbers=none, frame=none, inputencoding=latin1]
\begin{equation}
    g(a, x) = a*x*x
\end{equation}

\begin{equation}
    f = g(1, \vec{1,1,1})
\end{equation}

\end{lstlisting}
\end{codigo}

\begin{figure}[H]
    \caption{\label{fig-type-mismatch} \small Erro gerado por uso incorreto de tipos na chamada de função.}
    \begin{center}
        \includegraphics[scale=0.5]{./Imagens/error-type-mismatch.png}
    \end{center}
\end{figure}


\begin{codigo}[htb]
    \caption{\small Validação de parametros de uma função. }
    \label{cod-parametros-validation}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
// ...
parameter_types := [dynamic]^Type{}
scope_enter(fn_sym.scope) {
    for &parameter in fn.parameters {
        parameter_key := key_from_identifier(parameter)
        ty := infer_type(parameter, true, ty_number)
        parameter_sym.type = ty
        append(&parameter_types, ty)
    }
}
// ...
\end{lstlisting}
\end{codigo}


\begin{codigo}[htb]
    \caption{\small Validação de um uníco identificador dentro de contexto de parametros de uma função. }
    \label{cod-check-single-ident}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]

check_single_identifier :: proc(parameters: []^ast.Expr_Identifier, ident: ^ast.Expr_Identifier) {
    infer_type(ident)
    ident_key := key_from_identifier(ident)
    // Validates type consistency between declaration and usage
    if !is_type_equal(ident.ty_inferred, p.ty_inferred) {
        error(ident.identifier, "Parameter `%v` being use as type `%v` when the expected type is `%v`", ...)
    }
    // Código omitido por brevidade ..
}
\end{lstlisting}
\end{codigo}


\begin{codigo}[htb]
    \caption{\small Gerenciamento de escopo na validação do corpo da função.}
    \label{cod-scope-management}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
scope_enter(fn_sym.scope) {
    // Validação do corpo da função
    check_expr(body)
    // Inferência e validação de tipo
    body_type := infer_type(body)
}
\end{lstlisting}
\end{codigo}


\begin{codigo}[htb]
    \caption{\small Estruturas que representam o tipo de um expressão da AST.}
    \label{cod-types-structs}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=utf8]
case ^Decl_Equation:
    check_decl(s)

scope_enter(fn_sym.scope) {
    // Validação do corpo da função
    check_expr(body)
    // Inferência e validação de tipo
    body_type := infer_type(body)
    result_types := [dynamic]^Type{body_type}
    fn_type := make_function_type(parameter_types[:], result_types[:])
}
\end{lstlisting}
\end{codigo}

