
\section{Geração de Código (\texttt{emitter})} \label{section-emitter}

A fase de geração de código é responsável por transformar as estruturas intermediárias, como a AST anotada, em código de \textit{shading} GLSL. O pacote \texttt{emitter} realiza essa transformação, emitindo código compatível com a ferramenta da Disney BRDF Explorer.

A entrada principal para esse processo é o escopo global, que contém todas as informações necessárias para gerar o programa completo, como escopos filhos, simbolos, assinatura de funções e tipos. Nesta etapa, a AST está completamente anotada com tipos e informações auxiliares, acessíveis por meio dos símbolos presentes na tabela de símbolos que será usado geração de funções e expressões no formato apropriado.

Como o programa já foi validado anteriormente, assume-se sua corretude semântica, permitindo a travessia recursiva de todos os simbolos e nós, sem fazer nenhuma validação extra. A traversia abrange a geração de código para definições de funções, expressões e elementos específicos, como os lados esquerdo (LHS do inglês left hand side) e direito (RHS do inglês right hand side) das equações.

O lado esquerdo (LHS) pode envolver identificadores com subexpressões (e.g., $f_{n+1} = \dots$), parâmetros em definições de funções ou simplesmente símbolos como vetores ou números. A abordagem detalhada para o LHS é apresentada na \autoref{sec-LHS}. Já o lado direito (RHS) é sempre uma expressão, exigindo o uso do pacote \texttt{walker} para fazer a traversia da árvore para traduzir as operações e tipos inferidos para o equivalente em GLSL. Esse processo é explorado em \autoref{sec-RHS}.

Um ponto crucial é a necessidade de garantir que cada variável tenha um nome único no código GLSL, conforme detalhado em \autoref{sec-unicidade}.

\subsection{Emissão de Equações}

A emissão de código começa pelo lado esquerdo da equação. Existem três aspectos principais nesse processo:
\begin{enumerate}
    \item Mapeamento de Tipos (LHS): O tipo associado ao identificador é a primeira informação a ser resolvida. Caso seja um número real, ele é mapeado para \verb"float" em GLSL. Para vetores ($\mathbb{R}^3$), o mapeamento é feito para \verb"vec3", que representa vetores tridimensionais. Em definições de funções, utiliza-se o simbolo da funlão para acessar os tipos de parâmetros e do retorno, construindo assim a assinatura da função no formato GLSL.

    \item Identificador (LHS): O identificador associado ao símbolo é traduzido conforme regras específicas que garantem unicidade e conformidade com as restrições do GLSL. Este processo é detalhado em \autoref{sec-unicidade}.

    \item Expressões (RHS): No caso do lado direito da equação, tanto funções quanto de variaveis, são expressões. Para gerar isso, realiza-se uma travessia da AST, mapeando nós de expressões (como somas e chamadas de funções trigonométricas) para seu equivalente em GLSL. Detalhes adicionais sobre a emissão de código para expressões estão na \autoref{}.
\end{enumerate}





\subsection{Unicidade de Variáveis} \label{sec-unicidade}

Para garantir unicidade e compatibilidade dos identificadores gerados no GLSL, é necessário lidar com algumas restrições sintáticas e evitar colisões entre identificadores.

\begin{enumerate}
    \item \textbf{Restrição de Caracteres}: O GLSL não permite caracteres especiais, como \verb"{" e \verb"}", em seus identificadores. Por exemplo, uma equação em \texttt{EquationLang} \verb "f_{1} = 2" não pode ser diretamente transformada no identificador \verb`f_{1}`. Para resolver isso, todos os caracteres inválidos são substituídos por sublinhados (\verb`_`), considerando subexpressões, resultando em identificadores como \verb`f__1_`.

    \item \textbf{Prevenção de Colisões}: Mesmo após a substituição de caracteres, podem ocorrer colisões. Para resolver isso, mapeia-se cada a simbolo de identificador cada para um inteiro único de 64 bits (ID). Esse ID é então concatenado ao começo desse identificador com o prefixo \verb`var`, resultando em \verb`var12345_f__1_`; uma cadeia de carateres unica para simbolo.

    \item \textbf{Remoção de Sequências Reservadas}: O GLSL reserva identificadores que contêm duas ou mais ocorrências consecutivas de \verb`_`, Também é necessário remover sublinhados ao final, resultando em \verb`var12345_f_1`. Após a geração inicial, identificadores que contenham essas sequências são corrigidos para atender às restrições do GLSL, resultado.
\end{enumerate}


Essas etapas garantem que cada variável no código GLSL seja única e válida. Apesar da limitação de $2^{64} - 1$ identificadores distintos imposta pelo uso de inteiros de 64 bits, esse valor é mais do que suficiente para o propósito de criação de BRDFs. Caso necessário, a utilização de inteiros de tamanho arbitrário implementado por \textit{software} para ampliar esse limite.

%%%%%%%


\subsection{Geração de Expressões}



A geração de expressões é uma das etapas mais importantes no processo de compilação e ocupa uma parte substancial do pacote \texttt{emitter}. Essa tarefa consiste em emitir código paras todas as expressões do lado direito das equações em código GLSL válido usando a AST anotada com tipos inferidos.

A implementação é realizada na função \verb"emit_expr", que recebe um nó de expressão e uma referência a um objeto \verb"StringBuilder" (da biblioteca padrão de Odin). Este objeto é utilizado para construir a cadeia de caracteres que corresponde a expressão equivalente em GLSL, evitando concatenações excessivas de strings.

A travessia da AST é realizada de forma recursiva utilizando o pacote \texttt{walker}, que converte diferentes tipos de expressões, incluindo operações binárias, prefixas, vetoriais e chamadas de função para código GLSL. Para isso, a função discrimina o tipo de nó, determinando qual operação correspondente deve ser utilizada em GLSL. Um recorte dessa função pode ser observado no \autoref{cod-emit-expr}, onde a discriminação é feita por meio da palavra-chave \texttt{case}, e a construção de strings para funções trigonométricas é realizada na instância de \texttt{StringBuilder} através da função \verb|sbprint|. A seguir, detalharemos as principais categorias de expressões tratadas:

\begin{enumerate}
    \item \textbf{Expressões Prefixas (\texttt{Expr\_Prefix})}:
    Essas expressões incluem operações unárias e funções matemáticas básicas. A implementação:
    \begin{itemize}
        \item Emite funções trigonométricas através dão funlão providas por GLSL autometicamente, como \verb|sin|, \verb|cos| e \verb|tan|.
        \item Lida com operadores unários, como negação (\verb|-|) e raiz quadrada (\verb|sqrt|). Nesses casos é aplicar escrever o operador com parentesis ao redor. Por exemplo, \verb"\sqrt{-2}" ($\sqrt{-2}$) emite \verb"(sqrt(-(2)))".
        \item Constrói vetores usando o construtor provido por OpenGL \verb|vec3()|.
        \item Mantém a precedência de operadores adicionando parênteses apropriados.
    \end{itemize}

    \item \textbf{Expressões Binárias (\texttt{Expr\_Infix})}:  
    Operações binárias representam a maior parte das expressões matemáticas.
    \begin{itemize}
        \item Operações aritméticas básicas (\verb|+|, \verb|-|, \verb|*|, \verb|/|), basta adionar parenteses com o operador no meio, e emitir a esquerda e direita recursivamente.
        \item Produto interno (\verb|dot|).
        \item Multiplicação escalar-vetor é suportado por GLSL, então fica similair ao original \verb"\vec{n} \cdot 2" equivalente à \verb"(vec3(n)*2)".
        \item Suporta o produto vetorial (\verb|cross|). Nesse caso o operador vem primeiro, \verb"\vec{n_1} \cross $\vec{n_2}$" equivalente à \verb"cross(vec3(var_1_n_1),vec3(var_2_n_2))".
        \item Processa exponenciação (\verb|x^y|) chamando a função \verb|pow()| do GLSL.
    \end{itemize}

    \item \textbf{Expressões Literais e Agrupamentos}:
        \item Constrói vetores literais utilizando \verb|vec3|.
        \item Adicionar parentesis em expressões agrupadas.
    \end{itemize}

    \item \textbf{Expressões Chamadas de Função}:  
        Na geração de uma chamada de função, ocorre a chamada recursiva para emitir a expressão do indentificador dessa função, depois abre parentesis \verb"(", e emite uma expressão para cada argumentos separado por virgula, demonstrado no recorte do \autoref{cod-emission-func}.

    \end{itemize}
\end{enumerate}

\begin{codigo}[htb]
    \caption{\small Emissão de chamada de funlões. }
    \label{cod-emission-func}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]

        case ^Expr_Function_Call:
        emit_expr(sb, e.left)
        sbprint(sb, '(')
        for arg, idx in e.exprs {
            emit_expr(sb, arg)
            if idx < (len(e.exprs) -1)  {
                sbprint(sb, ',')
            }
        }
        sbprint(sb, ')')
\end{lstlisting}
\end{codigo}

Esse sistema permite traduzir expressões matemáticas como mostado em \autoref{eq-emit-expr-example}, gerando o código correspondente apresentado em \autoref{cod-emit-expr-example}.

A emissão de expressões é implementada na função \verb`emit_expr`. Essa função aceita uma nó expressão qualquer e um referencia à uma lista de caracteres (tipo `StringBuilder` disponibilizado pela biblioteca padrão de Odin) onde ira escrever um código GLSL correto. Para isso é realizado a travessia recursiva da (AST), usando \texttt{walker} convertendo todas as expressões binárias, prefixas, chamada de funções,  e operações vetoriais em código GLSL válido. A a função checa o tipo do da expressão em um \verb`switch` discriminado para processar diferentes tipos de nós da AST, . As principais categorias de expressões tratadas são:

1. Expressões prefixas (\verb`Expr_Prefix`):
   - Implementa a emissão de funções trigonométricas (sin, cos, tan, asin, acos, atan)
   - Processa operadores unários como negação (-) e raiz quadrada (sqrt)
   - Realiza a conversão de vetores através da construção vec3()
   - Mantém a precedência de operadores através de parênteses apropriados

2. Expressões binárias (\verb`Expr_Infix`):
   - Gerencia operações aritméticas básicas (+, -, *, /)
   - Implementa tratamento especial para multiplicação vetorial, diferenciando:
     * Produto interno entre vetores
     * Multiplicação escalar-vetor
     * Multiplicação escalar-escalar
   - Processa operações vetoriais, a unica que damos suporte é produto vetorial (\verb`cross`).
   - Exponenciação (\verb'x ^ y') é implementada fazendo chamanda a função \verb`pow()` que embutida em GLSL.

3. Expressões Literais e Identificadores:
   - Processa literais numéricos com formatação apropriada para GLSL
   - Gerencia a conversão de identificadores mantendo a consistência com o escopo
   - Implementa a construção de literais vetoriais através do construtor vec3

4. Expressões Agrupadas e Chamadas de Função:
   - Preserva a precedência de operadores através de parênteses
   - Implementa a emissão de chamadas de função com suporte a múltiplos argumentos
   - Mantém a separação adequada de argumentos através de vírgulas

A função utiliza um StringBuilder para construção eficiente, evitando concatenações excessivas durante a emissão do código. O sistema implementa verificações de tipo em tempo de compilação para garantir a corretude das operações vetoriais e escalares, essencial para a geração de código GLSL válido.

Esta implementação consegue traduzir as expressões matemáticas como na \autoref{eq-emit-expr-example} e emitir o \autoref{cod-emit-expr-example} na linguagens de shading.

\begin{subequations}
\begin{equation}
    \rho_{d} = \vec{0,1,1}
\end{equation}

\begin{equation}
    \rho_{s} = \vec{1,0,1}
\end{equation}

\begin{equation}
    n = +2^8
\end{equation}

\begin{equation}
f = \frac{\rho_{d}}{\pi} + \rho_{s} * \frac{n+2}{2*\pi} *
\cos{\theta_{h}}^{n}
\end{equation}
\end{subequations}

\begin{codigo}[htb]
   \caption{\small Exemplo de código de expressão gerado. }
   \label{cod-emit-expr-example}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
  var_12_rho_d = vec3(0.0, 1.0, 1.0);
  var_13_n     = pow(2.0, 8.0);
  var_14_rho_s = vec3(1.0, 0.0, 1.0);
  var_15_f     = ((var_12_rho_d / var_1_pi) +
              ((var_14_rho_s * ((var_13_n + 2.0) / (2.0 * var_1_pi))) *
               pow(cos(var_10_theta_h), var_13_n)));
\end{lstlisting}
\end{codigo}

\begin{codigo}[htb]
   \caption{\small Emitir expressão. }
   \label{cod-emit-expr}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
    case ^Expr_Prefix:
        #partial switch e.op.kind {
        case .ArcSin:
            sbprint(sb, "asin(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        //... Outros casos omissos

        case .Tan:
            sbprint(sb, "tan(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
        case .Exp:
            sbprint(sb, "exp(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
        case .Vec:
            ty_vec, ok := e.ty_inferred.derived.(^ast.Type_Vector)
            assert(ok && ty_vec.dimensions == 3)

            sbprint(sb, "vec3(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
    case ^Expr_Infix:
        op: string
        #partial switch e.op.kind {
        case .Plus:  op = "+"
        case .Minus: op = "-"
        case .Mul:
            // Check if both operands are vectors
            if is_vector(e.left.ty_inferred) && is_vector(e.right.ty_inferred) {
                sbprint(sb, "dot(")
                emit_expr(sb, e.left)
                sbprint(sb, ",")
                emit_expr(sb, e.right)
                sbprint(sb, ")")
                return
            } else {
                op = "*"
            }
        case .Frac, .Div:  op = "/"
        // Especially handled because it's not infix in glsl
        case .Caret: op = ""
            sbprint(sb, "pow(")
            emit_expr(sb, e.left)
            sbprint(sb, ",")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        //... Outros casos omissos
        case .Cross: op = ""
            sbprint(sb, "cross(")
            emit_expr(sb, e.left)
            sbprint(sb, ",")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        sbprint(sb, '(')
        emit_expr(sb, e.left)
        sbprint(sb, op)
        emit_expr(sb, e.right)
        sbprint(sb, ')')


   //... 

\end{lstlisting}
\end{codigo}
---
\subsection{Começo da Emissão}%
\label{sub:start-emitting}

A função \verb`emit` representa o ponto de entrada do processo de emissão de código, implementando a transformação final AST em um shader GLSL analítico. Esta função opera em três fases distintas e cruciais:

1. Fase de Inicialização e Estruturação:
   - Estabelece o formato canônico do shader através da emissão de cabeçalhos específicos
   - Implementa uma seção de parâmetros que permite a parametrização do shader
   - Delimita claramente as seções do código através de marcadores (::begin shader, ::end shader), são necessário para carregar o shading na ferramenta da Disney
   - Emite as declarações de funções embutidas (comumente chamda de \verb`built-in`) necessárias para o funcionamento do shader

2. Fase de Processamento de Símbolos:
   - Itera sobre uma tabela de símbolos ordenada (\verb"Scope")
   - Processa três categorias principais de símbolos:
     * Variáveis numéricas escalares (\verb"Type_Basic")
     * Definições de funções (\verb"Type_Function")
     * Variáveis vetoriais (\verb"Type_Vector")
   - Mantém separação entre declarações e definições através de builders distintos
   - Implementa um sistema de buffer duplo onde as equações são acumuladas separadamente das declarações, isso é feito para simular escopo global em GLSL.

3. Fase de Emissão Final:
   - Concatena as declarações de funções em ordem apropriada
   - Emite a função de entrada (entry point) chamado \verb`BRDF`, entrada necessaria para ferramenta Disney.
   - Realiza a escrita do código gerado em arquivo através de operações de I/O seguras
   - Implementa verificação de erros na escrita do arquivo

A função mantém uma clara separação de responsabilidades através de seções comentadas (START OF BUILTINS DECLARATION, START OF USER DECLARED, etc), facilitando a manutenção e depuração do código gerado. O sistema implementa um mecanismo de diferenciação entre símbolos built-in e definidos pelo usuário, garantindo que não haja duplicação de declarações.

Uma característica notável é a utilização de um sistema de builders para construção eficiente de strings, minimizando a sobrecarga de memória durante a geração do código. A função também implementa um sistema de gestão de recursos através do uso de `defer` para limpeza adequada dos builders.

O processo de emissão é crucial para a geração de shaders GLSL válidos, pois mantém a ordem correta de declarações e definições, essencial para a compilação posterior pelo compilador GLSL. A função retorna um booleano indicando o sucesso da operação de escrita, permitindo tratamento adequado de erros em níveis superiores do compilador.

Estas funções implementam a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL, estabelecendo as variáveis fundamentais para computação de interações luz-material. As variaveis enbutidas são aquelas definidas na tabelas @@@, que são a angulo de incidencia, entre outros, a ferramenta disney oferece algumas dessas variaveis embutidas como parametro para função de entrada \verb`BRDF`, mas com convenções de nomes diferentes do estabelicdo neste trabalho. Essas são:
      \verb`normal_vector`: normal da superfície (N)
      \verb`omega_i`: direção da luz incidente (L)
      \verb`omega_o`: direção de visualização (V)
Todas as outras são calculadas por nós e gerado para todas as entradas automaticamente, pronto para uso em qualquer equação.
Para calcular as embutidas \verb"omega_i", \verb"theta_d", \verb"phi_i", etc.., é foi desenvolvida algumas funções auxiliares de coordenadas esféricas:

   - A função \verb`phi(v)` calcula o ângulo azimutal ($\phi$) a partir de um vetor:
     - Implementa a conversão de coordenadas cartesianas para esféricas
     - Utiliza \verb"\atan(sqrt(y² + x²), z)" para computar $\phi$
   - A função \verb`theta(v)` calcula o ângulo polar ($\theta$):
     - Implementa atan(y, x) para computação do ângulo no plano xy

Assim podemos podemos fazer declaração das variáveis built-in  ( através da função \verb`emit_builtin_globals_declaration`):
     - \verb`half_vector`: vetor intermediário entre direção de luz e visualização (H)
     - \verb`normal_vector`: normal da superfície (N)
     - \verb`omega_i`: direção da luz incidente (L)
     - \verb`omega_o`: direção de visualização (V)
   
   - Ângulos Esféricos:
     - \verb`theta_h`: ângulo entre H e N
     - \verb`theta_d`: ângulo entre H e L
     - \verb`theta_i`: ângulo polar da luz incidente
     - \verb`theta_o`: ângulo polar da visualização
     - \verb`phi_i`: ângulo azimutal da luz incidente
     - \verb`phi_o`: ângulo azimutal da visualização

E também constantes matemáticas:
     - \verb`pi`: valor de $\pi$
     - \verb`epsilon`: valor de precisão numérica


A função \verb`emit_builtin_entry_function` encapsula toda esta lógica na função BRDF principal. 
- Recebe os vetores de entrada (L, V, N, X, Y), X e Y não usados.
- Inicializa todas as variáveis built-in, seu código gerado das variaveis embutidas pode ser visto em \autoref{cod-builtins-emitted}
- Incorpora as equações específicas do usuário
- Retorna o valor final da BRDF como um vec3

Este sistema fornece uma base suficiente para implementação de BRDFs complexas. 
\begin{codigo}[htb]
    \caption{\small Recorte da função BRDF one as variaveis built-ins são inicializadas }
    \label{cod-builtins-emitted}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
  //////////// START OF BUILTINS INITIALIZATION ////////////
  var_0_vec_h = normalize(L + V);
  var_3_vec_n = normalize(N);
  var_1_pi = 3.141592653589793;
  var_2_epsilon = 1.192092896e-07;
  var_4_vec_omega_i = L;
  var_5_theta_i = atan(var_4_vec_omega_i.y, var_4_vec_omega_i.x);
  var_6_phi_i = atan(sqrt(var_4_vec_omega_i.y * var_4_vec_omega_i.y +
                          var_4_vec_omega_i.x * var_4_vec_omega_i.x),
                     var_4_vec_omega_i.z);
  var_7_vec_omega_o = V;
  var_8_theta_o = atan(var_7_vec_omega_o.y, var_7_vec_omega_o.x);
  var_9_phi_o = atan(sqrt(var_7_vec_omega_o.y * var_7_vec_omega_o.y +
                          var_7_vec_omega_o.x * var_7_vec_omega_o.x),
                     var_7_vec_omega_o.z);
  var_10_theta_h = acos(dot(var_0_vec_h, N));
  var_11_theta_d = acos(dot(var_0_vec_h, var_4_vec_omega_i));
  //////////// END OF BUILTINS INITIALIZATION ////////////
\end{lstlisting}
\end{codigo}




---------

Nos resultados eu falo mais XD emissão

Uma coisa imporatnte a se dizer é todas em EquationLang todas as equações podem ser referenciadas em ourtas equações para isso pode ser possivel em GLSL, declarações todas as variaveis primeiro fora da função BRDF, efetivamente deixando-as globais. E só ao entrar na função é que inicializados, isso vale para as variaveis embutidas tbm \autoref{cod-builtins}. Isso é feito principalmente para deixar as variaveis visiveis dentro um função em GLSL assim como semanticamente é possivel em EquationLang. @Diga pra nota em agluma imagem mostrando isso@ Outra coisa é que todas as equaqações estão na ordem correta de avaliação já que isso foi feito através da ordernação topológica feita anteriormente, então as decalarções globais são cosistente, sempre, e vão conseguir rodar no GLSL @informal@.

\subsection{Emissão de Definições de Função}
A emissão de definições de função segue um processo similiar ao de equações, mas o LHS é diferente. Geração de assinatura de função. O RHS sempre é um exp´ressão então a mesma lógica de regração de expresão pode ser usado para o copo dessa função. O mesmo mapeamento de tipos de parâmetros.

\begin{itemize}
   \item Extração de tipo de retorno, extraido pelo campo results em \autoref{thingy}
   \item Processamento de identificadores de função, usando a estratégia citada na \autoref{sec-unicidade}
   \item Geração dos parametros entre parenteses, inclue tipo e nome da variaveis, também na estratégia \autoref{sec-unicidade}  ncparamétrica tipada, seguido
   % \item Emissão de corpo de função, que consiste no token `\verb{`, seguido da palavra-chave return, agora chamada recursiva para \verb`emit_expr`, \verb`;` e por fecha chave \verb`}`.
\end{itemize}

A parametrização implementa um mapeamento bijetivo entre tipos inferidos e representações GLSL, garantindo preservação semântica durante a tradução.
Um exemplo de da geração de um definição de função pode ser visto no \autoref{cod-normalize-reflect}, emitido pelas funções de reflexão e normalização definidos na equação \autoref{eq-normalize-reflect}. Note que os nomes gerados seguem a enumeração dita na \autoref{sec-unicidade} e que o retorno pode ser avaliada à uma unica expressão.


\label{eq-normalize-reflect} \begin{subequations}
\begin{equation}
  \text{normalize}(\vec{u}) = \frac{\vec{u}}{\sqrt{\vec{u} \cdot \vec{u}}}
\end{equation}

\begin{equation}
reflect(\vec I, \vec N) =  2*(\vec I \cdot \vec N)*\vec N - \vec I
\end{equation}
\end{subequations}

\begin{codigo}[htb]
   \caption{\small Código GLSL gerado pelo compilador para as funções de normalização e reflexão de vetores. }
   \label{cod-normalize-reflect}
\begin{lstlisting}[language=C, inputencoding=utf8]
//////////// START FUNCTIONS DECLARATIONS ////////////
vec3 var_13_reflect(vec3 var_14_vec_I, vec3 var_15_vec_N) {
    return (((2.0*(dot(var_14_vec_I,var_15_vec_N)))*var_15_vec_N)-var_14_vec_I);
}

vec3 var_17_text_normalize(vec3 var_18_vec_u) {
    return (var_18_vec_u/sqrt(dot(var_18_vec_u,var_18_vec_u)));
}
//////////// END FUNCTIONS DECLARATIONS ////////////

\end{lstlisting}
\end{codigo}
