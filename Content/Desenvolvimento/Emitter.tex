
\section{Geração de Código (\texttt{emitter})} \label{section-emitter}

A fase de geração de código é responsável por transformar as estruturas intermediárias, como a AST anotada, em código de \textit{shading} GLSL. O pacote \texttt{emitter} realiza essa transformação, emitindo código compatível com a ferramenta da Disney BRDF Explorer.

A entrada principal para esse processo é o escopo global, que contém todas as informações necessárias para gerar o programa completo, como escopos filhos, simbolos, assinatura de funções e tipos. Nesta etapa, a AST está completamente anotada com tipos e informações auxiliares, acessíveis por meio dos símbolos presentes na tabela de símbolos que será usado geração de funções e expressões no formato apropriado.

Como o programa já foi validado anteriormente, assume-se sua corretude semântica, permitindo a travessia recursiva de todos os simbolos e nós, sem fazer nenhuma validação extra. A traversia abrange a geração de código para definições de funções, expressões e elementos específicos, como os lados esquerdo (LHS do inglês left hand side) e direito (RHS do inglês right hand side) das equações.

O lado esquerdo (LHS) pode envolver identificadores com subexpressões (e.g., $f_{n+1} = \dots$), parâmetros em definições de funções ou simplesmente símbolos como vetores ou números. A abordagem detalhada para o LHS é apresentada na \autoref{sec-LHS}. Já o lado direito (RHS) é sempre uma expressão, exigindo o uso do pacote \texttt{walker} para fazer a traversia da árvore para traduzir as operações e tipos inferidos para o equivalente em GLSL. Esse processo é explorado em \autoref{sec-RHS}.

Um ponto crucial é a necessidade de garantir que cada variável tenha um nome único no código GLSL, conforme detalhado em \autoref{sec-unicidade}.

\subsection{Emissão de Equações}

A emissão de código começa pelo lado esquerdo da equação. Existem três aspectos principais nesse processo:
\begin{enumerate}
    \item Mapeamento de Tipos (LHS): O tipo associado ao identificador é a primeira informação a ser resolvida. Caso seja um número real, ele é mapeado para \verb"float" em GLSL. Para vetores ($\mathbb{R}^3$), o mapeamento é feito para \verb"vec3", que representa vetores tridimensionais. Em definições de funções, utiliza-se o simbolo da funlão para acessar os tipos de parâmetros e do retorno, construindo assim a assinatura da função no formato GLSL.

    \item Identificador (LHS): O identificador associado ao símbolo é traduzido conforme regras específicas que garantem unicidade e conformidade com as restrições do GLSL. Este processo é detalhado em \autoref{sec-unicidade}.

    \item Expressões (RHS): No caso do lado direito da equação, tanto funções quanto de variaveis, são expressões. Para gerar isso, realiza-se uma travessia da AST, mapeando nós de expressões (como somas e chamadas de funções trigonométricas) para seu equivalente em GLSL. Detalhes adicionais sobre a emissão de código para expressões estão na \autoref{}.
\end{enumerate}





\subsection{Unicidade de Variáveis} \label{sec-unicidade}

Para garantir unicidade e compatibilidade dos identificadores gerados no GLSL, é necessário lidar com algumas restrições sintáticas e evitar colisões entre identificadores.

\begin{enumerate}
    \item \textbf{Restrição de Caracteres}: O GLSL não permite caracteres especiais, como \verb"{" e \verb"}", em seus identificadores. Por exemplo, uma equação em \texttt{EquationLang} \verb "f_{1} = 2" não pode ser diretamente transformada no identificador \verb`f_{1}`. Para resolver isso, todos os caracteres inválidos são substituídos por sublinhados (\verb`_`), considerando subexpressões, resultando em identificadores como \verb`f__1_`.

    \item \textbf{Prevenção de Colisões}: Mesmo após a substituição de caracteres, podem ocorrer colisões. Para resolver isso, mapeia-se cada a simbolo de identificador cada para um inteiro único de 64 bits (ID). Esse ID é então concatenado ao começo desse identificador com o prefixo \verb`var`, resultando em \verb`var12345_f__1_`; uma cadeia de carateres unica para simbolo.

    \item \textbf{Remoção de Sequências Reservadas}: O GLSL reserva identificadores que contêm duas ou mais ocorrências consecutivas de \verb`_`, Também é necessário remover sublinhados ao final, resultando em \verb`var12345_f_1`. Após a geração inicial, identificadores que contenham essas sequências são corrigidos para atender às restrições do GLSL, resultado.
\end{enumerate}


Essas etapas garantem que cada variável no código GLSL seja única e válida. Apesar da limitação de $2^{64} - 1$ identificadores distintos imposta pelo uso de inteiros de 64 bits, esse valor é mais do que suficiente para o propósito de criação de BRDFs. Caso necessário, a utilização de inteiros de tamanho arbitrário implementado por \textit{software} para ampliar esse limite.

%%%%%%%


\subsection{Geração de Expressões}



A geração de expressões é uma das etapas mais importantes no processo de compilação e ocupa uma parte substancial do pacote \texttt{emitter}. Essa tarefa consiste em emitir código paras todas as expressões do lado direito das equações em código GLSL válido usando a AST anotada com tipos inferidos.

A implementação é realizada na função \verb"emit_expr", que recebe um nó de expressão e uma referência a um objeto \verb"StringBuilder" (da biblioteca padrão de Odin). Este objeto é utilizado para construir a cadeia de caracteres que corresponde a expressão equivalente em GLSL, evitando concatenações excessivas de strings.

A travessia da AST é realizada de forma recursiva utilizando o pacote \texttt{walker}, que converte diferentes tipos de expressões, incluindo operações binárias, prefixas, vetoriais e chamadas de função para código GLSL. Para isso, a função discrimina o tipo de nó, determinando qual operação correspondente deve ser utilizada em GLSL. 

Um recorte dessa função pode ser observado no \autoref{cod-emit-expr}, onde a discriminação dos tipos é feita é feita (\texttt{case}), e a construção de strings para funções trigonométricas é realizada na instância de \texttt{StringBuilder} através da função \verb|sbprint|. A seguir, são enumeradas as principais categorias de expressões tratadas:

\begin{enumerate}
    \item \textbf{Expressões Prefixas (\texttt{Expr\_Prefix})}:
    Essas expressões incluem operações unárias e funções matemáticas básicas. A implementação:
    \begin{itemize}
        \item Emite funções trigonométricas através dão funlão providas por GLSL autometicamente, como \verb|sin|, \verb|cos| e \verb|tan|.
        \item Lida com operadores unários, como negação (\verb|-|) e raiz quadrada (\verb|sqrt|). Nesses casos é aplicar escrever o operador com parentesis ao redor. Por exemplo, \verb"\sqrt{-2}" ($\sqrt{-2}$) emite \verb"(sqrt(-(2)))".
        \item Constrói vetores usando o construtor provido por OpenGL \verb|vec3()|.
        \item Mantém a precedência de operadores adicionando parênteses apropriados.
    \end{itemize}

    \item \textbf{Expressões Binárias (\texttt{Expr\_Infix})}:
    Operações binárias representam a maior parte das expressões matemáticas.
    \begin{itemize}
        \item Operações aritméticas básicas (\verb|+|, \verb|-|, \verb|*|, \verb|/|), basta adionar parenteses com o operador no meio, e emitir a esquerda e direita recursivamente.
        \item Produto interno, usa-se função \verb|dot| provida por GLSL.
        \item Multiplicação escalar-vetor é suportado por GLSL, então fica similair ao original \verb"\vec{n} \cdot 2" equivalente à \verb"(vec3(n)*2)".
        \item Suporta o produto vetorial (\verb|cross|). Nesse caso o operador vem primeiro, no lugar de infixo, \verb"\vec{n_1} \\ \cross $\vec{n_2}$" equivalente à  \\ \verb"cross(vec3(var_1_n_1),vec3(var_2_n_2))".
        \item Processa exponenciação (\verb|x^y|) chamando a função \verb|pow()| do GLSL.
    \end{itemize}

    \item \textbf{Expressões Literais e Agrupamentos}:
    \begin{itemize}
        \item Constrói vetores literais utilizando \verb|vec3|.
        \item Adicionar parentesis em expressões agrupadas.
    \end{itemize}

    \item \textbf{Expressões Chamadas de Função}:
        Na geração de uma chamada de função, ocorre a chamada recursiva para emitir a expressão do indentificador dessa função, depois abre parentesis \verb"(", e emite uma expressão para cada argumentos separado por virgula e, por fim, fecha o parentesis. Demonstrado no recorte do \autoref{cod-emission-func}.

\end{enumerate}

\begin{codigo}[htb]
    \caption{\small Emissão de chamada de funções. }
    \label{cod-emission-func}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]

        case ^Expr_Function_Call:
        emit_expr(sb, e.left)
        sbprint(sb, '(')
        for arg, idx in e.exprs {
            emit_expr(sb, arg)
            if idx < (len(e.exprs) -1)  {
                sbprint(sb, ',')
            }
        }
        sbprint(sb, ')')
\end{lstlisting}
\end{codigo}


 Esse sistema permite traduzir expressões matemáticas como mostado em \autoref{eq-emit-expr-example}, gerando o código correspondente apresentado em \autoref{cod-emit-expr-example}.

\begin{subequations}
\begin{equation}
    \rho_{d} = \vec{0,1,1}
\end{equation}

\begin{equation}
    \rho_{s} = \vec{1,0,1}
\end{equation}

\begin{equation}
    n = +2^8
\end{equation}

\begin{equation}
f = \frac{\rho_{d}}{\pi} + \rho_{s} * \frac{n+2}{2*\pi} *
\cos{\theta_{h}}^{n}
\end{equation}
\end{subequations}

\begin{codigo}[htb]
   \caption{\small Exemplo de código de expressão gerado. }
   \label{cod-emit-expr-example}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
  var_12_rho_d = vec3(0.0, 1.0, 1.0);
  var_13_n     = pow(2.0, 8.0);
  var_14_rho_s = vec3(1.0, 0.0, 1.0);
  var_15_f     = ((var_12_rho_d / var_1_pi) +
              ((var_14_rho_s * ((var_13_n + 2.0) / (2.0 * var_1_pi))) *
               pow(cos(var_10_theta_h), var_13_n)));
\end{lstlisting}
\end{codigo}

\begin{codigo}[htb]
   \caption{\small Emitir expressão. }
   \label{cod-emit-expr}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
    case ^Expr_Prefix:
        #partial switch e.op.kind {
        case .ArcSin:
            sbprint(sb, "asin(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        //... Outros casos omissos

        case .Tan:
            sbprint(sb, "tan(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
        case .Exp:
            sbprint(sb, "exp(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
        case .Vec:
            ty_vec, ok := e.ty_inferred.derived.(^ast.Type_Vector)
            assert(ok && ty_vec.dimensions == 3)

            sbprint(sb, "vec3(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
    case ^Expr_Infix:
        op: string
        #partial switch e.op.kind {
        case .Plus:  op = "+"
        case .Minus: op = "-"
        case .Mul:
            // Check if both operands are vectors
            if is_vector(e.left.ty_inferred) && is_vector(e.right.ty_inferred) {
                sbprint(sb, "dot(")
                emit_expr(sb, e.left)
                sbprint(sb, ",")
                emit_expr(sb, e.right)
                sbprint(sb, ")")
                return
            } else {
                op = "*"
            }
        case .Frac, .Div:  op = "/"
        // Especially handled because it's not infix in glsl
        case .Caret: op = ""
            sbprint(sb, "pow(")
            emit_expr(sb, e.left)
            sbprint(sb, ",")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        //... Outros casos omissos
        case .Cross: op = ""
            sbprint(sb, "cross(")
            emit_expr(sb, e.left)
            sbprint(sb, ",")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        sbprint(sb, '(')
        emit_expr(sb, e.left)
        sbprint(sb, op)
        emit_expr(sb, e.right)
        sbprint(sb, ')')


   //... 

\end{lstlisting}
\end{codigo}
---
\subsection{Fases do Processo de Geração do Shader}
\label{sub:start-emitting}

A função \verb"emit" é o ponto de partida do processo de emissão de código, onde ocorre a transformação final da AST em um shader GLSL. Este processo é dividido em três fases principais, cada uma com responsabilidades bem definidas para garantir a geração correta do código.

\begin{enumerate}
    \item \textbf{Inicialização e Estruturação} \\
    Nesta etapa inicial, o foco está em estabelecer a base do shader GLSL. Isso inclui:
    \begin{itemize}
        \item \textbf{Parâmetros}: Emissão de uma seção parametrizável, \verb"::begin parameters ::end parameters", dos shaders, requerida pela ferramenta Disney BRDF Explorer. 
        \item \textbf{Marcadores de Seção}: Adição de delimitadores como \verb|::begin shader| e \verb|::end shader|, que iniciam o código GLSL na ferramenta da Disney.
        \item \textbf{Built-in}s: Emissão das declarações e definições de variáveis e funções \textit{built-in} necessárias, para dar ao shader suporte às convenções da \autoref{table-conventions}.
    \end{itemize}

    \item \textbf{Processamento de Símbolos} \\
    Após a estruturação inicial, a função processa uma tabela de símbolos (\verb|Scope|) para organizar as declarações e definições necessárias. As operações nesta fase incluem:
    \begin{itemize}
        \item \textbf{Iteração sobre Símbolos}: Processamento de variáveis escalares (\verb|Type_Basic|), definições de funções (\verb|Type_Function|) e variáveis vetoriais (\verb|Type_Vector|).
        \item \textbf{Separação de Declarações e Definições}: Uso de duas instâncias distintas de \texttt{StringBuilder}, uma para declarações, que devem vir antes para que as variáveis possam ser usadas globalmente, e outra para definições que podem fazer uso dessas declarações sejam built-ins ou definidos pelos usuários.
    \end{itemize}

    \item \textbf{Emissão Final} \\
    A fase final concatena os elementos gerados anteriormente, garantindo que o código esteja na ordem correta para compilação. Essa fase gera a função principal \verb|BRDF|, que contém todas as declarações concatenadas, somadas às declarações e preâmbulos. Por fim, é realizada a gravação em disco do shader completo.
\end{enumerate}


\subsubsection{Variáveis Built-in}
A emissão correta de um shader de BRDF necessita da geração de variáveis \textit{built-in} diretamente no \textit{shader}, conforme ilustrado na \autoref{cod-builtins-emitted}. Essas variáveis, descritas na tabela \autoref{va trabalhar na tabela}, seguem as convenções estabelecidas e são inicializadas automaticamente de maneira padronizada dentro da função de entrada do \textit{shader}, denominada \verb|BRDF|, conforme o padrão da ferramenta Disney.

Essas variáveis fornecem a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL. A ferramenta Disney disponibiliza algumas delas como parâmetros da função de entrada \verb`BRDF`, mas com nomenclaturas diferentes das adotadas neste trabalho. Essas parametros são: \verb"N" que representa a normal da superfície; \verb"L" que indica a direção da luz incidente (L); \verb"V" que representa a direção de visualização. As demais variáveis são calculadas na emissão de código.

Para calcular variáveis como \verb`omega_i`, \verb`theta_d` e \verb`phi_i`, foram desenvolvidas funções auxiliares que produzem strings válidas em GLSL. A entrada dessas funções é uma string representando o vetor (\verb`v`), substituída diretamente no corpo do GLSL gerado:  
\begin{itemize}
    \item \verb`phi(v)`: Calcula o ângulo azimutal ($\phi$), gera \verb`atan(sqrt(v.y*v.y + v.x*v.x), v.z)`.
    \item \verb`theta(v)`: Calcula o ângulo polar ($\theta$) com a expressão \verb`atan(v.y, v.x)`.
\end{itemize}

A declaração dessas variáveis embutidas é realizada pela função \\ \verb`emit_builtin_globals_declaration`, que também define constantes matemáticas como \verb`\pi`  e \verb`\epsilon`. É apresentado na \autoref{tab-conventions} como cada convenção é mapeada para código GLSL. Para maior clareza, o prefixo das variáveis discutido na seção de unicidade (\autoref{sec-unicidade}) foi removido.

\begin{table}[h]
    \centering
    % \begin{tabular}{|c|l|}
    \begin{tabular}{c|l}
        \hline
        \textbf{Símbolo} & \textbf{Código GLSL Gerado} \\
        \hline
        $\theta_i$ & \verb"atan(omega_i.y, omega_i.x)" \\
        \hline
        $\theta_o$ & \verb"atan(omega_o.y, omega_o.x")\\
        \hline
        $\phi_i$ & \verb"atan(sqrt(omega_i.y*omega_i.y+omega_i.x*omega_i.x),omega_i.z)" \\
        \hline
        $\phi_o$ & \verb"atan(sqrt(omega_o.y*omega_o.y+omega_o.x*omega_o.x),omega_o.z")\\
        \hline
        $\omega_i$ & \verb"L " \\
        \hline
        $\omega_o$ & \verb"V " \\
        \hline
        $\vec{n}$ & \verb"normalize(N)" \\
        \hline
        $\vec{h}$ & \verb"normalize(L+V")\\
        \hline
        $\theta_h$ & \verb"acos(dot(vec_h , vec_n))" \\
        \hline
        $\theta_d$ & \verb"acos(dot(vec_h , omega_i))" \\
        \hline
        $\pi$ & \verb"3.141592653589793" \\
        \hline
        $\epsilon$ & \verb"1.192092896e-07" \\
        \hline
    \end{tabular}
    \caption{Tabela de mapeamento de conveções para código GLSL}
    \label{tab-conventions}
\end{table}

% Este sistema fornece uma base suficiente para implementação de BRDFs complexas.

\begin{codigo}[htb]
    \caption{\small Recorte da função BRDF one as variaveis built-ins são inicializadas }
    \label{cod-builtins-emitted}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
  //////////// START OF BUILTINS INITIALIZATION ////////////
  var_0_vec_h = normalize(L + V);
  var_3_vec_n = normalize(N);
  var_1_pi = 3.141592653589793;
  var_2_epsilon = 1.192092896e-07;
  var_4_vec_omega_i = L;
  var_5_theta_i = atan(var_4_vec_omega_i.y, var_4_vec_omega_i.x);
  var_6_phi_i = atan(sqrt(var_4_vec_omega_i.y * var_4_vec_omega_i.y +
                          var_4_vec_omega_i.x * var_4_vec_omega_i.x),
                     var_4_vec_omega_i.z);
  var_7_vec_omega_o = V;
  var_8_theta_o = atan(var_7_vec_omega_o.y, var_7_vec_omega_o.x);
  var_9_phi_o = atan(sqrt(var_7_vec_omega_o.y * var_7_vec_omega_o.y +
                          var_7_vec_omega_o.x * var_7_vec_omega_o.x),
                     var_7_vec_omega_o.z);
  var_10_theta_h = acos(dot(var_0_vec_h, N));
  var_11_theta_d = acos(dot(var_0_vec_h, var_4_vec_omega_i));
  //////////// END OF BUILTINS INITIALIZATION ////////////
\end{lstlisting}
\end{codigo}




% ---------
%
% Nos resultados eu falo mais XD emissão
%
% Uma coisa imporatnte a se dizer é todas em EquationLang todas as equações podem ser referenciadas em ourtas equações para isso pode ser possivel em GLSL, declarações todas as variaveis primeiro fora da função BRDF, efetivamente deixando-as globais. E só ao entrar na função é que inicializados, isso vale para as variaveis embutidas tbm \autoref{cod-builtins}. Isso é feito principalmente para deixar as variaveis visiveis dentro um função em GLSL assim como semanticamente é possivel em EquationLang. @Diga pra nota em agluma imagem mostrando isso@ Outra coisa é que todas as equaqações estão na ordem correta de avaliação já que isso foi feito através da ordernação topológica feita anteriormente, então as decalarções globais são cosistente, sempre, e vão conseguir rodar no GLSL @informal@.

\subsection{Emissão de Definições de Função}

A emissão de definições de função ocorre antes da inicialização das variáveis. Gera-se a assinatura da função, incluindo o nome (baseado na estratégia da \autoref{sec-unicidade}), o tipo de retorno e os parâmetros, mapeados conforme a \autoref{mapeamento de tipos}.  Os nomes dos parâmetros são determinados pelos símbolos presentes no escopo da função. Já o corpo da função é emitido chamando \verb|emit_expr|, semelhante à emissão de expressões.

O mapeamento entre tipos em \texttt{EquationLang} e GLSL é bijetivo, garantindo que qualquer função definida em \texttt{EquationLang} possa ser representada em GLSL. Um exemplo de definição gerada é mostrado na \autoref{cod-normalize-reflect}, emitida para as funções de reflexão e normalização da equação \autoref{eq-normalize-reflect}. Os nomes gerados seguem a numeração discutida na \autoref{sec-unicidade}, e o retorno é sempre avaliado como uma única expressão.

\label{eq-normalize-reflect} \begin{subequations}
\begin{equation}
  \text{normalize}(\vec{u}) = \frac{\vec{u}}{\sqrt{\vec{u} \cdot \vec{u}}}
\end{equation}

\begin{equation}
reflect(\vec I, \vec N) =  2*(\vec I \cdot \vec N)*\vec N - \vec I
\end{equation}
\end{subequations}

\begin{codigo}[htb]
   \caption{\small Código GLSL gerado pelo compilador para as funções de normalização e reflexão de vetores. }
   \label{cod-normalize-reflect}
\begin{lstlisting}[language=C, inputencoding=utf8]
//////////// START FUNCTIONS DECLARATIONS ////////////
vec3 var_13_reflect(vec3 var_14_vec_I, vec3 var_15_vec_N) {
    return (((2.0*(dot(var_14_vec_I,var_15_vec_N)))*var_15_vec_N)-var_14_vec_I);
}

vec3 var_17_text_normalize(vec3 var_18_vec_u) {
    return (var_18_vec_u/sqrt(dot(var_18_vec_u,var_18_vec_u)));
}
//////////// END FUNCTIONS DECLARATIONS ////////////

\end{lstlisting}
\end{codigo}
