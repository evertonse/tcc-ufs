O
antes de avançar para uma linguagem mais complexa. O capítulo também descreve os testes elaborados para validar a implementação. Além disso, ele apresenta o 
\subsection{Mecanismo de Reflexão de Raios}
% \include{Pos_Textual/Apendices}
Chapter
\subsection{Mecanismo de Reflexão de Raios}
\section{Desenvolvimento}
@{}
d
\begin{codigo}[H]
  \caption{\small Exemplo GLSL de \textit{shader} de vértice.}
 \label{vertex_code1}
\begin{lstlisting}
#version 330 core
layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inNormal;
uniform mat4 modelViewProjection;
out vec3 fragNormal;
void main() {
    vec3 manipulatedPosition = inPosition + (sin(gl_VertexID * 0.1) * 0.1);
    fragNormal = inNormal;
    gl_Position = modelViewProjection * vec4(manipulatedPosition, 1.0);
}
\end{lstlisting}
\end{codigo}
é
Anteriormente, na \autoref{lexer-subexpression}, foi comentado que o \textit{parser} é capaz de lidar com identificadores aninhados, como, por exemplo, \( x_{i_1} \) (\verb"x_{i_1}"). No \autoref{cod-expression-ident-recursive}, apresentamos como esses identificadores são criados recursivamente. O código mostrado faz parte de uma função maior, sendo um recorte de um \texttt{switch}\footnote{\texttt{switch} e \texttt{case} em Odin funcionam da mesma forma que na linguagem de programação \texttt{C}} sobre a enumeração descrita no \autoref{enum-token-kind}. Dentro desse \texttt{switch}, temos um \texttt{case} que reconhece \textit{tokens} de identificador ou símbolos especiais (\( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \)). Ao fazer uma chamada recursiva à função \texttt{parse\_expr}, o \textit{parser} permite a inclusão de subíndices numéricos, subexpresões de identificadores ou até expressões binárias, como \( n+1 \) em \( f_{n+1} \).

Isso confere maior flexibilidade na hora de expressar funções e equações para descrever as BRDFs, sendo muito comum o uso de subíndices numéricos. Na etapa de geração de código, essa capacidade de distinguir identificadores com subíndices é crucial, pois permite tratar semânticamente \textit{tokens} aparentemente iguais de maneira diferenciada. Por exemplo, embora o primeiro \textit{token} seja \( f \), \( f_1 \) e \( f_2 \) são semanticamente distintos, permitindo uma distinção precisa entre símbolos com o mesmo nome base, mas com significados diferentes devido aos seus índices.

Anteriormente
N
Anteriormente, na \autoref{lexer-subexpression}, foi comentado que o \textit{parser} é capaz de lidar com identificadores aninhados, como, por exemplo, \( x_{i_1} \) (\verb"x_{i_1}"). No \autoref{cod-expression-ident-recursive}, apresentamos como esses identificadores são criados recursivamente. O código mostrado faz parte de uma função maior, sendo um recorte de um \texttt{switch}\footnote{\texttt{switch} e \texttt{case} em Odin funcionam da mesma forma que na linguagem de programação \texttt{C}} sobre a enumeração descrita no \autoref{enum-token-kind}. Dentro desse \texttt{switch}, temos um \texttt{case} que reconhece \textit{tokens} de identificador ou símbolos especiais (\( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \)). Ao fazer uma chamada recursiva à função \texttt{parse\_expr}, o \textit{parser} permite a inclusão de subíndices numéricos, subexpresões de identificadores ou até expressões binárias, como \( n+1 \) em \( f_{n+1} \).

Isso confere maior flexibilidade na hora de expressar funções e equações para descrever as BRDFs, sendo muito comum o uso de subíndices numéricos. Na etapa de geração de código, essa capacidade de distinguir identificadores com subíndices é crucial, pois permite tratar semânticamente \textit{tokens} aparentemente iguais de maneira diferenciada. Por exemplo, embora o primeiro \textit{token} seja \( f \), \( f_1 \) e \( f_2 \) são semanticamente distintos, permitindo uma distinção precisa entre símbolos com o mesmo nome base, mas com significados diferentes devido aos seus índices.

O \autoref{cod-expression-ident-recursive}, já apresentado, serve como exemplo para outras expressões recursivas, como expressões infixas (operações binárias). Para identificar o \textit{token} atual, utilizamos a função \texttt{peek()}, que permite visualizar um ou dois \textit{tokens} à frente e, com isso, decidir qual nó da AST (Árvore de Sintaxe Abstrata) deve ser construído. Após identificar o token, calculamos a variável \texttt{prec}, que indica a precedência do \textit{token} atual. Com base nessa precedência, fazemos uma ou mais chamadas recursivas à função \texttt{parse\_expr} para processar os campos que requerem expressões aninhadas.

Uma vez que todos os campos necessários estejam preenchidos, a expressão completa é retornada. Esse processo é repetido até que a subárvore de expressões de uma dada equação esteja completamente construída. A análise sintática é concluída quando todas as equações forem adicionadas à AST. Essa estrutura hierárquica das expressões é então anotada com tipos e validada pelo pacote \texttt{checker}, conforme discutido na \autoref{secion-checker}.

No entanto, antes que a validação ocorra, é necessário implementar métodos para realizar a travessia dessa estrutura. O processo de travessia da AST é discutido na seção \autoref{secion-walker}, onde são apresentadas as técnicas para percorrer a árvore e acessar os dados nela contidos, facilitando a análise semântica e a geração de código subsequente.

necessário
essencial
%%%%%

O \autoref{cod-expression-ident-recursive}, já apresentado, serve como exemplo para outras expressões recursivas, como expressões infixas (operações binárias). Para identificar o \textit{token} atual, utilizamos a função \texttt{peek()}, que permite visualizar um ou dois \textit{tokens} à frente e, com isso, decidir qual nó da AST (Árvore de Sintaxe Abstrata) deve ser construído. Após identificar o token, calculamos a variável \texttt{prec}, que indica a precedência do \textit{token} atual. Com base nessa precedência, fazemos uma ou mais chamadas recursivas à função \texttt{parse\_expr} para processar os campos que requerem expressões aninhadas.

Uma vez que todos os campos necessários estejam preenchidos, a expressão completa é retornada. Esse processo é repetido até que a subárvore de expressões de uma dada equação esteja completamente construída. A análise sintática é concluída quando todas as equações forem adicionadas à AST. Essa estrutura hierárquica das expressões é então anotada com tipos e validada pelo pacote \texttt{checker}, conforme discutido na \autoref{secion-checker}.

No entanto, antes que a validação ocorra, é necessário implementar métodos para realizar a travessia dessa estrutura. O processo de travessia da AST é discutido na seção \autoref{secion-walker}, onde são apresentadas as técnicas para percorrer a árvore e acessar os dados nela contidos, facilitando a análise semântica e a geração de código subsequente.




\label{section-checker}
secion-checker
 Essa abordagem permite que a lógica de manipulação da AST seja flexível e extensível
e
subsection-svg
SVG
é
a
A estrutura \texttt{Visitor} (\autoref{cod-visitor-struct}) encapsula uma função de visita polimórfica (\texttt{visit}) que pode ser invocada em cada nó da AST. A função \texttt{visit} pode ser definida nessa estrutura para realizar operações transformação de nós, como mudar o campo \texttt{ty\_inferred} do nó do tipo \texttt{Expr}; também é permitido remoção ou adicição de nós. Além disso, a estrutura permite que o visitante mantenha um estado interno (\texttt{data}), que pode ser modificado dinamicamente durante a travessia. Como exemplo, esse estado é usado para manter um inteiro indicando a profundidade atual para gerar um arquivo no formato SVG da arvóres (\autoref{subsection-svg}), ou uma lista de indentificadores usados para fazer resolução de simbolos pelo pacote \texttt{checker}, entre outros usos.

A estrutura \texttt{Visitor} (\autoref{cod-visitor-struct}) encapsula uma função de visita polimórfica (\texttt{visit}) que pode ser invocada em cada nó da AST. A função \texttt{visit} pode ser definida nessa estrutura para realizar operações transformação de nós, como mudar o campo \texttt{ty\_inferred} do nó do tipo \texttt{Expr}; também é permitido remoção ou adicição de nós. Além disso, a estrutura permite que o visitante mantenha um estado interno (\texttt{data}), que pode ser modificado dinamicamente durante a travessia. Como exemplo, esse estado é usado para manter um inteiro indicando a profundidade atual para gerar um arquivo no formato SVG da arvóres (\autoref{subsection-svg}), ou uma lista de indentificadores usados para fazer resolução de simbolos pelo pacote \texttt{checker}, entre outros usos.

%%%

% A estrutura \texttt{Visitor} (\autoref{cod-visitor-struct}) encapsula uma função de visita polimórfica que pode ser chamada para cada tipo de nó, possibilitando um processamento flexível e extensível, onde o visitante pode modificar seu próprio estado durante a travessia, decidir continuar ou interromper o caminhamento, e realizar operações arbitrárias como transformação, análise semântica, geração de código ou depuração.



\begin{itemize}

\begin{enumerate}

item 
O controle de parada em \texttt{walk} é essencial para evitar chamadas recursivas desnecessárias ou operações em nós inválidos. Este controle é realizado por meio de duas verificações principais

A função \texttt{walk} (\autoref{cod-visitor-walk}) implementa a travessia profunda (\textit{depth-first}) da AST usando as estrutura genericas de visitar. Essa função percorre todos os nós, incluindo declarações, expressões e equações e definição de funções, aplicando a função \texttt{visit} antes e depois de explorar cada subárvore. Isso é especialmente útil para criar \textit{visitors} personalizados para tarefas como:

\begin{itemize}
    \item Checagem de tipos: Verifica a consistência dos tipos em diferentes nós da árvore.
    \item Parentização de expressões: Modifica nós para assegurar precedência correta de operadores.
    \item Geração de gráficos: Produz uma representação visual em arquivo no formato SVG da AST.
    \item Geração de código: Traduz a AST para uma linguagem GLSL.
\end{itemize}

% O controle de parada em \texttt{walk} é essencial para evitar chamadas recursivas desnecessárias ou operações em nós inválidos. Este controle é realizado por meio de duas verificações principais

O controle de parada em \texttt{walk} é realizado por meio de duas verificações principais:

\begin{enumerate}

    \item Verificação de nulidade: A função verifica se o visitante (\texttt{v}) ou o nó (\texttt{node}) atual são nulos antes de proceder. Isso garante que a execução não tente operar em dados inexistentes.

    \item Interrupção de travessia: Após cada chamada à função \texttt{visit}, verifica-se o retorno do visitante. Se for nulo, a travessia é interrompida, permitindo que o \textit{visitor} decida dinamicamente se deseja continuar ou parar; adaptando-se a diferentes cenários de análise e manipulação da AST.

\end{enumerate}


A função \texttt{walk} (\autoref{cod-visitor-walk}) implementa a travessia profunda (\textit{depth-first}) da AST usando as estrutura genericas de visitar. Essa função percorre todos os nós, incluindo declarações, expressões e equações e definição de funções, aplicando a função \texttt{visit} antes e depois de explorar cada subárvore. Isso é especialmente útil para criar \textit{visitors} personalizados para tarefas como:

\begin{itemize}
    \item Checagem de tipos: Verifica a consistência dos tipos em diferentes nós da árvore.
    \item Parentização de expressões: Modifica nós para assegurar precedência correta de operadores.
    \item Geração de gráficos: Produz uma representação visual em arquivo no formato SVG da AST.
    \item Geração de código: Traduz a AST para uma linguagem GLSL.
\end{itemize}

%%%%%%%

% O controle de parada em \texttt{walk} é essencial para evitar chamadas recursivas desnecessárias ou operações em nós inválidos. Este controle é realizado por meio de duas verificações principais



,
O controle de parada em \texttt{walk} é realizado por meio de duas verificações principais:

\begin{enumerate}

    \item Verificação de nulidade: A função verifica se o visitante (\texttt{v}) ou o nó (\texttt{node}) atual são nulos antes de proceder. Isso garante que a execução não tente operar em dados inexistentes.

    \item Interrupção de travessia: Após cada chamada à função \texttt{visit}, verifica-se o retorno do visitante. Se for nulo, a travessia é interrompida, permitindo que o \textit{visitor} decida dinamicamente se deseja continuar ou parar; adaptando-se a diferentes cenários de análise e manipulação da AST.

\end{enumerate}





\begin{codigo}[!ht]
    \caption{\small Estrutura polimórfica \texttt{Visitor}}
        \label{cod-visitor-struct}
\begin{lstlisting}[language = C]

// Estrutura polimórfica, aceita um tipo qualquer, chamado de DataType, como estrada para criar um tipo concreto.
Visitor :: struct (DataType: typeid) {
    visit: proc(visitor: ^Visitor(DataType), node: ^ast.Node) -> ^Visitor(DataType),
    data:  DataType,
}
\end{lstlisting}
\end{codigo}

Utilizamos o pacote \texttt{walker} para validar a precedência dos operadores na AST gerada pelo \texttt{parser}. A função de parentização implementa a inserção de parênteses para capturar a precedência original das expressões da AST. Dessa forma, a representação textual resultante reflete corretamente a ordem de avaliação das expressões matemáticas.

Durante a travessia da AST, o algoritmo processa todos os tipos de expressões, como prefixas, binárias e chamadas de função, inserindo parênteses sempre que necessário. Isso garante que a hierarquia das operações seja explicitamente representada, permitindo verificar se a construção da AST durante o parsing respeitou corretamente as regras de precedência matemáticas.

Os testes de precedência consistem em comparar o texto original de uma expressão com sua versão esperada, na qual os parênteses refletem a ordem de avaliação correta (\autoref{cod-test-paren}). Casos mais complexos, como a combinação de operadores associativos à direita (como a exponenciação) com operadores de diferentes precedências, são incluídos para abranger cenários que envolvem todas as operações aritméticas suportadas. Além disso, as expressões podem conter sub-expressões aninhadas, chamadas de funções e expressões como parâmetros na definição de funções.

À medida que o compilador foi sendo desenvolvido, esses testes se mostraram úteis para evitar regressões. Sempre que uma nova funcionalidade era adicionada, os testes garantiam que funcionalidades já existentes não fossem quebradas.


%%%%

À medida que o compilador foi sendo desenvolvido, esses testes se mostraram úteis para evitar regressões. Sempre que uma nova funcionalidade era adicionada, os testes garantiam que funcionalidades já existentes não fossem quebradas.

À medida que o compilador foi sendo desenvolvido, esses testes se mostraram úteis para evitar regressões. Sempre que uma nova funcionalidade era adicionada, os testes garantiam que funcionalidades já existentes não fossem quebradas.

não fossem quebradas
permanecessem intactas
À medida que o compilador foi sendo desenvolvido, esses testes se mostraram úteis para evitar regressões. Sempre que uma nova funcionalidade era adicionada, os testes garantiam que funcionalidades já existentes não fossem quebradas.

Esses testes foram essenciais para evitar regressões durante o desenvolvimento do compilador, garantindo que novas funcionalidades não quebrem as existentes.



Durante a travessia da AST, o algoritmo processa todos os tipos de expressões, adicionando parênteses quando necessário.
processa todos os tipos de expressões
quando necessário
implita
(sem parentiza)
A funções e esturura de traversia foram usadas para validar a precedência dos operadores na AST gerada pelo \texttt{parser}. A função de parentização processa todos os tipos de expressões na traversia da AST e insere parênteses nas expressões para preservar a  precedência implita original(sem parentizas). garantindo que a representação textual reflita corretamente a ordem de avaliação das operações matemáticas. Isso assegura que a hierarquia das operações seja explicitamente representada e que as regras de precedência sejam respeitadas no parsing.

à
A funções e esturura de traversia foram usadas para validar a precedência dos operadores na AST gerada pelo \texttt{parser}. A função de parentização processa todos os tipos de expressões na traversia da AST e insere parênteses nas expressões para preservar a  precedência implita original(sem parentizas). garantindo que a representação textual reflita corretamente a ordem de avaliação das operações matemáticas. Isso assegura que a hierarquia das operações seja explicitamente representada e que as regras de precedência sejam respeitadas no parsing.





%%%%%%%%%%%%%%

Utilizamos o pacote \texttt{walker} para validar a precedência dos operadores na AST gerada pelo \texttt{parser}. A função de parentização implementa a inserção de parênteses para capturar a precedência original das expressões da AST. Dessa forma, a representação textual resultante reflete corretamente a ordem de avaliação das expressões matemáticas.

Durante a travessia da AST, o algoritmo processa todos os tipos de expressões, como prefixas, binárias e chamadas de função, inserindo parênteses sempre que necessário. Isso garante que a hierarquia das operações seja explicitamente representada, permitindo verificar se a construção da AST durante o parsing respeitou corretamente as regras de precedência matemáticas.

Os testes de precedência consistem em comparar o texto original de uma expressão com sua versão esperada, na qual os parênteses refletem a ordem de avaliação correta (\autoref{cod-test-paren}). Casos mais complexos, como a combinação de operadores associativos à direita (como a exponenciação) com operadores de diferentes precedências, são incluídos para abranger cenários que envolvem todas as operações aritméticas suportadas. Além disso, as expressões podem conter sub-expressões aninhadas, chamadas de funções e expressões como parâmetros na definição de funções.






%%%%





        % \includegraphics[width=\textwidth, scale=1.1]{./Imagens/svg.png}
        % \includegraphics[scale=0.9]{./Imagens/svg.png}

        \includegraphics[scale=0.65]{./Imagens/svg.pdf} % Best outta of them all, because it gets to indefinitely zoom in
        % \includesvg[scale=0.9]{./Imagens/svg.svg}

        % Best outta of them all, because it gets to indefinitely zoom in
        % \includesvg[scale=0.9]{./Imagens/svg.svg}

5
Além disso, é possível remover ou adicionar nós. A estrutura também permite que o visitante mantenha um estado interno (\texttt{data}), que pode ser alterado dinamicamente durante a travessia. Um exemplo de uso desse estado é o acompanhamento da profundidade atual para gerar um arquivo SVG da árvore (\autoref{subsection-svg}), ou a manutenção de uma lista de identificadores usados para a resolução de símbolos pelo pacote \texttt{checker}, entre outros.

subsection-svg
\texttt{Visitor}
Visitor
remover ou adicionar
remover ou adicionar nós. 
.
.
remover ou adicionar nós;
.
à
 
        // ...
        // casos OMITIDOS aqui Também
        // ...

        case ^Decl_Equation:
            walk(v, n.field)


        // ...

        // ...



        // ...

H
- Remova abordagem

H
"
\begin{codigo}[!h]
    \caption{\small Validação de precendencia por parentização de expressões. }
        \label{cod-test-paren}
  \begin{lstlisting}[language = C]
    test_paren(
        "a = 1+2", // Entrada
        "a=(1+2)"  // Saída Esperada
    );

    test_paren(
        "a = \exp 1 + 2^3", // Entrada
        "a=(\exp(1)+(2^3))" // Saída Esperada
    );

    // ...
    // Outros Testes
    // ...

    test_paren(
        "a = a(1*2 ^ 4 +  \sqrt 4^8 , 2)", // Entrada
        "a=a(((1*(2^4))+(\sqrt(4)^8)),2)"  // Saída Esperada
    );
  \end{lstlisting}
\end{codigo}

Para validação visual, foi implementado uma função que gera uma imagem da AST no formato SVG, que é textual e fácil de manipular. Cada nó da AST é representado por um retangulo com textos associados que fornecem informações, como o tipo de operador, o tipo do nó e a string do identificador, se aplicavel. Anteriormente, utilizávamos a função \texttt{print\_ast}, que imprimia os nós e seus atributos com indentação correspondente à profundidade. Essa abordagem se tornou limitada à medida que a AST crescia em complexidade, demandando uma solução mais robusta para depuração.

Na \autoref{fig-svg}, apresentamos a visualização gerada para a equação \autoref{eq-svg}. Observamos que os nós de operações binárias, como \texttt{+} e \texttt{-}, localizados próximos à raiz, são avaliados posteriormente, enquanto os nós mais próximos das folhas, como \texttt{*} e \texttt{\^}, têm maior precedência e são resolvidos primeiro. Além disso, o SVG inclui informações adicionais, como o tipo das expressões. Por exemplo, o identificador \( f \) é anotado como pertencente ao tipo \( \mathbb{R} \), o que é determinado na etapa de validação semântica (\texttt{checker}), como será discutido posteriormente.

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

Os nós da AST são heterogêneos, e o modo de acessar seus filhos varia conforme o tipo do nó, já que os campos podem ter nomes ou posições diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma função chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferenças entre os tipos de nós e retorna, para qualquer nó, uma lista uniforme de seus filhos.
Essa função simplifica o código de geração do SVG, permitindo que a função opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de nó individualmente.

h
Para validação visual, foi implementado uma função que gera uma imagem da AST no formato SVG, que é textual e fácil de manipular. Cada nó da AST é representado por um retangulo com textos associados que fornecem informações, como o tipo de operador, o tipo do nó e a string do identificador, se aplicavel. Anteriormente, utilizávamos a função \texttt{print\_ast}, que imprimia os nós e seus atributos com indentação correspondente à profundidade. Essa abordagem se tornou limitada à medida que a AST crescia em complexidade, demandando uma solução mais robusta para depuração.

Na \autoref{fig-svg}, apresentamos a visualização gerada para a equação \autoref{eq-svg}. Observamos que os nós de operações binárias, como \texttt{+} e \texttt{-}, localizados próximos à raiz, são avaliados posteriormente, enquanto os nós mais próximos das folhas, como \texttt{*} e \texttt{\^}, têm maior precedência e são resolvidos primeiro. Além disso, o SVG inclui informações adicionais, como o tipo das expressões. Por exemplo, o identificador \( f \) é anotado como pertencente ao tipo \( \mathbb{R} \), o que é determinado na etapa de validação semântica (\texttt{checker}), como será discutido posteriormente.

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

Os nós da AST são heterogêneos, e o modo de acessar seus filhos varia conforme o tipo do nó, já que os campos podem ter nomes ou posições diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma função chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferenças entre os tipos de nós e retorna, para qualquer nó, uma lista uniforme de seus filhos.
Essa função simplifica o código de geração do SVG, permitindo que a função opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de nó individualmente.

Os nós da AST são heterogêneos, e o modo de acessar seus filhos varia conforme o tipo do nó, já que os campos podem ter nomes ou posições diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma função chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferenças entre os tipos de nós e retorna, para qualquer nó, uma lista uniforme de seus filhos.
Essa função simplifica o código de geração do SVG, permitindo que a função opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de nó individualmente.

%%
Para validação visual, foi implementado uma função que gera uma imagem da AST no formato SVG, que é textual e fácil de manipular. Cada nó da AST é representado por um retangulo com textos associados que fornecem informações, como o tipo de operador, o tipo do nó e a string do identificador, se aplicavel. Anteriormente, utilizávamos a função \texttt{print\_ast}, que imprimia os nós e seus atributos com indentação correspondente à profundidade. Essa abordagem se tornou limitada à medida que a AST crescia em complexidade, demandando uma solução mais robusta para depuração.

Na \autoref{fig-svg}, apresentamos a visualização gerada para a equação \autoref{eq-svg}. Observamos que os nós de operações binárias, como \texttt{+} e \texttt{-}, localizados próximos à raiz, são avaliados posteriormente, enquanto os nós mais próximos das folhas, como \texttt{*} e \texttt{\^}, têm maior precedência e são resolvidos primeiro. Além disso, o SVG inclui informações adicionais, como o tipo das expressões. Por exemplo, o identificador \( f \) é anotado como pertencente ao tipo \( \mathbb{R} \), o que é determinado na etapa de validação semântica (\texttt{checker}), como será discutido posteriormente.

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

Os nós da AST são heterogêneos, e o modo de acessar seus filhos varia conforme o tipo do nó, já que os campos podem ter nomes ou posições diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma função chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferenças entre os tipos de nós e retorna, para qualquer nó, uma lista uniforme de seus filhos.
Essa função simplifica o código de geração do SVG, permitindo que a função opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de nó individualmente.

%%
Para validação visual, foi implementado uma função que gera uma imagem da AST no formato SVG, que é textual e fácil de manipular. Cada nó da AST é representado por um retangulo com textos associados que fornecem informações, como o tipo de operador, o tipo do nó e a string do identificador, se aplicavel. Anteriormente, utilizávamos a função \texttt{print\_ast}, que imprimia os nós e seus atributos com indentação correspondente à profundidade. Essa abordagem se tornou limitada à medida que a AST crescia em complexidade, demandando uma solução mais robusta para depuração.

Na \autoref{fig-svg}, apresentamos a visualização gerada para a equação \autoref{eq-svg}. Observamos que os nós de operações binárias, como \texttt{+} e \texttt{-}, localizados próximos à raiz, são avaliados posteriormente, enquanto os nós mais próximos das folhas, como \texttt{*} e \texttt{\^}, têm maior precedência e são resolvidos primeiro. Além disso, o SVG inclui informações adicionais, como o tipo das expressões. Por exemplo, o identificador \( f \) é anotado como pertencente ao tipo \( \mathbb{R} \), o que é determinado na etapa de validação semântica (\texttt{checker}), como será discutido posteriormente.

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

Os nós da AST são heterogêneos, e o modo de acessar seus filhos varia conforme o tipo do nó, já que os campos podem ter nomes ou posições diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma função chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferenças entre os tipos de nós e retorna, para qualquer nó, uma lista uniforme de seus filhos.
Essa função simplifica o código de geração do SVG, permitindo que a função opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de nó individualmente.




\texttt{\^}
tab-conventions
tabela-variaveis
a
,
,
Além disso, variáveis como a normal \( \vec{n} \) são frequentemente fornecidas como entrada para o \textit{shader} de fragmentos ou declaradas como variáveis uniformes. Por isso, elas não estão explicitamente definidas na função \texttt{cook\_torrance} do \autoref{cod-glsl-esperado}, sendo consideradas variáveis implícitas. Uma lista completa dessas variáveis implícitas podem ser encontrada no mapeamento de conveções para código GLSL na \autoref{tab-conventions}.

    Por isso, elas não estão explicitamente definidas na função \texttt{cook\_torrance} do \autoref{cod-glsl-esperado}, sendo consideradas variáveis implícitas. Uma lista completa dessas variáveis implícitas podem ser encontrada no mapeamento de conveções para código GLSL na \autoref{tab-conventions}.

e atenda aos requisitos do pipeline gráfic
e atenda aos requisitos do pipeline gráfico
e
o
a
Concluímos que os experimentos realizados têm resultados satisfatórios. O compilador desenvolvido demonstra flexibilidade ao capturar nuances das diferentes BRDFs, inclusive em materiais com estruturas complexas. O sistema permite diversas parametrizações e equações alteranivas para representar comportamentos da superfície.

Os resultados obtidos não apenas validam a abordagem metodológica adotada, mas também abrem perspectivas para futuras extensões e refinamentos da ferramenta. Após o último experimento, passamos diretamente para o capítulo de conclusão (\autoref{chapter-conclusion}), onde é discutido as potenciais direções deste trabalho.

passamos

Os resultados obtidos não apenas validam a abordagem metodológica adotada, mas também abrem perspectivas para futuras extensões e refinamentos da ferramenta. Após o último experimento, passamos diretamente para o capítulo de conclusão (\autoref{chapter-conclusion}), onde é discutido as potenciais direções deste trabalho.

Concluímos que os experimentos realizados têm resultados satisfatórios. O compilador desenvolvido demonstra flexibilidade ao capturar nuances das diferentes BRDFs, inclusive em materiais com estruturas complexas. O sistema permite diversas parametrizações e equações alteranivas para representar comportamentos da superfície.



Além disso, foi implementada uma etapa de análise semântica por meio do pacote chamado \texttt{checker}. Essa etapa é criar os escopos e tabela de simbolo e anotar a AST com informações como o tipos de dados dos nós, incluindo funções com seus domínios e contradomínios, vetores reais e suas dimensões, ou números reais.

Além disso, foi implementada uma etapa de análise semântica por meio do pacote chamado \texttt{checker}. Essa etapa é criar os escopos e tabela de simbolo e anotar a AST com informações como o tipos de dados dos nós, incluindo funções com seus domínios e contradomínios, vetores reais e suas dimensões, ou números reais.

m
a
a

Ainda, definimos símbolos operadores: ``$*$'' indica zero ou mais ocorrências; ``$()$'' indica agrupamento para aplicar um operador ao mesmo; ``$|$'' simboliza o início de uma regra alternativa para o mesmo não-terminal, ou se estiver dentro de um agrupamento, como por exemplo``$(a|b)$'', significa que aceita $a$ ou $b$; e ``$=$'' indica uma produção. Essa mesmta sintaxe de gramática é utilizada na análise sintática, onde cada regra é faz bijeção com os tipos de nó da AST, como detalhado na \autoref{section-parser}. Na etapa de análise sintática, é usada a mesma sintaxed para a gramatica, mas alfabeto passa a ser composto pelo conjunto de \textit{tokens} gerados pelo \texttt
[
a
a
a
a
a
A estrutura \texttt{Position}, detalhada na \autoref{lexer-structs}
, uma funcionalidade essencial para a geração de relatórios de erro
Durante a iteração sobre o \texttt{input}, o processo de tokenização mantém algumas variáveis de controle para monitorar o estado do fluxo de caracteres. Quebras de linha são contadas ao encontrar sequências como \verb|"\n"| ou \verb|"\n\r"|. É mantida a coluna atual que rastreia a posição horizontal do caractere em uma linha. O cursor é o índice que aponta para o caractere atualmente em processamento. Essas informações são usadas para preencher o campo \texttt{position} de cada \textit{token}. A estrutura \texttt{Position}, detalhada na \autoref{lexer-structs}, é essencial para garantir a precisão no rastreamento de problemas e geração de relatórios de erro.

A estrutura \texttt{Position}, detalhada na \autoref{lexer-structs}, é essencial para garantir a precisão no rastreamento de problemas e geração de relatórios de erro.

geração
LogicalOrExpr
LogicalOrExpr
PrimaryExpr
PrimaryExpr
PrimaryExpr
PrimaryExpr
Expressões primárias


expr;   ---  Igualdade
      |
relational_expr
relational_expr
rel_expr
         
        
        
        
       
       
       
   
 --- regra de identifier está omitida
       
      
    
 |
| rel_expr;   ---  Igualdade
  
  
   
      
---  Comparação
---  Igualdade
    --- regra de identifier está omitida

Para formalizar a gramática da linguagem de entrada (\texttt{EquationLang}), têm suas regras detalhadas nos \autoref{grammar-ast-pt1} e \autoref{grammar-ast-pt2}. É apresentado um exemplo de código-fonte de três equações válidas nesta linguagem no \autoref{code-gramatica}, cuja renderização correspondente em \LaTeX{} é ilustrada em \autoref{code-gramatica-rendered}. Nesse exemplo, a primeira equação ($\rho_{d}$) é gerado pela regra \verb"expr_vector_literal". A segunda ($\rho_{s}$), é uma expressão binário derivada pela regra \verb"expr_infix". Já a última representa uma equação que necessitou de mais regras como \verb"expr_grouped" e \verb"expr_prefix".

Concluímos que os experimentos realizados apresentaram resultados satisfatórios. O compilador desenvolvido demonstra flexibilidade ao capturar as nuances das diferentes BRDFs, inclusive em materiais com estruturas complexas. O sistema permite diversas parametrizações e equações alternativas para representar os comportamentos da superfície.



Os resultados obtidos não apenas validam a abordagem metodológica adotada, mas também abrem perspectivas para futuras extensões e refinamentos da ferramenta. Após o último experimento, seguimos diretamente para o capítulo de conclusão (\autoref{chapter-conclusion}), onde são discutidas as possíveis direções para a continuidade deste trabalho.

Nesse exemplo, a primeira equação (
𝜌
𝑑
ρ 
d
​
 ) é gerada pela regra \verb"expr_vector_literal". A segunda (
𝜌
𝑠
ρ 
s
​
 ) é uma expressão binária derivada da regra \verb"expr_infix". Já a última equação utiliza múltiplas regras, como \verb"expr_grouped" e \verb"expr_prefix".

é uma expressão binário derivada pela regra \verb"expr_infix". Já a última representa uma equação que necessitou de mais regras como \verb"expr_grouped" e \verb"expr_prefix".

A gramática definida nesta seção abrange regras para expressões, atribuições, agrupamento, literais numéricos e vetores, chamadas de funções, definições de funções e diversos operadores, como \texttt{expr\_prefix} e \texttt{expr\_infix}. O objetivo é fornecer uma linguagem capaz de expressar a sintaxe necessária para definições de BRDFs em \LaTeX{}. 

A tabela de operadores (\autoref{tab-token-precedence}) usada no Pratt Parsing é representada pela função \texttt{precedence\_from\_token}, que mapeia um \textit{token} para um valor inteiro que representa sua precedência: quanto maior o valor, maior a precedência do operador. É importante observar que alguns \textit{tokens} podem ser usados tanto como prefixos quanto como infixos, dependendo do contexto. Por exemplo, o \textit{token} \texttt{(} pode ser um prefixo em uma expressão de agrupamento, como em \textbf{(}$2*3$\textbf{)}, mas também pode ser infixo em uma chamada de função, como em $f$\textbf{(}$x$\textbf{)}. O mesmo comportamento ocorre com o \textit{token} \texttt{-}, que pode atuar como operador prefixo de negação ou infixo para subtração.

A gramática definida nesta seção abrange regras para expressões, atribuições, agrupamento, literais numéricos e vetores, chamadas de funções, definições de funções e diversos operadores, como \texttt{expr\_prefix} e \texttt{expr\_infix}. O objetivo é fornecer uma linguagem capaz de expressar a sintaxe necessária para definições de BRDFs em \LaTeX{}. 



$f$\textbf{(}$x$\textbf{)}
(
𝑓









H
"

    expr_identifier =
        --- Ex: `\text{id}`
        token_text token_opencurly expr_identifier token_closecurly
        --- Ex: `\vec{id}`
        token_vec token_opencurly expr_identifier token_closecurly
        --- Ex: `id_n`
        | expr_identifier token_underline expr_identifier
        --- Ex: `id_2`
        | expr_identifier token_underline token_number
        --- Ex: `id_{n+1}`
        | expr_identifier token_underline token_opencurly expr token_closecurly
        --- Token especiais como \phi ou \alpha
        | token_identifier
        | token_omega
        | token_theta   | token_phi
        | token_rho     | token_alpha
        | token_beta    | token_sigma
        | token_pi      | token_epsilon
        | token_max     | token_min
    ;



 % Adjust this value as needed


        lineskip=-1pt,

small
    expr_identifier =
        --- Ex: `\text{id}`
        token_text token_opencurly expr_identifier token_closecurly
        --- Ex: `\vec{id}`
        token_vec token_opencurly expr_identifier token_closecurly
        --- Ex: `id_n`
        | expr_identifier token_underline expr_identifier
        --- Ex: `id_2`
        | expr_identifier token_underline token_number
        --- Ex: `id_{n+1}`
        | expr_identifier token_underline token_opencurly expr token_closecurly
        --- Token especiais como \phi ou \alpha
        | token_identifier
        | token_omega
        | token_theta   | token_phi
        | token_rho     | token_alpha
        | token_beta    | token_sigma
        | token_pi      | token_epsilon
        | token_max     | token_min
    ;

basicstyle=\small
scriptsize
footnotesize
small
small
footnotesize
small




        




\begin{lstlisting}[language=haskell, basicstyle=\footnotesize, numbers=none, inputencoding=utf8]

basicstyle=\fontsize{10}{12}\selectfont
basicstyle=\footnotesize
\ttfamily\small,
\selectfont
    basicstyle=\ttfamily\small,

8
basicstyle=\ttfamily\footnotesize
\footnotesize
A tabela de operadores (\autoref{tab-token-precedence}), usada no Pratt Parsing, é implementada pela função \texttt{precedence\_from\_token}, que associa cada \textit{token} a um valor inteiro indicando sua precedência: valores maiores indicam maior prioridade. Alguns \textit{tokens} assumem diferentes funções conforme o contexto, e podem mudar suas precedencia. Por exemplo, \texttt{(} pode ser um prefixo em expressões agrupadas, \textbf{(}$2*3$\textbf{)}, ou um infixo em chamadas de função, $f$\textbf{(}$x$\textbf{)}. O mesmo vale para \texttt{-}, que pode atuar como operador de negação (prefixo) ou subtração (infixo).

    % basicstyle=\fontsize{6}{7.2}\selectfont\ttfamily

,
demonstrando a flexibilidade contextual dos \textit{tokens} no processo de parsing.
Alguns \textit{tokens} assumem diferentes funções conforme o contexto, e podem mudar suas precedencia. Por exemplo, \texttt{(} pode ser um prefixo em expressões agrupadas, \textbf{(}$2*3$\textbf{)}, ou um infixo em chamadas de função, $f$\textbf{(}$x$\textbf{)}. O mesmo vale para \texttt{-}, que pode atuar como operador de negação (prefixo) ou subtração (infixo).



% A tabela de operadores (\autoref{tab-token-precedence}) usada no Pratt Parsing é representada pela função \texttt{precedence\_from\_token}, que mapeia um \textit{token} para um valor inteiro que representa sua precedência: quanto maior o valor, maior a precedência do operador. É importante observar que alguns \textit{tokens} podem ser usados tanto como prefixos quanto como infixos, dependendo do contexto. Por exemplo, o \textit{token} \texttt{(} pode ser um prefixo em uma expressão de agrupamento, como em \textbf{(}$2*3$\textbf{)}, mas também pode ser infixo em uma chamada de função, como em . O mesmo comportamento ocorre com o \textit{token} \texttt{-}, que pode atuar como operador prefixo de negação ou infixo para subtração.



a
Nesta seção, apresentamos os tipos de nós que compõem a AST utilizada no compilador da linguagem \texttt{EquationLang}. Cada estrutura de nó capturam os diferentes elementos da sintaxe da linguagem. Diferente da gramática definida no \autoref{lst-gramatica}, os nós aqui são representados em nível de código, e esses nomes serão utilizados nas seções posteriores para explicar o desenvolvimento.

É importante destacar que o nó \texttt{Expr}, sendo o mais genérico, possui um campo adicional,\verb"ty_inferred", utilizado na etapa de análise semântica e na geração de código. A seguir, apresentamos uma descrição semântica das principais estruturas de nós da AST:


%%%
Nesta seção, apresentamos os tipos de nós que compõem a AST utilizada no compilador da linguagem \texttt{EquationLang}. Cada estrutura de nó capturam os diferentes elementos da sintaxe da linguagem. Diferente da gramática definida no \autoref{lst-gramatica}, os nós aqui são representados em nível de código, e esses nomes serão utilizados nas seções posteriores para explicar o desenvolvimento.

É importante destacar que o nó \texttt{Expr}, sendo o mais genérico, possui um campo adicional,\verb"ty_inferred", utilizado na etapa de análise semântica e na geração de código. A seguir, apresentamos uma descrição semântica das principais estruturas de nós da AST:

Anteriormente, na \autoref{lexer-subexpression}, discutiu-se que o \textit{parser} é capaz de lidar com identificadores aninhados, como \( x_{i_1} \) (\verb"x_{i_1}"). Esse suporte é demonstrado no código apresentado na \autoref{cod-expression-ident-recursive}, que ilustra como identificadores desse tipo são processados de forma recursiva. O trecho mostrado faz parte de uma função maior e é extraído de um \texttt{switch}\footnote{Os comandos \texttt{switch} e \texttt{case} na linguagem Odin funcionam de forma semelhante aos da linguagem C.}, aplicado sobre a enumeração descrita na \autoref{enum-token-kind}. Dentro desse \texttt{switch}, há um \texttt{case} específico que reconhece \textit{tokens} de identificadores ou símbolos especiais, como \( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \).

A tabela de operadores (\autoref{tab-token-precedence}), usada no Pratt Parsing, é implementada pela função \texttt{precedence\_from\_token}, que associa cada \textit{token} a um valor inteiro indicando sua precedência: valores maiores indicam maior prioridade. 



o
e
Nesta seção, é apresentado os tipos de nós que compõem a AST do compilador da linguagem \texttt{EquationLang}. Cada estrutura de nó captura as diferentes regras de produção da sintaxe da linguagem em nível de código, e esses nomes serão utilizados nas seções posteriores para explicar o desenvolvimento. É importante destacar que o nó \texttt{Expr}, sendo o mais genérico, possui um campo importante, o \verb"ty_inferred", que representa o tipo da expressão que é preenchido pela análise semântica para uso na geração de código.

Cada estrutura de nó captura as diferentes regras de produção da sintaxe da linguagem em nível de código
Cada nó corresponde a uma regra da sintaxe da linguagem, servindo como base para explicações nas seções seguintes
Nesta seção, é apresentado os tipos de nós que compõem a AST do compilador da linguagem \texttt{EquationLang}. Cada estrutura de nó captura as diferentes regras de produção da sintaxe da linguagem em nível de código, e esses nomes serão utilizados nas seções posteriores para explicar o desenvolvimento. É importante destacar que o nó \texttt{Expr}, sendo o mais genérico, possui um campo importante, o \verb"ty_inferred", que representa o tipo da expressão que é preenchido pela análise semântica para uso na geração de código.



Anteriormente, na \autoref{lexer-subexpression}, discutiu-se que o \textit{parser} é capaz de lidar com identificadores aninhados, como \( x_{i_1} \) (\verb"x_{i_1}"). Esse suporte é demonstrado no código apresentado na \autoref{cod-expression-ident-recursive}, que ilustra como identificadores desse tipo são processados de forma recursiva. O trecho mostrado faz parte de uma função maior e é extraído de um \texttt{switch}\footnote{Os comandos \texttt{switch} e \texttt{case} na linguagem Odin funcionam de forma semelhante aos da linguagem C.}, aplicado sobre a enumeração descrita na \autoref{enum-token-kind}. Dentro desse \texttt{switch}, há um \texttt{case} específico que reconhece \textit{tokens} de identificadores ou símbolos especiais, como \( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \).

A funcionalidade recursiva é habilitada por chamadas à função \texttt{parse\_expr}, permite a inclusão de subíndices numéricos, subexpressões de identificadores, ou até mesmo expressões mais complexas, como \( n+1 \) em \( f_{n+1} \). Isso amplia a flexibilidade na representação de equações de BRDFs, onde o uso de subíndices numéricos é bastante comum.

,
Com chamadas recursivas à função \texttt{parse_expr}, o \textit{parser} permite incluir subíndices numéricos, subexpressões ou até expressões mais complexas, como 
𝑛
+
1
n+1 em 
𝑓
𝑛
+
1
f 
n+1
​

 . Isso garante maior flexibilidade na representação de equações de BRDFs, onde subíndices numéricos são frequentemente usados.

a
por 
i
à
s
Anteriormente, na \autoref{lexer-subexpression}, foi discutido que o \textit{parser} é capaz de lidar com identificadores aninhados, como \( x_{i_1} \) (\verb"x_{i_1}"). Esse suporte é demonstrado no \autoref{cod-expression-ident-recursive}, que processa identificadores de forma recursiva. O trecho faz parte de uma função maior onde um \texttt{switch}\footnote{Os comandos \texttt{switch} e \texttt{case} na linguagem Odin funcionam de forma semelhante aos da linguagem C.} é aplicado sobre a enumeração descrita na \autoref{enum-token-kind}. Dentro desse \texttt{switch}, há um \texttt{case} específico que reconhece \textit{tokens} de identificadores ou símbolos especiais, como \( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \).


A recursividade, feita pela chamada a função \texttt{parse\_expr}, permite a inclusão de subíndices numéricos, subexpressões de identificadores, ou até mesmo expressões mais complexas, como \( n+1 \) em \( f_{n+1} \). Isso amplia a flexibilidade na representação de equações de BRDFs, onde o uso de subíndices numéricos é bastante comum.

%%%%%%%%
Anteriormente, na \autoref{lexer-subexpression}, foi discutido que o \textit{parser} é capaz de lidar com identificadores aninhados, como \( x_{i_1} \) (\verb"x_{i_1}"). Esse suporte é demonstrado no \autoref{cod-expression-ident-recursive}, que processa identificadores de forma recursiva. O trecho faz parte de uma função maior onde um \texttt{switch}\footnote{Os comandos \texttt{switch} e \texttt{case} na linguagem Odin funcionam de forma semelhante aos da linguagem C.} é aplicado sobre a enumeração descrita na \autoref{enum-token-kind}. Dentro desse \texttt{switch}, há um \texttt{case} específico que reconhece \textit{tokens} de identificadores ou símbolos especiais, como \( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \).


A recursividade, feita pela chamada a função \texttt{parse\_expr}, permite a inclusão de subíndices numéricos, subexpressões de identificadores, ou até mesmo expressões mais complexas, como \( n+1 \) em \( f_{n+1} \). Isso amplia a flexibilidade na representação de equações de BRDFs, onde o uso de subíndices numéricos é bastante comum.



% Essa capacidade do \textit{parser} é essencial na etapa de geração de código, pois permite distinguir semanticamente identificadores que, à primeira vista, podem parecer idênticos. Por exemplo, embora o identificador base seja \( f \), os símbolos \( f_1 \) e \( f_2 \) são tratados como semanticamente distintos devido aos seus índices. Essa distinção é crucial para o correto mapeamento e interpretação dos elementos durante a análise semântica e a geração de código GLSL.





%%%%%




Essa mesma lógica exemplifica o processamento todas as outras expressões recursivas, como operações binárias. Para identificar o \textit{token} atual, utilizamos a função \texttt{peek()}, que permite visualizar um ou dois \textit{tokens} à frente e decidir qual nó da AST será construído. Após identificar o \textit{token}, calcula-se a variável \texttt{prec}, que determina a precedência do operador. Com base nessa precedência, são realizadas chamadas recursivas à função \texttt{parse\_expr} para processar expressões aninhadas.

Após preencher todos os campos necessários, a expressão completa é retornada. Esse processo é repetido até que toda a subárvore de expressões de uma equação seja construída. A análise sintática é concluída quando todas as equações são adicionadas à AST.

Em seguida, essa estrutura hierárquica é anotada com tipos e validada pelo pacote \texttt{checker}, como descrito na \autoref{section-checker}. Antes da validação, é necessário implementar métodos para a travessia da árvore. Esse processo é detalhado na \autoref{section-walker}, que apresenta técnicas para percorrer a árvore, acessar seus dados e facilitar as etapas subsequentes de análise semântica e geração de código.

% Essa mesma lógica exemplifica o processamento todas as outras expressões recursivas, como operações binárias. Para identificar o \textit{token} atual, utilizamos a função \texttt{peek()}, que permite visualizar um ou dois \textit{tokens} à frente e decidir qual nó da AST será construído. Após identificar o \textit{token}, calcula-se a variável \texttt{prec}, que determina a precedência do operador. Com base nessa precedência, são realizadas chamadas recursivas à função \texttt{parse\_expr} para processar expressões aninhadas.
%
% Após preencher todos os campos necessários, a expressão completa é retornada. Esse processo é repetido até que toda a subárvore de expressões de uma equação seja construída. A análise sintática é concluída quando todas as equações são adicionadas à AST.
%
% Em seguida, essa estrutura hierárquica é anotada com tipos e validada pelo pacote \texttt{checker}, como descrito na \autoref{section-checker}. Antes da validação, é necessário implementar métodos para a travessia da árvore. Esse processo é detalhado na \autoref{section-walker}, que apresenta técnicas para percorrer a árvore, acessar seus dados e facilitar as etapas subsequentes de análise semântica e geração de código.

As funções e a estrutura de travessia foram utilizadas para validar a precedência dos operadores na AST gerada pelo \texttt{parser}. Foi implementada uma função de parentização, que processa todos os tipos de expressões durante a travessia da AST, inserindo parênteses para preservar a precedência implícita original (sem parênteses). Isso garante que a representação textual reflita corretamente a ordem de avaliação das operações matemáticas, assegurando que a hierarquia das operações foram corretamente representada na árvore gerada.

Os testes de precedência comparam o texto original de uma expressão com sua versão esperada, onde os parênteses refletem a ordem correta de avaliação (\autoref{cod-test-paren}). Casos mais complexos, como operadores associativos à direita (ex: exponenciação) combinados com outros operadores de diferentes precedências, também são testados. Expressões aninhadas e funções também são consideradas para abranger todos os cenários.

,
assegurando que a hierarquia das operações foram corretamente representada na árvore gerada.

garantindo que a hierarquia das operações seja respeitada.

e
As funções e a estrutura de travessia foram utilizadas para validar a precedência dos operadores na AST gerada pelo \texttt{parser}. Foi implementada uma função de parentização, que processa todos os tipos de expressões durante a travessia da AST, inserindo parênteses para preservar a precedência implícita original (sem parênteses). Isso garante que a representação textual reflita corretamente a ordem de avaliação das operações matemáticas, 

Os testes de precedência comparam o texto original de uma expressão com sua versão esperada, onde os parênteses refletem a ordem correta de avaliação (\autoref{cod-test-paren}). Casos mais complexos, como operadores associativos à direita (ex: exponenciação) combinados com outros operadores de diferentes precedências, também são testados. Expressões aninhadas e funções também são consideradas para abranger todos os cenários.

subsection-type-inference
subsection-type-inference
subsection-inferencia-tipos
subsection-type-inference
subsection-inferencia-tipos


*
        \item Os argumentos de uma função pertençam ao domínio da função. Por exemplo, se a função $\texttt{normalize}(\vec{u})$ retorna um vetor tridimensional ($\mathbb{R}^3$), usá-lo como argumento para funlção seno, que espera um número escalar ($\mathbb{R}$). Então, $\sin(\texttt{normalize}(\vec{u}))$ seria inválido.
        \item O tipo do valor de retorno de uma função seja adequado ao contexto onde é utilizado.

        \item Os argumentos de uma função pertençam ao domínio da função. Por exemplo, se a função $\texttt{normalize}(\vec{u})$ retorna um vetor tridimensional ($\mathbb{R}^3$), usá-lo como argumento para funlção seno, que espera um número escalar ($\mathbb{R}$). Então, $\sin(\texttt{normalize}(\vec{u}))$ seria inválido.
        \item O tipo do valor de retorno de uma função seja adequado ao contexto onde é utilizado.

        \item Os argumentos de uma função pertençam ao domínio da função. Por exemplo, se a função $\texttt{normalize}(\vec{u})$ retorna um vetor tridimensional ($\mathbb{R}^3$), usá-lo como argumento para funlção seno, que espera um número escalar ($\mathbb{R}$). Então, $\sin(\texttt{normalize}(\vec{u}))$ seria inválido.
        \item O tipo do valor de retorno de uma função seja adequado ao contexto onde é utilizado.



    // node:   ^Expr_Procedure,


    /* Easy comparison, types aren't equal if they are not even the same odin typeid */

Type_Vector
Type_Basic
Type_Function
sec-symbol-resolution
subsection-sym-resolution
sec-symbol-resolution
cod-symbol-graph
cod-symbol-graph
cod-grafo-simbol-deps
cod-grafo-simbol-deps
a
        \item Verificação do ponto de entrada

        \item Validação de definição de funções com uso de escopo

 idk yet @LOOK
    /*
     . It does not need to be a pointer to a map
     . because we don't ever copy a Scope we have only one scope
     . per map elements, and we access this ONLY scope value trought a pointer
    */




SCOPES := Scope_Table{}


    \item \texttt{scope\_reset}: redefine a tabela de símbolos limpando todos os escopos.

A função \verb`infer_type` serve para determinar o tipo de uma expressão sintática (representada por \verb`expr`) na AST durante a análise semântica. É usado um conjunto de regras para inferir e atribuir tipos à expressões. A base das regras são matematicas, como multiplicação entre numero real e vetor, produtor vetorial dentre dois vetores, assinatura de funções definidas, entre outras.


Essa função é projetada para lidar com todas construções que são expressões em \texttt{EquationLang}, como identificadores, operadores prefixados e infixados, chamadas de função e literais.

Inicialmente, a função verifica se o tipo da expressão já foi inferido (\verb"expr.ty_inferred"). Se sim, retorna o tipo previamente inferido, evitando processamento redundante. Caso contrário, prossegue com a inferência. O bloco central da função é um \verb"switch" que analisa os diferentes tipos de expressões derivadas de \verb"expr". Um trecho relevante dessa implementação está no \autoref{cod-type-inference}, onde é possivel ver a discrimição dos tipos e a validação.

v
v
Um trecho relevante dessa implementação está no \autoref{cod-type-inference}
Um exemplo desse processo está no 
ndo
%%%
A função \verb`infer_type` serve para determinar o tipo de uma expressão sintática (representada por \verb`expr`) na AST durante a análise semântica. É usado um conjunto de regras para inferir e atribuir tipos à expressões. A base das regras são matematicas, como multiplicação entre numero real e vetor, produtor vetorial dentre dois vetores, assinatura de funções definidas, entre outras.


Essa função é projetada para lidar com todas construções que são expressões em \texttt{EquationLang}, como identificadores, operadores prefixados e infixados, chamadas de função e literais.

Inicialmente, a função verifica se o tipo da expressão já foi inferido (\verb"expr.ty_inferred"). Se sim, retorna o tipo previamente inferido, evitando processamento redundante. Caso contrário, prossegue com a inferência. O bloco central da função é um \verb"switch" que analisa os diferentes tipos de expressões derivadas de \verb"expr". Um trecho relevante dessa implementação está no \autoref{cod-type-inference}, onde é possivel ver a discrimição dos tipos e a validação.



    \item Operações entre dois números resultam em um número.

à
basicstyle=\ttfamily\footnotesize
Esse processo também verifica redefinições de símbolos, prevenindo múltiplas declarações do mesmo identificador no mesmo escopo.

Declarações de equações são validadas após a etapa de coleta e ordenação descrita em \autoref{subsection-sym-resolution}, portanto assume-se que o lado esquerdo das equações deve ser um identificador válido ou a definição de uma função.

Todas as violações semânticas, como incompatibilidades de tipos ou uso de valores escalares onde vetores são esperados, são reportadas ao usuário, juntamente com informações detalhadas sobre o contexto e o local do erro, como descrito na \autoref{subsection-erros}.

A função \verb"check_expr" realiza uma traversia similiar a interencia de tipos e é ser responsável por chamar \texttt{infer\_type}. Nessa função, a análise de expressões que \texttt{infer\_type} deixou de fazer são feitas para todas os tipos de expressões, alguns dessas validações estão listado logo após este paragrafo. O recorte dessa traversia pode ser visto no \autoref{eq-function-check-expr}.

portanto assume-
portanto assume-se
com a exigência de

Declarações de equações são validadas após a etapa de coleta e ordenação descrita em \autoref{subsection-sym-resolution}, portanto assume-se que o lado esquerdo das equações deve ser um identificador válido ou a definição de uma função.

Todas as violações semânticas, como incompatibilidades de tipos ou uso de valores escalares onde vetores são esperados, são reportadas ao usuário, juntamente com informações detalhadas sobre o contexto e o local do erro, como descrito na \autoref{subsection-erros}.


%%%%

A função \verb"check_expr" realiza uma traversia similiar a interencia de tipos e é ser responsável por chamar \texttt{infer\_type}. Nessa função, a análise de expressões que \texttt{infer\_type} deixou de fazer são feitas para todas os tipos de expressões, alguns dessas validações estão listado logo após este paragrafo. O recorte dessa traversia pode ser visto no \autoref{eq-function-check-expr}.








    \item \verb`Expr_Function_Call`: Verifica se estamos fazendo a chamada com um identificador, pode ocorrer o caso de tentar fazer a chamada com um número $123(x,y)$, e isso está incorreto.

\begin{itemize}
    \item \verb`Expr_Function_Call`: Verifica se estamos fazendo a chamada com um identificador, pode ocorrer o caso de tentar fazer a chamada com um número $123(x,y)$, e isso está incorreto. Ou que o número de argumentos é diferente do número de paraemtros esperados
    \item \verb`Expr_Prefix`: Verifica operadores (\verb`-`, \verb`+`) e funções como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compatíveis, gerando erro caso contrário, como aceitar um vetor no seno seria incorreto.
    \item Literais de Vetor \verb`Expr_Vector_Literal`: Garante que vetores tenham exatamente 3 dimensões, reportando erros para formatos inválidos.
\end{itemize}

\begin{itemize}
    \item \verb`Expr_Function_Call`: Verifica se estamos fazendo a chamada com um identificador, pode ocorrer o caso de tentar fazer a chamada com um número $123(x,y)$, e isso está incorreto. Ou que o número de argumentos é diferente do número de paraemtros esperados
    \item \verb`Expr_Prefix`: Verifica operadores (\verb`-`, \verb`+`) e funções como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compatíveis, gerando erro caso contrário, como aceitar um vetor no seno seria incorreto.
    \item Literais de Vetor \verb`Expr_Vector_Literal`: Garante que vetores tenham exatamente 3 dimensões, reportando erros para formatos inválidos.
\end{itemize}

a
,
a
    `\max`,

basicstyle=\ttfamily\footnotesize
            
    
        // Código omitido de preambulo
        // Partimos checar os casos para cada tipo de expressão

    

            if !fn_sym_ok {
                error(e.open,  "Tried to call`%v`, which is not defined in this scope.", fn_string)
            }









    // Partimos checar os casos para cada tipo de expressão



            // The name of the function stores the functon type with argments type and returns



    // Primeiro inferimos o tipo

    






O procedimento \verb"check_function_definition" implementa a validação para definições de função, garantindo segurança de tipos e consistência de parâmetros. Ela é responsável pelas tarefas à seguir:

\begin{enumerate}
    \item Inferir os tipos para cada parâmetro
    \item Inferir o tipo de retorno com base na expressão final.
    \item Construir o tipo completo da função, incluindo parâmetros e retorno.
    \item Garantir que todos os identificadores utilizados estejam consistentes com seus tipos declarados.
    \item Validar todas as expressões no corpo da função.
    \item Criar um novo escopo para os parâmetros da funçã\textbackslash{}o
\end{enumerate}
%%%

O processo começa com o processamento dos parâmetros e o gerenciamento do escopo, como aparece no \autoref{cod-func-defn}. Quando uma função é definida, o sistema cria um novo escopo para armazenar informações dos parâmetros e da própria função em forma de símbolos a serem adicionados ao escopo atrelado a essa definição.

Esse escopo com simbolos são essencial para validar tanto as chamadas de função quanto as expressões no corpo da função. Cada função tem seu próprio escopo, cujo escopo pai é o global, prevenindo conflitos de identificadores.

O controle de visibilidade de símbolos é feito de forma específica. Na definição de escopo, se o $x$ existe nos parâmetros, primeiro é usado o $x$ do parâmetro antes de tentar acessar um $x$ global. Isso é chamado de \textit{shadowing} ou sombreamento do símbolo, como no caso da equação \autoref{eq-shadowing}, o resultado de $f$ é 3 e não 2.

è
O procedimento \verb"check_function_definition" implementa a validação para definições de função, garantindo segurança de tipos e consistência de parâmetros. Ela é responsável pelas tarefas à seguir:

\begin{enumerate}
    \item Inferir os tipos para cada parâmetro
    \item Inferir o tipo de retorno com base na expressão final.
    \item Construir o tipo completo da função, incluindo parâmetros e retorno.
    \item Garantir que todos os identificadores utilizados estejam consistentes com seus tipos declarados.
    \item Validar todas as expressões no corpo da função.
    \item Criar um novo escopo para os parâmetros da funçã\textbackslash{}o
\end{enumerate}
%%%

%%%%%%%


O processo começa com o processamento dos parâmetros e o gerenciamento do escopo, como aparece no \autoref{cod-func-defn}. Quando uma função é definida, o sistema cria um novo escopo para armazenar informações dos parâmetros e da própria função em forma de símbolos a serem adicionados ao escopo atrelado a essa definição.

Esse escopo com simbolos são essencial para validar tanto as chamadas de função quanto as expressões no corpo da função. Cada função tem seu próprio escopo, cujo escopo pai é o global, prevenindo conflitos de identificadores.

O controle de visibilidade de símbolos é feito de forma específica. Na definição de escopo, se o $x$ existe nos parâmetros, primeiro é usado o $x$ do parâmetro antes de tentar acessar um $x$ global. Isso é chamado de \textit{shadowing} ou sombreamento do símbolo, como no caso da equação \autoref{eq-shadowing}, o resultado de $f$ é 3 e não 2.

%%%

cod-parametros-validation
cod-func-
defn
A validação de identificadores no corpo da função utiliza o escopo da função para realizar três verificações principais: confirmar se o identificador está definido, verificar a compatibilidade do seu tipo com o símbolo no escopo e garantir que não haja violação das regras semânticas.



./Imagens/error-type-mismatch.png
\begin{codigo}[htb]
    \caption{\small Equação com uso incorreto de tipos na chamada de função. }
    \label{cod-type-mismatch}
\begin{lstlisting}[language=tex, numbers=none, frame=none, inputencoding=latin1]
\begin{equation}
    g(a, x) = a*x*x
\end{equation}

\begin{equation}
    f = g(1, \vec{1,1,1})
\end{equation}

\end{lstlisting}
\end{codigo}

f
,
A função $g$ espera dois números reais como argumentos, mas na equação $f$, um vetor foi passado no lugar de um numero, assim um erro será gerado. A \autoref{fig-type-mismatch} ilustra esse erro, indicando função que teve o argumento incompatível. Na hora de passar os argumentos também validamos que o quantidade de argumentos correspondem ao numero de parâmetros esperados.

𝑔
$g$
%%
𝑓

A função $g$ espera dois números reais como argumentos, mas na equação $f$, um vetor foi passado no lugar de um numero, assim um erro será gerado. A \autoref{fig-type-mismatch} ilustra esse erro, indicando função que teve o argumento incompatível. Na hora de passar os argumentos também validamos que o quantidade de argumentos correspondem ao numero de parâmetros esperados.







cod-check-single-ident
cod-check-single-ident
\begin{codigo}[htb]
    \caption{\small Validação de um uníco identificador dentro de contexto de parametros de uma função. }
    \label{cod-check-single-ident}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]

check_single_identifier :: proc(parameters: []^ast.Expr_Identifier, ident: ^ast.Expr_Identifier) {
    infer_type(ident)
    ident_key := key_from_identifier(ident)
    // Validates type consistency between declaration and usage
    if !is_type_equal(ident.ty_inferred, p.ty_inferred) {
        error(ident.identifier, "Parameter `%v` being use as type `%v` when the expected type is `%v`", ...)
    }
    // Código omitido por brevidade ..
}
\end{lstlisting}
\end{codigo}




cod-scope-management
basicstyle=\ttfamily\footnotesize

A fase de geração de código é responsável por transformar as estruturas intermediárias, como a AST anotada, em código de \textit{shading} GLSL. O pacote \texttt{emitter} realiza essa transformação, emitindo código compatível com a ferramenta da Disney BRDF Explorer.

A entrada principal para esse processo é o escopo global, que contém todas as informações necessárias para gerar o programa completo, como escopos filhos, simbolos, assinatura de funções e tipos. Nesta etapa, a AST está completamente anotada com tipos e informações auxiliares, acessíveis por meio dos símbolos presentes na tabela de símbolos que será usado geração de funções e expressões no formato apropriado.

Como o programa já foi validado anteriormente, assume-se sua corretude semântica, permitindo a travessia recursiva de todos os simbolos e nós, sem fazer nenhuma validação extra. A traversia abrange a geração de código para definições de funções, expressões e elementos específicos, como os lados esquerdo (LHS do inglês left hand side) e direito (RHS do inglês right hand side) das equações.

O lado esquerdo (LHS) pode envolver identificadores com subexpressões (e.g., $f_{n+1} = \dots$), parâmetros em definições de funções ou simplesmente símbolos como vetores ou números. A abordagem detalhada para o LHS é apresentada na \autoref{sec-LHS}. Já o lado direito (RHS) é sempre uma expressão, exigindo o uso do pacote \texttt{walker} para fazer a traversia da árvore para traduzir as operações e tipos inferidos para o equivalente em GLSL. Esse processo é explorado em \autoref{sec-RHS}.

Um ponto crucial é a necessidade de garantir que cada variável tenha um nome único no código GLSL, conforme detalhado em \autoref{sec-unicidade}.

,
código compatível com a Disney BRDF Explorer
A fase de geração de código é realizada pelo pacote \texttt{emitter}, criando um código compatível com a Disney BRDF Explorer. O processo começa com o escopo global, que contém informações essenciais como escopos, símbolos, assinaturas de funções e tipos. A AST já está completamente anotada, e a travessia recursiva dos símbolos e nós é realizada sem validações adicionais, pois a semântica já foi validada.

A fase de geração de código é realizada pelo pacote \texttt{emitter}, criando um código compatível com a Disney BRDF Explorer. O processo começa com o escopo global, que contém informações essenciais como escopos, símbolos, assinaturas de funções e tipos. A AST já está completamente anotada, e a travessia recursiva dos símbolos e nós é realizada sem validações adicionais, pois a semântica já foi validada.
%%
A fase de geração de código é responsável por transformar as estruturas intermediárias, como a AST anotada, em código de \textit{shading} GLSL. O pacote \texttt{emitter} realiza essa transformação, emitindo código compatível com a ferramenta da Disney BRDF Explorer.

A entrada principal para esse processo é o escopo global, que contém todas as informações necessárias para gerar o programa completo, como escopos filhos, simbolos, assinatura de funções e tipos. Nesta etapa, a AST está completamente anotada com tipos e informações auxiliares, acessíveis por meio dos símbolos presentes na tabela de símbolos que será usado geração de funções e expressões no formato apropriado.




Um ponto crucial é a necessidade de garantir que cada variável tenha um nome único no código GLSL, conforme detalhado em \autoref{sec-unicidade}.

A fase de geração de código é realizada pelo pacote \texttt{emitter}, que cria um código compatível com a Disney BRDF Explorer. O processo iniciae no escopo global, que contém informações essenciais, como escopos, símbolos, assinaturas de funções e tipos. A AST já está completamente anotada, e a travessia recursiva dos símbolos e nós ocorre sem validações adicionais, uma vez que a etapa semântica já foi validada.

A geração de código abrange tanto os lados esquerdo (LHS) quanto direito (RHS) das equações. O LHS pode incluir identificadores, parâmetros de funções ou símbolos simples. O RHS é sempre uma expressão, que é processada pelo pacote \texttt{walker} para traduzir operações e tipos para o formato GLSL.

Além disso, é fundamental garantir que cada variável tenha um nome único no código GLSL, conforme descrito em \autoref{sec-unicidade}.

%%%%%%
Como o programa já foi validado anteriormente, assume-se sua corretude semântica, permitindo a travessia recursiva de todos os simbolos e nós, sem fazer nenhuma validação extra. A traversia abrange a geração de código para definições de funções, expressões e elementos específicos, como os lados esquerdo (LHS do inglês left hand side) e direito (RHS do inglês right hand side) das equações.

O lado esquerdo (LHS) pode envolver identificadores com subexpressões (e.g., $f_{n+1} = \dots$), parâmetros em definições de funções ou simplesmente símbolos como vetores ou números. A abordagem detalhada para o LHS é apresentada na \autoref{sec-LHS}. Já o lado direito (RHS) é sempre uma expressão, exigindo o uso do pacote \texttt{walker} para fazer a traversia da árvore para traduzir as operações e tipos inferidos para o equivalente em GLSL. Esse processo é explorado em \autoref{sec-RHS}.

%%%
A fase de geração de código é realizada pelo pacote \texttt{emitter}, que cria um código compatível com a Disney BRDF Explorer. O processo iniciae no escopo global, que contém informações essenciais, como escopos, símbolos, assinaturas de funções e tipos. A AST já está completamente anotada, e a travessia recursiva dos símbolos e nós ocorre sem validações adicionais, uma vez que a etapa semântica já foi validada.

A geração de código abrange tanto os lados esquerdo (LHS) quanto direito (RHS) das equações. O LHS pode incluir identificadores, parâmetros de funções ou símbolos simples. O RHS é sempre uma expressão, que é processada pelo pacote \texttt{walker} para traduzir operações e tipos para o formato GLSL.

Além disso, é fundamental garantir que cada variável tenha um nome único no código GLSL, conforme descrito em \autoref{sec-unicidade}.

%%%%%%
Como o programa já foi validado anteriormente, assume-se sua corretude semântica, permitindo a travessia recursiva de todos os simbolos e nós, sem fazer nenhuma validação extra. A traversia abrange a geração de código para definições de funções, expressões e elementos específicos, como os lados esquerdo (LHS do inglês left hand side) e direito (RHS do inglês right hand side) das equações.

O lado esquerdo (LHS) pode envolver identificadores com subexpressões (e.g., $f_{n+1} = \dots$), parâmetros em definições de funções ou simplesmente símbolos como vetores ou números. A abordagem detalhada para o LHS é apresentada na \autoref{sec-LHS}. Já o lado direito (RHS) é sempre uma expressão, exigindo o uso do pacote \texttt{walker} para fazer a traversia da árvore para traduzir as operações e tipos inferidos para o equivalente em GLSL. Esse processo é explorado em \autoref{sec-RHS}.

%%%
A fase de geração de código é realizada pelo pacote \texttt{emitter}, que cria um código compatível com a Disney BRDF Explorer. O processo iniciae no escopo global, que contém informações essenciais, como escopos, símbolos, assinaturas de funções e tipos. A AST já está completamente anotada, e a travessia recursiva dos símbolos e nós ocorre sem validações adicionais, uma vez que a etapa semântica já foi validada.

A geração de código abrange tanto os lados esquerdo (LHS) quanto direito (RHS) das equações. O LHS pode incluir identificadores, parâmetros de funções ou símbolos simples. O RHS é sempre uma expressão, que é processada pelo pacote \texttt{walker} para traduzir operações e tipos para o formato GLSL.

Além disso, é fundamental garantir que cada variável tenha um nome único no código GLSL, conforme descrito em \autoref{sec-unicidade}.

%%%%%%
Como o programa já foi validado anteriormente, assume-se sua corretude semântica, permitindo a travessia recursiva de todos os simbolos e nós, sem fazer nenhuma validação extra. A traversia abrange a geração de código para definições de funções, expressões e elementos específicos, como os lados esquerdo (LHS do inglês left hand side) e direito (RHS do inglês right hand side) das equações.

O lado esquerdo (LHS) pode envolver identificadores com subexpressões (e.g., $f_{n+1} = \dots$), parâmetros em definições de funções ou simplesmente símbolos como vetores ou números. A abordagem detalhada para o LHS é apresentada na \autoref{sec-LHS}. Já o lado direito (RHS) é sempre uma expressão, exigindo o uso do pacote \texttt{walker} para fazer a traversia da árvore para traduzir as operações e tipos inferidos para o equivalente em GLSL. Esse processo é explorado em \autoref{sec-RHS}.

l
\subsection{Emissão de Equações}

A emissão de código começa pelo lado esquerdo da equação. Existem três aspectos principais nesse processo:
\begin{enumerate}
    \item Mapeamento de Tipos (LHS): O tipo associado ao identificador é a primeira informação a ser resolvida. Caso seja um número real, ele é mapeado para \verb"float" em GLSL. Para vetores ($\mathbb{R}^3$), o mapeamento é feito para \verb"vec3". Em definições de funções, utiliza-se o simbolo da função para acessar os tipos de parâmetros e do retorno, construindo assim a assinatura da função no formato GLSL.

    \item Identificador (LHS): O identificador associado ao símbolo é traduzido conforme regras específicas que garantem unicidade e conformidade com as restrições do GLSL. Este processo é detalhado em \autoref{sec-unicidade}.

    \item Expressões (RHS): No caso do lado direito da equação, tanto funções quanto de variaveis, são expressões. Para gerar isso, realiza-se uma travessia da AST, mapeando nós de expressões (como somas e chamadas de funções trigonométricas) para seu equivalente em GLSL. Detalhes adicionais sobre a emissão de código para expressões estão na \autoref{}.
\end{enumerate}


\label{sec-RHS}
A geração de expressões é uma das etapas mais importantes no processo de compilação e ocupa uma parte substancial do pacote \texttt{emitter}. Essa tarefa consiste em emitir código paras todas as expressões do lado direito das equações em código GLSL válido usando a AST anotada com tipos inferidos.

A implementação é realizada na função \verb"emit_expr", que recebe um nó de expressão e uma referência a um objeto \verb"StringBuilder" (da biblioteca padrão de Odin). Este objeto é utilizado para construir a cadeia de caracteres que corresponde a expressão equivalente em GLSL, evitando concatenações excessivas de strings.

A travessia da AST é realizada de forma recursiva utilizando o pacote \texttt{walker}, que converte diferentes tipos de expressões, incluindo operações binárias, prefixas, vetoriais e chamadas de função para código GLSL. Para isso, a função discrimina o tipo de nó, determinando qual operação correspondente deve ser utilizada em GLSL. 

Um recorte dessa função pode ser observado no \autoref{cod-emit-expr}, onde a discriminação dos tipos é feita é feita (\texttt{case}), e a construção de strings para funções trigonométricas é realizada na instância de \texttt{StringBuilder} através da função \verb|sbprint|. A seguir, são enumeradas as principais categorias de expressões tratadas:

A
A geração de expressões é uma das etapas mais importantes no processo de compilação e ocupa uma parte substancial do pacote \texttt{emitter}. Essa tarefa consiste em emitir código paras todas as expressões do lado direito das equações em código GLSL válido usando a AST anotada com tipos inferidos.

A implementação é realizada na função \verb"emit_expr", que recebe um nó de expressão e uma referência a um objeto \verb"StringBuilder" (da biblioteca padrão de Odin). Este objeto é utilizado para construir a cadeia de caracteres que corresponde a expressão equivalente em GLSL, evitando concatenações excessivas de strings.

Um exemplo dessa função está no \autoref{cod-emit-expr}, que demonstra como os tipos são discriminados (\texttt{case}) e strings para funções trigonométricas são geradas usando \verb|sbprint|. As principais categorias de expressões tratadas incluem operações matemáticas e chamadas de funções.
%%%


A travessia da AST é realizada de forma recursiva utilizando o pacote \texttt{walker}, que converte diferentes tipos de expressões, incluindo operações binárias, prefixas, vetoriais e chamadas de função para código GLSL. Para isso, a função discrimina o tipo de nó, determinando qual operação correspondente deve ser utilizada em GLSL. 



recorte

Um recorte dessa função pode ser observado no \autoref{cod-emit-expr}, onde a discriminação dos tipos é feita é feita (\texttt{case}), e a construção de strings para funções trigonométricas é realizada na instância de \texttt{StringBuilder} através da função \verb|sbprint|. 




,
identificadores e parâmetros de funções
o lado esquerdo
é explorado em \autoref{sec-RHS}
A fase de geração de código é realizada pelo pacote \texttt{emitter}, que cria um \textit{shader} compatível com a ferramenta Disney BRDF Explorer. O processo começa no escopo global, contendo informações essenciais como escopos, símbolos, assinaturas de funções e tipos. A AST já está completamente anotada, e a travessia recursiva dos símbolos e nós ocorre sem validações adicionais, uma vez que a etapa semântica já foi validada.

A geração de código abrange o lado esquerdo da equação, que inclue identificadores e parâmetros de funções e o direito que é sempre uma expressão, tal que que sua emissão é é explorado em \autoref{sec-RHS}.

Além disso, é essencial garantir que cada variável tenha um nome único no código GLSL, conforme descrito em \autoref{sec-unicidade}.





    \item \textbf{Expressões Chamadas de Função}:
        Na geração de uma chamada de função, ocorre a chamada recursiva para emitir a expressão do indentificador dessa função, depois abre parentesis \verb"(", e emite uma expressão para cada argumentos separado por virgula e, por fim, fecha o parentesis. Demonstrado no recorte do \autoref{cod-emission-func}.

     
parentesis
parêntese
parentesis
    \item \textbf{Expressões Chamadas de Função}:
        Na geração de uma chamada de função, ocorre a chamada recursiva para emitir a expressão do indentificador dessa função, depois abre parentesis \verb"(", e emite uma expressão para cada argumentos separado por virgula e, por fim, fecha o parentesis. Demonstrado no recorte do \autoref{cod-emission-func}.



é
eq-emit-expr-example
tab-conventions
tab-conventions-metodologia
tab-conventions
tab-conventions
i
---

:
sub-start-emitting
o
,
sub-start-
tab-conventions-metodologia
va trabalhar na tabela
