O
antes de avançar para uma linguagem mais complexa. O capítulo também descreve os testes elaborados para validar a implementação. Além disso, ele apresenta o 
\subsection{Mecanismo de Reflexão de Raios}
% \include{Pos_Textual/Apendices}
Chapter
\subsection{Mecanismo de Reflexão de Raios}
\section{Desenvolvimento}
@{}
d
\begin{codigo}[H]
  \caption{\small Exemplo GLSL de \textit{shader} de vértice.}
 \label{vertex_code1}
\begin{lstlisting}
#version 330 core
layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inNormal;
uniform mat4 modelViewProjection;
out vec3 fragNormal;
void main() {
    vec3 manipulatedPosition = inPosition + (sin(gl_VertexID * 0.1) * 0.1);
    fragNormal = inNormal;
    gl_Position = modelViewProjection * vec4(manipulatedPosition, 1.0);
}
\end{lstlisting}
\end{codigo}
à
S
- Explain Lambertianos



\autoref{code-gramatica}
\rho_{d}
($\rho_{d}$)
d
,
a
 usado na 
expr_grouped
;
\verb"
\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

H
diferentes
.


\subsubsection{Gerenciamento de Escopo}



env
}

}

\label{eq-preref}
\[
\]
\[
\]


    

}
    &a = \vec{1, 0, 1}

1, 0, 1
a
g
a
P

\begin{subequations}
\begin{equation}
    \rho_{d} = \vec{0,1,1}
\end{equation}

\begin{equation}
    \rho_{s} = \vec{1,0,1}
\end{equation}

\begin{equation}
    n = +2^8
\end{equation}

    &b = a \\

    \rho_{d} = \vec{0,1,1}

    &a = \vec{n}\\

    \rho_{s} = \vec{1,0,1}

    &f = b

\end{subequations}



\label{eq-preref}
\begin{align} 
\end{align}




    n = +2^8

\subsection{Validação de Equaçoes}

Para todos os identificadores, é criado um escopo global contendo todos os símbolos definidos. Declarações de equações são validadas verificando o lado esquerdo (LHS) das expressões, assegurando que o identificador esteja previamente definido. Isso ocorre após a etapa de coleta e ordenação descrita em \autoref{colega e ordenação de equações}. Cada LHS deve ser um identificador válido ou a definição de uma função. Esse processo também verifica redefinições de símbolos, prevenindo múltiplas declarações do mesmo identificador no mesmo escopo.

Todas as violações semânticas, como incompatibilidades de tipos ou uso de valores escalares onde vetores são esperados, são reportadas ao usuário, juntamente com informações detalhadas sobre o contexto e o local do erro.

Essa etapa de validação semântica provê a base necessária para garantir a correção do programa gerado, sendo crucial para a próxima etapa, que é a geração de código.

A função \verb"check_expr" realiza a mesma traversia que a interencia de tipos das expressões. Mas dessa vez fazendo validações que \texttt{infer\_type} deixou de fazer, garantindo que todas sigam as regras e sintaxe estabelecidas pela linguagem.

Os identificadores embutidos, definidos pelas convenções deste trabalho, são adicionados automaticamente à tabela de símbolos e estão prontos para uso imediato. A lista de identificadores embutidos pode ser vista em \autoref{cod-builtins}.

\begin{codigo}[htb]
    \caption{\small Identificadores embutidos pela convenção deste trabalho.}
    \label{cod-builtins}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
BUILTIN_IDENTIFIERS :: []string {
    `\max`,
    `\pi`,
    `\epsilon`,
    `\theta{h}`,
    `\vec{n}`,
    `\vec{h}`,
    `\vec{\omega{i}}`,
    `\theta{i}`,
    `\phi{i}`,
    `\vec{\omega{o}}`,
    `\theta{o}`,
    `\phi{o}`,
    `\theta{h}`,
    `\theta{d}`,
}
\end{lstlisting}
\end{codigo}

\subsection{Tipos de Expressões}

Essa etapa de validação semântica provê a base necessária para garantir a correção do programa gerado, sendo crucial para a próxima etapa, que é a geração de código.



\begin{itemize}
    
    \item Identificadores (\verb`Expr_Identifier`):
      Verifica se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. Se estiver definido:
    \item **Chamadas de Função (\verb`Expr_Function_Call`)**: 
      A função realiza várias validações:
      - Verifica se a expressão da esquerda é um identificador válido.
      - Confirma que o identificador refere-se a um símbolo do tipo função.
      - Garante que o número e os tipos dos argumentos correspondem aos parâmetros esperados.
      - Para cada argumento, chama recursivamente \verb`check_expr`.
    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**:  
      Avalia operadores como \verb`-`, \verb`+`, ou funções como `sqrt()` e `sin()`. Por exemplo:
      - Em \verb`sqrt(x)`, verifica se `x` é um número (\verb`ty_number`). Caso contrário, exibe um erro.
      - Para operadores básicos como \verb`-` e `+`, a inferência de tipo já determina o comportamento correto.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**:  
      Verifica se o vetor tem exatamente 3 dimensões. Caso contrário, gera um erro indicando o formato esperado.
\end{itemize}


\subsubsection{Casos mais relevantes}

@Do we needs this again?@







check_single_identifier
check_single_identifier
\begin{itemize}
    \item \textbf{Validação de Tipo de Parâmetro}
    \begin{itemize}
        \item Verificação explícita de tipos para parâmetros
        \item Tratamento de tipo vetor (reconhecimento do prefixo \verb|\vec|)
        \item Atribuição de tipo padrão
    \end{itemize}

    \item \textbf{Validação Baseada em Escopo}
    \begin{itemize}
        \item Gerenciamento hierárquico de escopo
        \item Controle de visibilidade de símbolos
        \item Isolamento de escopo de parâmetros
    \end{itemize}

    \item \textbf{Detecção de Erros}
    \begin{itemize}
        \item Detecção de incompatibilidade de tipos
        \item Validação de uso de parâmetros
        \item Verificação de violação de escopo
    \end{itemize}
\end{itemize}

\subsection{Detalhes Técnicos da Implementação}


\begin{codigo}[htb]
    \caption{\small Gerenciamento de escopo na validação do corpo da função.}
    \label{cod-scope-management}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
scope_enter(fn_sym.scope) {
    // Validação do corpo da função
    check_expr(body)
    // Inferência e validação de tipo
    body_type := infer_type(body)
}
\end{lstlisting}
\end{codigo}

\subsubsection{Gerenciamento de Escopo}

\subsubsection{Resolução de Símbolos}
\begin{itemize}
    \item Símbolos de parâmetros são resolvidos dentro do escopo da função
    \item Inferência de tipos é realizada para todos os identificadores
    \item Consistência de tipos é aplicada em todo o corpo da função
\end{itemize}


\subsection{Detalhes Técnicos da Implementação}



\subsection{Mecanismos de Segurança de Tipos}
A implementação garante segurança de tipos através de vários mecanismos:

 wjk

\section*{Validação de Campo de Declaração e Definição de Funções na Análise Semântica}

Este documento descreve o funcionamento das funções \texttt{check\_field} e \texttt{check\_function\_definition}, incluindo a validação semântica de campos, declaração de equações e definições de funções. 

\subsection*{Fluxo Geral da Função \texttt{check\_field}}

A função \texttt{check\_field} garante que os campos de uma estrutura ou declaração estejam semanticamente corretos. Esse processo segue as etapas abaixo:

\begin{itemize}
  \item \textbf{Validação do LHS (Chave):}  
  O lado esquerdo deve ser um identificador ou definição de função. Erros de validação são detalhados com mensagens explicativas.

  \item \textbf{Definições de Função:}  
  Chaves que representam definições de função são delegadas à função \texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.

  \item \textbf{Validação do RHS (Valor):}  
  O valor (\texttt{field.value}) é verificado recursivamente com \texttt{check\_expr}. Caso o tipo não esteja inferido, a inferência é realizada.

  \item \textbf{Comparação de Tipos:}  
  Após a inferência, verifica se os tipos do LHS e RHS são compatíveis. Inconsistências são detalhadas nas mensagens de erro.

  \item \textbf{Gerenciamento de Símbolos:}  
  Os símbolos representam variáveis ou funções na linguagem. Caso o símbolo já exista, ele é atualizado; caso contrário, um novo símbolo é criado.
\end{itemize}

A Validação de Campo de Declaração e Definição de Funções na Análise Semântica}



    // Primeiro inferimos o tipo

    #partial switch e in expr.derived {

    //

e
p
eq-function-check-expr
eq-function-check-expr
itemize
]
Dessa vez fazendo análise de expressões que \texttt{infer\_type} deixou de fazer, garantindo que todas sigam as regras e sintaxe estabelecidas pela linguagem.

    

\begin{itemize}
    \item Identificadores (\verb`Expr_Identifier`):
      Verifica se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. Se estiver definido:
    \item **Chamadas de Função (\verb`Expr_Function_Call`)**:
      A função realiza várias validações:
      - Verifica se a expressão da esquerda é um identificador válido.
      - Confirma que o identificador refere-se a um símbolo do tipo função.
      - Garante que o número e os tipos dos argumentos correspondem aos parâmetros esperados.
      - Para cada argumento, chama recursivamente \verb`check_expr`.
    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**:  
      Avalia operadores como \verb`-`, \verb`+`, ou funções como `sqrt()` e `sin()`. Por exemplo:
      - Em \verb`sqrt(x)`, verifica se `x` é um número (\verb`ty_number`). Caso contrário, exibe um erro.
      - Para operadores básicos como \verb`-` e `+`, a inferência de tipo já determina o comportamento correto.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**:  
      Verifica se o vetor tem exatamente 3 dimensões. Caso contrário, gera um erro indicando o formato esperado.
\end{itemize}

    \item Identificadores (\verb`Expr_Identifier`):
      Verifica se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. Se estiver definido:

    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**:  
      Avalia operadores como \verb`-`, \verb`+`, ou funções como `sqrt()` e `sin()`. Por exemplo:
      - Em \verb`sqrt(x)`, verifica se `x` é um número (\verb`ty_number`). Caso contrário, exibe um erro.
      - Para operadores básicos como \verb`-` e `+`, a inferência de tipo já determina o comportamento correto.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**:  
      Verifica se o vetor tem exatamente 3 dimensões. Caso contrário, gera um erro indicando o formato esperado.

  
\include

\invlude

      Verifica se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. Se estiver definido:

    \item Identificadores (\verb`Expr_Identifier`):
    \item **Chamadas de Função (\verb`Expr_Function_Call`)**:
      A função realiza várias validações:
      - Verifica se a expressão da esquerda é um identificador válido.
      - Confirma que o identificador refere-se a um símbolo do tipo função.
      - Garante que o número e os tipos dos argumentos correspondem aos parâmetros esperados.
      - Para cada argumento, chama recursivamente \verb`check_expr`.

Validação de Tipo de
\begin{itemize}
    \textbf{Validação de Tipo de Parâmetro}
    \begin{itemize}
        \item Verificação explícita de tipos para parâmetros
        \item Tratamento de tipo vetor (reconhecimento do prefixo \verb|\vec|)
        \item Atribuição de tipo padrão
    \end{itemize}

    \item \textbf{Validação Baseada em Escopo}
    \begin{itemize}
        \item Gerenciamento hierárquico de escopo
        \item Controle de visibilidade de símbolos
        \item Isolamento de escopo de parâmetros
    \end{itemize}

    \item \textbf{Detecção de Erros}
    \begin{itemize}
        \item Detecção de incompatibilidade de tipos
        \item Validação de uso de parâmetros
        \item Verificação de violação de escopo
    \end{itemize}
\end{itemize}

\begin{codigo}[H]
    \caption{\small Recorte da função \texttt{check\_expr}. }
    \label{eq-function-check-expr}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
check_expr :: proc(expr: ^ast.Expr) {
    // Primeiro inferimos o tipo
    infer_type(expr)
    // Código omitido de preambulo
    // Partimos checar os casos para cada tipo de expressão
        case ^Expr_Identifier:
            // Check for using undefined indetifiers
            identifier_key := key_from_identifier(e)
            if !is_defined(e, false) {
                error(e.identifier,  "Identifier `%v` is not defined in the current scope.", identifier_key)
            }

        case ^Expr_Grouped:
            // Basta vallidar o corpo da expressão agrupada
            check_expr(e.expr)

        case ^Expr_Prefix:
            // Validamos o lado dereito da expressão
            check_expr(e.right)
            if e.op.kind == .Sqrt {
                if !is_type_equal(e.right.ty_inferred, ty_number) {
                    error(e.op,  "Square root can only accept Numbers but instead got `%v`.", format_type(e.right.ty_inferred))
                }
            }
            // Código omitido ...
        case ^Expr_Infix:
            // Validamos dois lados da expressão binária e
            // checamos se são compativeis entre si
            check_expr(e.right)
            check_expr(e.left)
            // Código omitido ...

        case ^Expr_Vector_Literal:
            for number in e.numbers {
                check_expr(number)
            }

        case ^Expr_Number:
            // base case
        // Outros casos omitidos
    }
}

\end{lstlisting}
\end{codigo}



\input{Content/Desenvolvimento/code/Infer.tex}

\input{}

include
\subsection{Validação de Equaçoes}

Para todos os identificadores, é criado um escopo global contendo todos os símbolos definidos. Nessa validação é verificado se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. Se estiver definido:
Declarações de equações são validadas verificando o lado esquerdo (LHS) das expressões, assegurando que o identificador esteja previamente definido. Isso ocorre após a etapa de coleta e ordenação descrita em \autoref{colega e ordenação de equações}. Cada LHS deve ser um identificador válido ou a definição de uma função. Esse processo também verifica redefinições de símbolos, prevenindo múltiplas declarações do mesmo identificador no mesmo escopo.

Todas as violações semânticas, como incompatibilidades de tipos ou uso de valores escalares onde vetores são esperados, são reportadas ao usuário, juntamente com informações detalhadas sobre o contexto e o local do erro.

A função \verb"check_expr" realiza a mesma traversia que a interencia de tipos das expressões. Dessa vez fazendo análise de expressões que \texttt{infer\_type} deixou de fazer, garantindo que todas sigam as regras e sintaxe estabelecidas pela linguagem. O recorte dessa traversia pode ser visto no \autoref{eq-function-check-expr}. 

Os identificadores embutidos, definidos pelas convenções deste trabalho, são adicionados automaticamente à tabela de símbolos e estão prontos para uso imediato. A lista de identificadores embutidos pode ser vista em \autoref{cod-builtins}.

\begin{itemize}
    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**:
      Avalia operadores como \verb`-`, \verb`+`, ou funções como `sqrt()` e `sin()`. Por exemplo:
      - Em \verb`sqrt(x)`, verifica se `x` é um número (\verb`ty_number`). Caso contrário, exibe um erro.
      - Para operadores básicos como \verb`-` e `+`, a inferência de tipo já determina o comportamento correto.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**:
      Verifica se o vetor tem exatamente 3 dimensões. Caso contrário, gera um erro indicando o formato esperado.
\end{itemize}


\begin{codigo}[htb]
    \caption{\small Identificadores embutidos pela convenção deste trabalho.}
    \label{cod-builtins}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
BUILTIN_IDENTIFIERS :: []string {
    `\max`,
    `\pi`,
    `\epsilon`,
    `\theta{h}`,
    `\vec{n}`,
    `\vec{h}`,
    `\vec{\omega{i}}`,
    `\theta{i}`,
    `\phi{i}`,
    `\vec{\omega{o}}`,
    `\theta{o}`,
    `\phi{o}`,
    `\theta{h}`,
    `\theta{d}`,
}
\end{lstlisting}
\end{codigo}


\input{Content/Desenvolvimento/code/Check}

Funcionamento das funções \texttt{check\_field} e \texttt{check\_function\_definition}, incluindo a validação semântica de campos, declaração de equações e definições de funções.

\subsection*{Fluxo Geral da Função \texttt{check\_field}}

A função \texttt{check\_field} garante que os campos de uma estrutura ou declaração estejam semanticamente corretos. Esse processo segue as etapas abaixo:

\begin{itemize}
  \item \textbf{Validação do LHS (Chave):}  
  O lado esquerdo deve ser um identificador ou definição de função. Erros de validação são detalhados com mensagens explicativas.

  \item \textbf{Definições de Função:}  
  Chaves que representam definições de função são delegadas à função \texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.

  \item \textbf{Validação do RHS (Valor):}  
  O valor (\texttt{field.value}) é verificado recursivamente com \texttt{check\_expr}. Caso o tipo não esteja inferido, a inferência é realizada.

  \item \textbf{Comparação de Tipos:}  
  Após a inferência, verifica se os tipos do LHS e RHS são compatíveis. Inconsistências são detalhadas nas mensagens de erro.

  \item \textbf{Gerenciamento de Símbolos:}  
  Os símbolos representam variáveis ou funções na linguagem. Caso o símbolo já exista, ele é atualizado; caso contrário, um novo símbolo é criado.
\end{itemize}


\subsection{Validação de Funções}
A validação semântica de definições e chamadas de funções segue um processo semelhante ao da análise de expressões, mas o uso da pilha de escopos. As variáveis no corpo da função (lado direito da equação) devem ser validadas para garantir que todos os símbolos estejam definidos.

A validação do corpo da função representa a etapa final do processo de checagem e envolve:

\begin{enumerate}
    \item Validar todas as expressões no corpo da função.
    \item Inferir o tipo de retorno com base na expressão final.
    \item Construir o tipo completo da função, incluindo parâmetros e retorno.
    \item Garantir que todos os identificadores utilizados estejam consistentes com seus tipos declarados.
\end{enumerate}
%%%
\begin{itemize}
    \item \textbf{Validação de Tipo de Parâmetro}
    \begin{itemize}
        \item Verificação explícita de tipos para parâmetros
        \item Tratamento de tipo vetor (reconhecimento do prefixo \verb|\vec|)
        \item Atribuição de tipo padrão
    \end{itemize}

    \item \textbf{Validação Baseada em Escopo}
    \begin{itemize}
        \item Gerenciamento hierárquico de escopo
        \item Controle de visibilidade de símbolos
        \item Isolamento de escopo de parâmetros
    \end{itemize}

    \item \textbf{Detecção de Erros}
    \begin{itemize}
        \item Detecção de incompatibilidade de tipos
        \item Validação de uso de parâmetros
        \item Verificação de violação de escopo
    \end{itemize}
\end{itemize}

O processo começa com o processamento dos parâmetros e o gerenciamento do escopo. Quando uma função é definida, o sistema cria um novo escopo para armazenar informações dos parâmetros e da própria função em forma de simbolos à serem adicionados ao escopo atrelado a essa definição.

Esse escopo com simbolos são essencial para validar tanto as chamadas de função quanto as expressões no corpo da função. Cada função tem seu próprio escopo, cujo escopo pai é o global, prevenindo conflitos de identificadores.

Na definição de escopo, se o $x$ existe nos parâmetros, primeiro é usado o $x$ do parâmetro antes de tentar acessar um $x$ global. Isso é chamado de \textit{shadowing} ou sombreamento do símbolo, como no caso da equação \autoref{eq-shadowing}, o resultado de $f$ é 3 e não 2.

\begin{align} \label{eq-shadowing}
    &x = 2 \\
    &g(x) = x \\
    &f = g(3)
\end{align}


%%%
Durante a validação dos parâmetros, cada identificador passa pela inferência de tipo. Parâmetros explicitamente marcados com o prefixo \verb"\vec" recebem o tipo padrão $\mathbb{R}^3$ (vetor tridimensional). Caso contrário, o tipo padrão atribuído é o de número real ($\mathbb{R}$).

A validação de identificadores do corpo da função (lado direito da equação) usa o escopo da função para verificar se o identificador está definido, se seu tipo é compatível com o encontrado no simbolo presente neste escopo; e verifica ele não viola as regras semânticas.

Identificadores especiais, como $\omega_i$ e $\theta_d$, são inseridos automaticamente no escopo global com seus tipos predefinidos. Por exemplo, se o parâmetro $\vec{x}$ é declarado como vetor, todo uso de x no corpo da função deve respeitar as operações vetoriais, ou um erro será reportado.

\begin{itemize}
    \item **Chamadas de Função (\verb`Expr_Function_Call`)**:
      A função realiza várias validações:
      - Verifica se a expressão da esquerda é um identificador válido.
      - Confirma que o identificador refere-se a um símbolo do tipo função.
      - Garante que o número e os tipos dos argumentos correspondem aos parâmetros esperados.
      - Para cada argumento, chama recursivamente \verb`check_expr`.
\end{itemize}

Chamadas de função passam por uma validação semelhante: os argumentos fornecidos têm seus tipos inferidos e são comparados com a assinatura da função chamada (\verb"Type_Function"). Por exemplo, no código da \autoref{cod-type-mismatch}, a função $g$ tem a assinatura $\mathbb{R} \times \mathbb{R} \to \mathbb{R}$. A expressão de chamada de função resultante tem o tipo do contradomínio da função chamada. Se, por exemplo, $f$ espera dois números reais como argumentos e um vetor é passado no lugar de um deles, um erro será gerado. A \autoref{fig-type-mismatch} ilustra tal erro, indicando exatamente o argumento incompatível.

\begin{codigo}[htb]
    \caption{\small Equação com uso incorreto de tipos na chamada de função. }
    \label{cod-type-mismatch}
\begin{lstlisting}[language=tex, numbers=none, frame=none, inputencoding=latin1]
\begin{equation}
    g(a, x) = a*x*x
\end{equation}

\begin{equation}
    f = g(1, \vec{1,1,1})
\end{equation}

\end{lstlisting}
\end{codigo}

\begin{figure}[H]
    \caption{\label{fig-type-mismatch} \small Erro gerado por uso incorreto de tipos na chamada de função.}
    \begin{center}
        \includegraphics[scale=0.5]{./Imagens/error-type-mismatch.png}
    \end{center}
\end{figure}


\begin{codigo}[htb]
    \caption{\small Validação de parametros de uma função. }
    \label{cod-parametros-validation}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
// ...
parameter_types := [dynamic]^Type{}
scope_enter(fn_sym.scope) {
    for &parameter in fn.parameters {
        parameter_key := key_from_identifier(parameter)
        ty := infer_type(parameter, true, ty_number)
        parameter_sym.type = ty
        append(&parameter_types, ty)
    }
}
// ...
\end{lstlisting}
\end{codigo}


\begin{codigo}[htb]
    \caption{\small Validação de um uníco identificador dentro de contexto de parametros de uma função. }
    \label{cod-check-single-ident}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]

check_single_identifier :: proc(parameters: []^ast.Expr_Identifier, ident: ^ast.Expr_Identifier) {
    infer_type(ident)
    ident_key := key_from_identifier(ident)
    // Validates type consistency between declaration and usage
    if !is_type_equal(ident.ty_inferred, p.ty_inferred) {
        error(ident.identifier, "Parameter `%v` being use as type `%v` when the expected type is `%v`", ...)
    }
    // Código omitido por brevidade ..
}
\end{lstlisting}
\end{codigo}


% \subsection{Validação de Definição e Declaração de Função na Análise Semântica}

\subsection{Validação da Definição de Função}
O procedimento \verb`check_function_definition` implementa um sistema de validação abrangente para definições de função, garantindo segurança de tipos e consistência de parâmetros.

\subsubsection{Fase 1: Processamento de Parâmetros}
Aspectos principais:
\begin{itemize}
    \item Cria um novo escopo para os parâmetros da função
    \item Inferência de tipos para cada parâmetro
    \item Mantém informações sobre o tipo dos parâmetros
    \item Tratamento de tipo padrão (número se não for vetor)
\end{itemize}

\subsubsection{Fase 2: Validação de Identificadores}
Assim como no parser, temos uma correspondência entre os tipos da árvore sintática com \verb|Expr_Identifier|, \verb|Expr_Infix|, etc., com funções que podem ser indiretamente recursivas, como \verb|check_single_identifier| (\autoref{cod-check-single-ident}), \verb|check_expr|, etc.

\subsubsection{Fase 3: Validação do Corpo da Função}
\begin{codigo}[htb]
    \caption{\small Validação do corpo da função.}
    \label{cod-function-body-validation}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
scope_enter(fn_sym.scope) {
    check_expr(body)
    body_type := infer_type(body)
    result_types := [dynamic]^Type{body_type}
    fn_type := make_function_type(parameter_types[:], result_types[:])
}
\end{lstlisting}
\end{codigo}

Passos principais:
\begin{itemize}
    \item Validação de expressões
    \item Inferência do tipo de retorno
    \item Construção do tipo de função
    \item Gerenciamento de escopo
\end{itemize}

\subsection{Tratamento de Declaração de Equação}
\begin{codigo}[htb]
    \caption{\small Tratamento de declaração de equação.}
    \label{cod-equation-declaration}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
case ^Decl_Equation:
    check_decl(s)
\end{lstlisting}
\end{codigo}


\begin{codigo}[htb]
    \caption{\small Gerenciamento de escopo na validação do corpo da função.}
    \label{cod-scope-management}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
scope_enter(fn_sym.scope) {
    // Validação do corpo da função
    check_expr(body)
    // Inferência e validação de tipo
    body_type := infer_type(body)
}
\end{lstlisting}
\end{codigo}

\subsection*{Validação de Definições de Funções}

A função \texttt{check\_function\_definition} é responsável pela validação completa de definições de funções. Ela assegura a consistência dos parâmetros e a segurança de tipos.

\subsubsection*{Fase 1: Processamento de Parâmetros}
\begin{itemize}
  \item Cria um novo escopo para os parâmetros da função.
  \item Realiza inferência de tipos para cada parâmetro.
  \item Lida com tipos padrão (e.g., vetor para prefixos \textbackslash{}vec).
\end{itemize}

\subsubsection*{Fase 2: Validação do Identificador}
Correspondências entre a árvore sintática e os tipos são validadas recursivamente por funções como \texttt{check\_single\_identifier} e \texttt{check\_expr}.

\subsubsection*{Fase 3: Validação do Corpo da Função}
O corpo da função é validado em um escopo isolado:
\begin{itemize}
  \item Expressões são verificadas com \texttt{check\_expr}.
  \item O tipo de retorno é inferido e comparado com o tipo declarado.
  \item O tipo da função é construído com base nos parâmetros e resultados.
\end{itemize}

\begin{codigo}[htb]
    \caption{\small Estruturas que representam o tipo de um expressão da AST.}
    \label{cod-types-structs}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=utf8]
case ^Decl_Equation:
    check_decl(s)

scope_enter(fn_sym.scope) {
    // Validação do corpo da função
    check_expr(body)
    // Inferência e validação de tipo
    body_type := infer_type(body)
    result_types := [dynamic]^Type{body_type}
    fn_type := make_function_type(parameter_types[:], result_types[:])
}
\end{lstlisting}
\end{codigo}

\subsection*{Mecanismos de Segurança de Tipos}

A implementação garante a segurança de tipos por meio de:
\begin{itemize}
  \item \textbf{Validação de Parâmetros:}
  Checagem explícita de tipos para parâmetros e reconhecimento de vetores (\textbackslash{}vec).

  \item \textbf{Gerenciamento de Escopos:}
  Uso de operações hierárquicas (\texttt{scope\_enter}/\texttt{scope\_exit}) para evitar conflitos de símbolos.

  \item \textbf{Detecção de Erros:}
  Identificação de inconsistências de tipo, violações de escopo e uso inválido de parâmetros.
\end{itemize}

\subsection*{Exemplo de Declaração de Equação}

Se estiver definido:

A função \verb"check_expr" realiza a análise detalhada de expressões, garantindo que sigam as regras da linguagem e complementando a inferência de tipos feita por \texttt{infer\_type}. Isso inclui:

A função \verb"check_expr" realiza a análise detalhada de expressões, garantindo que sigam as regras da linguagem e complementando a inferência de tipos feita por \texttt{infer\_type}. Isso inclui:

\begin{itemize}
    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**:
      Avalia operadores como \verb`-`, \verb`+`, ou funções como `sqrt()` e `sin()`. Por exemplo:
      - Em \verb`sqrt(x)`, verifica se `x` é um número (\verb`ty_number`). Caso contrário, exibe um erro.
      - Para operadores básicos como \verb`-` e `+`, a inferência de tipo já determina o comportamento correto.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**:
      Verifica se o vetor tem exatamente 3 dimensões. Caso contrário, gera um erro indicando o formato esperado.
\end{itemize}



    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**: Verifica operadores (\verb`-`, \verb`+`) e funções como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compatíveis, gerando erro caso contrário.

í


\texttt{infer\_type}
\texttt{infer\_type}
a
fazendo
,



  \item \textbf{Validação do LHS (Chave):}  
  O lado esquerdo deve ser um identificador ou definição de função. Erros de validação são detalhados com mensagens explicativas.

  Chaves que representam definições de função são delegadas à função \texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.

\texttt{check\_expr}. Caso o tipo não esteja inferido, a inferência é realizada.
  Os símbolos representam variáveis ou funções na linguagem. Caso o símbolo já exista, ele é atualizado; caso contrário, um novo símbolo é criado.


\begin{itemize}

  \item \textbf{Definições de Função:}  


  \item \textbf{Validação do RHS (Valor):}  
  O valor (\texttt{field.value}) é verificado recursivamente com 
  \item \textbf{Comparação de Tipos:}  
  Após a inferência, verifica se os tipos do LHS e RHS são compatíveis. Inconsistências são detalhadas nas mensagens de erro.

  \item \textbf{Gerenciamento de Símbolos:}  
\end{itemize}


\begin{itemize}

  \item \textbf{Definições de Função:}  


  \item \textbf{Validação do RHS (Valor):}  
  O valor (\texttt{field.value}) é verificado recursivamente com 
  \item \textbf{Comparação de Tipos:}  
  Após a inferência, verifica se os tipos do LHS e RHS são compatíveis. Inconsistências são detalhadas nas mensagens de erro.

  \item \textbf{Gerenciamento de Símbolos:}  
\end{itemize}

\subsection*{Fluxo Geral da Função \texttt{check\_field}}



        \item Controle de visibilidade de símbolos

Controle de visibilidade de símbolos
Controle de visibilidade de símbolos
Validação de uso de parâmetros
Tratamento de tipo vetor (reconhecimento do prefixo \verb|\vec|)
\begin{itemize}
    \item \textbf{Validação de Tipo de Parâmetro}
    \begin{itemize}
        \item Verificação explícita de tipos para parâmetros
        \item 
        \item Atribuição de tipo padrão
    \end{itemize}

    \item \textbf{Validação Baseada em Escopo}
    \begin{itemize}
        \item Gerenciamento hierárquico de escopo
        \item 
        \item Isolamento de escopo de parâmetros
    \end{itemize}

    \item \textbf{Detecção de Erros}
    \begin{itemize}
        \item Detecção de incompatibilidade de tipos
        \item 
        \item Verificação de violação de escopo
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item **Chamadas de Função (\verb`Expr_Function_Call`)**:
      A função realiza várias validações:
      - Verifica se a expressão da esquerda é um identificador válido.
      - Confirma que o identificador refere-se a um símbolo do tipo função.
      - Garante que o número e os tipos dos argumentos correspondem aos parâmetros esperados.
      - Para cada argumento, chama recursivamente \verb`check_expr`.
\end{itemize}

check_single_identifier
O procedimento \verb`check_function_definition` implementa um sistema de validação abrangente para definições de função, garantindo segurança de tipos e consistência de parâmetros.

title
check_function_definition :: proc(fn : ^ast.Expr_Function_Definition, body: ^ast.Expr) {
    using ast, fmt

    fn_sym, ok := scope_get(key_from_identifier(fn.name))
    assert(ok, fmt.tprint("The fn symbol for", key_from_identifier(fn.name), " should have been set by now") )


    parameter_types := [dynamic]^Type{}

    scope_enter(fn_sym.scope)
        // We can'tr really loop by scope because order is not preserved for parameter_key, parameter in fn_sym.scope.elements {
        for &parameter in fn.parameters {
            parameter_key := key_from_identifier(parameter)
            // By default if it didn't recognise as vector
            // we set it a default to number
            ty := infer_type(parameter, true, ty_number)

            parameter_sym, parameter_exits := scope_get_from(fn_sym.scope, parameter_key)
            assert(parameter_exits)

            parameter_sym.type = ty
            append(&parameter_types, ty)
        }
    scope_exit()

    //
    // Now we gotta make sure every instance where the parameter identifier is
    // used inside the body, it has the type expected from the parameter
    //
    check_single_identifier :: proc(parameters: []^ast.Expr_Identifier, ident: ^ast.Expr_Identifier, ) {
        // Just in case we infer it, no problem can occur if the type is already set
        infer_type(ident)
        ident_key := key_from_identifier(ident)
        for p in parameters {
            infer_type(p)
            p_key := key_from_identifier(p)

            // if match, they should have the same type
            if ident_key == p_key {
                if !is_type_equal(ident.ty_inferred, p.ty_inferred) {
                    error(ident.identifier, "Parameter `%v` being use as type `%v` when the expected type is `%v`\nRemember that if you want a vector you should prefix it with `\\vec`", p_key,  format_type(ident.ty_inferred), format_type(p.ty_inferred)  )
                }
            }
        }

    }

    check_for_identifiers_inside_function :: proc(node: ^ast.Node, parameters: []^ast.Expr_Identifier,) {
        ident, ident_ok := node.derived.(^ast.Expr_Identifier)
        if ident_ok {
            check_single_identifier(parameters, ident)
            //
            // We don't wanna go into more in depth sub indenfitiers
            // because the scope only cares about top level identifiers
            // because of that we just return
            //
            return;
        }

        children := ast.children(node)
        defer delete(children)
        for c in children {
            check_for_identifiers_inside_function(c, parameters)
        }
    }



    // assert(false,  "scope_print(fn_sym.scope)")

    //
    // We push this scope
    // to make parameters being used in the body
    // have a symbol defined
    //
    scope_enter(fn_sym.scope)
        check_expr(body)
        body_type := infer_type(body)

        when #config(DEV, false) {
            // Quickly check for le types by printing the type annotated ast
            if true do walker.print_ast(body)
        }

        result_types := [dynamic]^Type{body_type}
        fn_type := make_function_type(parameter_types[:], result_types[:] )
        fn.ty_inferred = fn_type


        check_for_identifiers_inside_function(body, fn.parameters)
    scope_exit()

    fn_sym.type = fn.ty_inferred
    fn_sym.fn_defn = fn
}

 \\
\\
Para todos os identificadores, é criado um escopo global contendo todos os símbolos definidos. Nessa validação é verificado se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. 

Para todos os identificadores, é criado um escopo global contendo todos os símbolos definidos. Nessa validação é verificado se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. 

Para todos os identificadores, é criado um escopo global contendo todos os símbolos definidos. Nessa validação é verificado se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. 

Para todos os identificadores, é criado um escopo global contendo todos os símbolos definidos. Nessa validação é verificado se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. 

Para todos os identificadores
Os identificadores embutidos, definidos pelas convenções deste trabalho, são adicionados automaticamente à tabela de símbolos e estão prontos para uso imediato. A lista de identificadores embutidos pode ser vista em \autoref{cod-builtins}.

Funcionamento das funções \texttt{check\_field} e \texttt{check\_function\_definition}, incluindo a validação semântica de campos, declaração de equações e definições de funções.



A função \texttt{check\_field} garante que os campos de uma estrutura ou declaração estejam semanticamente corretos. Esse processo segue as etapas abaixo:

A
o
      - Garante que o número e os tipos dos argumentos correspondem aos parâmetros esperados.

 w
\subsection{Validação de Funções}

\subsubsection{Definição de Funções}

A validação do corpo da função representa a etapa final do processo de checagem e envolve:

Validação de uso de parâmetros

Validação de uso de parâmetros

 \
Identificadores especiais
Identificadores especiais, como $\omega_i$ e $\theta_d$, são inseridos automaticamente no escopo global com seus tipos predefinidos. Por exemplo, se o parâmetro $\vec{x}$ é declarado como vetor, todo uso de x no corpo da função deve respeitar as operações vetoriais, ou um erro será reportado.

\subsubsection{Definição de Funções}

O procedimento \verb`check_function_definition` implementa um sistema de validação abrangente para definições de função, garantindo segurança de tipos e consistência de parâmetros.

O procedimento \verb`check_function_definition` implementa um sistema de validação abrangente para definições de função, garantindo segurança de tipos e consistência de parâmetros.

\subsection{Validação da Definição de Função}


    \item Cria um novo escopo para os parâmetros da função

    \item Cria um novo escopo para os parâmetros da função
    \item Inferência de tipos para cada parâmetro
    \item Mantém informações sobre o tipo dos parâmetros
    \item Tratamento de tipo padrão (número se não for vetor)

Assim como no parser, temos uma correspondência entre os tipos da árvore sintática com \verb|Expr_Identifier|, \verb|Expr_Infix|, etc., com funções que podem ser indiretamente recursivas, como \verb|check_single_identifier| (\autoref{cod-check-single-ident}), \verb|check_expr|, etc.

\subsubsection{Fase 2: Validação de Identificadores}


scope_enter(fn_sym.scope) {
    check_expr(body)
    body_type := infer_type(body)
    result_types := [dynamic]^Type{body_type}
    fn_type := make_function_type(parameter_types[:], result_types[:])
}

    \item Validação de expressões
    \item Inferência do tipo de retorno
    \item Construção do tipo de função
    \item Gerenciamento de escopo

Passos principais:
\begin{itemize}
\end{itemize}

A função \texttt{check\_function\_definition} é responsável pela validação completa de definições de funções. Ela assegura a consistência dos parâmetros e a segurança de tipos.

  \item Cria um novo escopo para os parâmetros da função.
  \item Realiza inferência de tipos para cada parâmetro.
  \item Lida com tipos padrão (e.g., vetor para prefixos \textbackslash{}vec).


\subsubsection*{Fase 1: Processamento de Parâmetros}
\begin{itemize}
\end{itemize}

Correspondências entre a árvore sintática e os tipos são validadas recursivamente por funções como \texttt{check\_single\_identifier} e \texttt{check\_expr}.

\subsubsection*{Fase 2: Validação do Identificador}

\subsubsection*{Fase 3: Validação do Corpo da Função}
O corpo da função é validado em um escopo isolado:
\begin{itemize}

  \item Expressões são verificadas com \texttt{check\_expr}.
  \item O tipo de retorno é inferido e comparado com o tipo declarado.
  \item O tipo da função é construído com base nos parâmetros e resultados.
\end{itemize}

A implementação garante a segurança de tipos por meio de:
\begin{itemize}
  \item \textbf{Validação de Parâmetros:}
  Checagem explícita de tipos para parâmetros e reconhecimento de vetores (\textbackslash{}vec).

  \item \textbf{Gerenciamento de Escopos:}
  Uso de operações hierárquicas (\texttt{scope\_enter}/\texttt{scope\_exit}) para evitar conflitos de símbolos.

  \item \textbf{Detecção de Erros:}
  Identificação de inconsistências de tipo, violações de escopo e uso inválido de parâmetros.
\end{itemize}

\subsection*{Exemplo de Declaração de Equação}

\subsection*{Mecanismos de Segurança de Tipos}





\subsubsection{Fase 1: Processamento de Parâmetros}
Aspectos principais:
\begin{itemize}
\end{itemize}

Aspectos principais:
\begin{itemize}
\end{itemize}

\begin{codigo}[htb]
    \caption{\small Validação do corpo da função.}
    \label{cod-function-body-validation}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
\end{lstlisting}
\end{codigo}



\vec{x}
\subsubsection{Resolução de Símbolos}

    \item Inferência de tipos é realizada para todos os identificadores

Símbolos de parâmetros são resolvidos dentro do escopo da função
\begin{itemize}
    \item 
    \item Consistência de tipos é aplicada em todo o corpo da função
\end{itemize}

\subsection{Resolução de Símbolos}

A resolução de símbolos é uma etapa fundamental no \texttt{checker}, garantindo que cada símbolo seja corretamente definido e tipado antes de seu uso. Esse processo é especialmente relevante em situações onde a ordem de definição não segue um fluxo linear, como no exemplo da \autoref{eq-preref}).

Para todos os identificadores, é criado um escopo global contendo todos os símbolos definidos. Nessa validação é verificado se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. 

Os identificadores embutidos, definidos pelas convenções deste trabalho, são adicionados automaticamente à tabela de símbolos e estão prontos para uso imediato. A lista de identificadores embutidos pode ser vista em \autoref{cod-builtins}. Identificadores especiais, como $\omega_i$ e $\theta_d$, são inseridos automaticamente no escopo global com seus tipos predefinidos. 
Símbolos de parâmetros são resolvidos dentro do escopo da função.


\begin{subequations} \label{eq-preref}
\begin{equation}
    b = a
\end{equation}

\begin{equation}
    a = \vec{n}
\end{equation}

\begin{equation}
    f = b
\end{equation}
\end{subequations}

Nesse caso, \texttt{b} é atribuído a \texttt{a} antes que \texttt{a} tenha sido definido. O \texttt{checker} deve resolver essa dependência, analisando \texttt{a} antes de \texttt{b} para inferir corretamente o tipo de \texttt{b}. Isso é possível por conta da construção de um grafo de dependências entre símbolos (apresentado na \autoref{cod-grafo-simbol-deps}). Utilizando uma ordenação topológica desse grafo, o sistema determina uma ordem de avaliação válida, além de identificar casos de dependências circulares que poderiam impedir a compilação.


Essa ordenação permite o uso de simbolos antes da sua equação ser declarada, desde que estejam devidamente definidas em alguma das equações. Adicionalmente, a resolução de símbolos lida com escopos, parâmetros de funções e símbolos embutidos, que são os definidos na tabela de convenções de símbolos matemáticos (\autoref{@va trabahlhar vagabundo@}).


A resolução de simbolos mantém uma lista com a ordem correta de avaliação das declaraçãos, recurso particularmente importante na geração de código GLSL, onde referências a variáveis antes de suas declarações não são permitidas.


Nessa resolução, é considerado o escopo do simbolo apropriadamente e é nessa etapa que detectamos se a função $f$, a BRDF por convenção, existe no escopo global. Para implementar essas funcionalidades, o pacote \texttt{checker} é dividido em múltiplas passadas na AST, na seguinte ordem:

A resolução de símbolos é uma etapa crucial no \texttt{checker}, assegurando que cada símbolo seja definido e tipado corretamente antes do uso. Isso é particularmente relevante em cenários onde a ordem de definição não é linear, como no exemplo da \autoref{eq-preref}.

%%%%

$\omega_i$ e $\theta_d$
$\omega_i$ e $\theta_d$
Para todos os identificadores, é criado um escopo global contendo todos os símbolos definidos. Nessa validação é verificado se o identificador está definido no escopo atual. Caso contrário, gera um erro com a mensagem apropriada. 

Os identificadores embutidos, definidos pelas convenções deste trabalho, são adicionados automaticamente à tabela de símbolos e estão prontos para uso imediato. A lista de identificadores embutidos pode ser vista em \autoref{cod-builtins}. Identificadores especiais, como $\omega_i$ e $\theta_d$, são inseridos automaticamente no escopo global com seus tipos predefinidos. 
Símbolos de parâmetros são resolvidos dentro do escopo da função.


\begin{subequations} \label{eq-preref}
\begin{equation}
    b = a
\end{equation}

\begin{equation}
    a = \vec{n}
\end{equation}

\begin{equation}
    f = b
\end{equation}
\end{subequations}

\autoref{eq-preref}
seja definido
A partir de
sequência
que possam impedir a compilação.
No exemplo acima, \texttt{b} é atribuído a \texttt{a} antes que \texttt{a} . O \texttt{checker} resolve essa dependência construindo um grafo entre os símbolos (\autoref{cod-grafo-simbol-deps}). A partir de uma ordenação topológica desse grafo, o sistema determina uma sequência de avaliação válida, além de identificar dependências circulares que possam impedir a compilação.

, conforme definido na tabela de convenções de símbolos matemáticos (\autoref{@va trabahlhar vagabundo@}).
,
Essa ordenação permite o uso de simbolos antes da sua equação ser declarada, desde que estejam devidamente definidas em alguma das equações. Adicionalmente, a resolução de símbolos lida com escopos, parâmetros de funções e símbolos embutidos, que são os definidos na tabela de convenções de símbolos matemáticos (\autoref{@va trabahlhar vagabundo@}).



uma lista com
uma lista

A resolução de simbolos mantém uma lista com a ordem correta de avaliação das declaraçãos, recurso particularmente importante na geração de código GLSL, onde referências a variáveis antes de suas declarações não são permitidas.


Nessa resolução, é considerado o escopo do simbolo apropriadamente e é nessa etapa que detectamos se a função $f$, a BRDF por convenção, existe no escopo global. Para implementar essas funcionalidades, o pacote \texttt{checker} é dividido em múltiplas passadas na AST, na seguinte ordem:

a
// Make this distinct?




\end{lstlisting}







cod-grafo-simbol-deps
Symbol_Graph
cod-symbol-graph
Estruturas podem ser vistar no \autoref{cod-symbol-graph}, é um simples grafo associa um simbolos à outros simbolos que depende.



.
Para implementar essas funcionalidades, o \texttt{checker} realiza múltiplas passadas na AST, duas são para resolução de simbolos e a útilma é para validação das equações, na seguinte ordem:

\begin{enumerate}
    \item \textbf{Coleta de Símbolos}:
    \begin{itemize}
        \item Coletar todos identificadores nas declarações
        \item Registrar símbolos nos escopos apropriados
        \item Inicializar estruturas de rastreamento de dependências.     \end{itemize}

    \item \textbf{Análise de Dependências}:
    \begin{itemize}
        \item Construir o grafo de dependências. Estruturas podem ser vistar no \autoref{cod-symbol-graph}, é um simples grafo associa um simbolos à outros simbolos que depende.
        \item Validar referências de símbolos; inclue detectar uso de simbolos que nunca foram definidas.
        \item Estabelecer a ordem de avaliação por meio de ordenação topológica
    \end{itemize}

    \item \textbf{Validação Final}:
    \begin{itemize}
        \item Inferencia e verificação de tipos
        \item Verificação do ponto de entrada
        \item Validação de definição de funções com uso escopo, visto na \sec
    \end{itemize}
\end{enumerate}

Para implementar essas funcionalidades, o \texttt{checker} realiza múltiplas passadas na AST, duas são para resolução de simbolos e a útilma é para validação das equações, na seguinte ordem:

    \item \textbf{Análise de Dependências}:
    \begin{itemize}
        \item Construir o grafo de dependências. Estruturas podem ser vistar no \autoref{cod-symbol-graph}, é um simples grafo associa um simbolos à outros simbolos que depende.
        \item Validar referências de símbolos; inclue detectar uso de simbolos que nunca foram definidas.
        \item Estabelecer a ordem de avaliação por meio de ordenação topológica
    \end{itemize}

    \item \textbf{Validação Final}:
    \begin{itemize}
        \item Inferencia e verificação de tipos
        \item Verificação do ponto de entrada
        \item Validação de definição de funções com uso escopo, visto na \sec
    \end{itemize}
\end{enumerate}

            
    
    \end{itemize}

O processo de validação de equações assegura que todos os identificadores e expressões sigam as regras semânticas de linguagem \texttt{EquationLang}. A análise ocorre após a etapa de coleta e ordenação descrita em \autoref{colega e ordenação de equações}. A validação inclui os seguintes aspectos principais:

%%%%

Declarações de equações são validadas após a etapa de coleta e ordenação descrita em \autoref{colega e ordenação de equações}, portanto assume-se que o lado esquerdo das equações deve ser um identificador válido ou a definição de uma função. Esse processo também verifica redefinições de símbolos, prevenindo múltiplas declarações do mesmo identificador no mesmo escopo.

Todas as violações semânticas, como incompatibilidades de tipos ou uso de valores escalares onde vetores são esperados, são reportadas ao usuário, juntamente com informações detalhadas sobre o contexto e o local do erro.

A função \verb"check_expr" realiza uma traversia similiar a interencia de tipos e é ser responsável por chamar \texttt{infer\_type}. Nessa função, a análise de expressões que \texttt{infer\_type} deixou de fazer são feitas para todas os tipos de expressões garantindo que todas as expressões sigam as semantica matematica estabelecidas pela linguagem. O recorte dessa traversia pode ser visto no \autoref{eq-function-check-expr}.

Equações que representam definições de função são delegadas à função \texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.

\texttt{check\_expr}. Caso o tipo não esteja inferido, a inferência é realizada.

  Os símbolos representam variáveis ou funções na linguagem. Caso o símbolo já exista, ele é atualizado; caso contrário, um novo símbolo é criado.

\begin{itemize}
    \item **Expressões de chamada de função (\verb`Expr_Function_Call`)**: Verifica se estamos fazendo a chamada com um identificador, pode ocoprrer o caso de tentar fazer a chamada com um número $123(x,y)$, e isso está incorreto.
    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**: Verifica operadores (\verb`-`, \verb`+`) e funções como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compatíveis, gerando erro caso contrário.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**: Garante que vetores tenham exatamente 3 dimensões, reportando erros para formatos inválidos.
\end{itemize}


- Move Pratt parsing explanation of precende to somewhere else








%%%%
Além disso, a resolução 
.
,
É nesta etapa que verificamos se a função $f$, a BRDF por convenção, existe no escopo global.

É nesta etapa que verificamos se a função $f$, a BRDF por convenção, existe no escopo global.




É nesta etapa que verificamos se a função $f$, a BRDF por convenção, existe no escopo global.



É nesta etapa que verificamos se a função $f$, a BRDF por convenção, existe no escopo global.


É nesta etapa que verificamos se a função $f$, a BRDF por convenção, existe no escopo global.

a
 
n
section-escope-table
section-escope-table
,
Caso o identificador não seja encontrado, a função reporta um erro.
"\


subsubsection-eq-func-defn
Erros encontrados são reportados com mensagens detalhadas, como descrito na \autoref{subsection-erros}.


O processo de validação de equações assegura que todos os identificadores e expressões sigam as regras semânticas de linguagem \texttt{EquationLang}. A análise ocorre após a etapa de coleta e ordenação descrita em \autoref{colega e ordenação de equações}. A validação inclui os seguintes aspectos principais:

subsection
\label{subsection-sym-resolution}
\label{subsection-sym-resolution}
redefinições
Erros encontrados são reportados com mensagens detalhadas, como descrito na \autoref{subsection-erros}.




\texttt{check\_expr}. Caso o tipo não esteja inferido, a inferência é realizada.

\begin{itemize}
    \item **Expressões de chamada de função (\verb`Expr_Function_Call`)**: Verifica se estamos fazendo a chamada com um identificador, pode ocoprrer o caso de tentar fazer a chamada com um número $123(x,y)$, e isso está incorreto.
    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**: Verifica operadores (\verb`-`, \verb`+`) e funções como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compatíveis, gerando erro caso contrário.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**: Garante que vetores tenham exatamente 3 dimensões, reportando erros para formatos inválidos.

\begin{itemize}
    \item **Expressões de chamada de função (\verb`Expr_Function_Call`)**: Verifica se estamos fazendo a chamada com um identificador, pode ocoprrer o caso de tentar fazer a chamada com um número $123(x,y)$, e isso está incorreto.
    \item **Expressões com Prefixo (\verb`Expr_Prefix`)**: Verifica operadores (\verb`-`, \verb`+`) e funções como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compatíveis, gerando erro caso contrário.
    \item **Literais de Vetor (\verb`Expr_Vector_Literal`)**: Garante que vetores tenham exatamente 3 dimensões, reportando erros para formatos inválidos.
\end{itemize}


g
f
a função.
Equações que representam definições de função são delegadas à função \texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.

\texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.
  Os símbolos representam variáveis ou funções na linguagem. Caso o símbolo já exista, ele é atualizado; caso contrário, um novo símbolo é criado.

\texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.

\texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.

\subsection{Validação de Funções}
A validação semântica de definições e chamadas de funções segue um processo semelhante ao da análise de expressões, mas com o uso da pilha de escopos. Nas definições de funções as variáveis no corpo da função (lado direito da equação) devem ser validadas para garantir que todos os símbolos do corpo estejam definidos no escopo da função. Ja na chamadas de funlções os argumentos usados são comparados aos parametros para sua validação.

Validação de uso de parâmetros \texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.


\subsubsection{Definição de Funções} \label{subsubsection-eq-func-defn}

O procedimento \verb`check_function_definition` implementa um sistema de validação abrangente para definições de função, garantindo segurança de tipos e consistência de parâmetros. A validação do corpo da função representa a etapa final do processo de checagem e envolve:
A função \texttt{check\_function\_definition} é responsável pela validação completa de definições de funções. Ela assegura a consistência dos parâmetros e a segurança de tipos.

\begin{enumerate}
    \item Validar todas as expressões no corpo da função.
    \item Inferir o tipo de retorno com base na expressão final.
    \item Construir o tipo completo da função, incluindo parâmetros e retorno.
    \item Garantir que todos os identificadores utilizados estejam consistentes com seus tipos declarados.

    \item Cria um novo escopo para os parâmetros da função
    \item Inferência de tipos para cada parâmetro
    \item Mantém informações sobre o tipo dos parâmetros
    \item Tratamento de tipo padrão (número se não for vetor)

    \item Validação de expressões
    \item Inferência do tipo de retorno
    \item Construção do tipo de função
    \item Gerenciamento de escopo
    \item Cria um novo escopo para os parâmetros da função.
    \item Realiza inferência de tipos para cada parâmetro.
    \item Lida com tipos padrão (e.g., vetor para prefixos \textbackslash{}vec).
\end{enumerate}

Nas definições de funções as variáveis no corpo da função (lado direito da equação) devem ser validadas para garantir que todos os símbolos do corpo estejam definidos no escopo da função. Ja na chamadas de funlções os argumentos usados são comparados aos parametros para sua validação.

Validação de uso de parâmetros \texttt{check\_function\_definition}, que valida os parâmetros e o corpo da função.



O processo começa com o processamento dos parâmetros e o gerenciamento do escopo. Quando uma função é definida, o sistema cria um novo escopo para armazenar informações dos parâmetros e da própria função em forma de simbolos à serem adicionados ao escopo atrelado a essa definição \autoref.

Esse escopo com simbolos são essencial para validar tanto as chamadas de função quanto as expressões no corpo da função. Cada função tem seu próprio escopo, cujo escopo pai é o global, prevenindo conflitos de identificadores.

Controle de visibilidade de símbolos é feito, Na definição de escopo, se o $x$ existe nos parâmetros, primeiro é usado o $x$ do parâmetro antes de tentar acessar um $x$ global. Isso é chamado de \textit{shadowing} ou sombreamento do símbolo, como no caso da equação \autoref{eq-shadowing}, o resultado de $f$ é 3 e não 2.

\begin{align} \label{eq-shadowing}
    &x = 2 \\
    &g(x) = x \\
    &f = g(3)
\end{align}


%%%
Tratamento de tipo vetor (reconhecimento do prefixo \verb|\vec|)
Durante a validação dos parâmetros, cada identificador passa pela inferência de tipo. Parâmetros explicitamente marcados com o prefixo \verb"\vec" recebem o tipo padrão $\mathbb{R}^3$ (vetor tridimensional). Caso contrário, o tipo padrão atribuído é o de número real ($\mathbb{R}$).

A validação de identificadores do corpo da função (lado direito da equação) usa o escopo da função para verificar se o identificador está definido, se seu tipo é compatível com o encontrado no simbolo presente neste escopo; e verifica ele não viola as regras semânticas. Por exemplo, se o parâmetro $\vec{x}$ é declarado como vetor, todo uso de x no corpo da função deve respeitar as operações vetoriais, ou um erro será reportado.


A função \texttt{check_function_definition} desempenha o papel central nesse processo, validando tanto os parâmetros quanto o corpo da função.



A validação do corpo da função representa a etapa final do processo de checagem e envolve:


O procedimento \verb`check_function_definition` implementa um sistema de validação abrangente para definições de função, garantindo segurança de tipos e consistência de parâmetros. A validação do corpo da função representa a etapa final do processo de checagem e envolve:

O procedimento \verb"check_function_definition" implementa a validação para definições de função, garantindo segurança de tipos e consistência de parâmetros. tipos.

tipos.
\end{enumerate}





    \item Mantém informações sobre o tipo dos parâmetros

    \item Tratamento de tipo padrão (número se não for vetor)

    \item Inferência do tipo de retorno

    \item Inferência do tipo de retorno
    \item Construção do tipo de função

    \item Validação de expressões

    \item Lida com tipos padrão (e.g., vetor para prefixos \textbackslash{}vec).

\textbackslash{}
    \item Gerenciamento de escopo
    \item Cria um novo escopo para os parâmetros da função.



    \item Realiza inferência de tipos para cada parâmetro.

    \item Lida com tipos padrão (e.g., vetor para prefixos \textbackslash{}vec).

]
\label{cod-func-defn}
label
expressões no corpo da função. Cada função tem seu próprio escopo, cujo escopo pai é o global, prevenindo conflitos de identificadores.

Quando uma função é definida, o sistema cria um novo escopo para armazenar informações dos parâmetros e da própria função em forma de simbolos à serem adicionados ao escopo atrelado a essa definição \autoref.



Controle de visibilidade de símbolos é feito, Na definição de escopo, se o $x$ existe nos parâmetros, primeiro é usado o $x$ do parâmetro antes de tentar acessar um $x$ global. Isso é chamado de \textit{shadowing} ou sombreamento do símbolo, como no caso da equação \autoref{eq-shadowing}, o resultado de $f$ é 3 e não 2.

Tratamento de tipo vetor (reconhecimento do prefixo \verb|\vec|)
Durante a validação dos parâmetros, cada identificador passa pela inferência de tipo. Parâmetros explicitamente marcados com o prefixo \verb"\vec" recebem o tipo padrão $\mathbb{R}^3$ (vetor tridimensional). Caso contrário, o tipo padrão atribuído é o de número real ($\mathbb{R}$).

A validação de identificadores do corpo da função (lado direito da equação) usa o escopo da função para verificar se o identificador está definido, se seu tipo é compatível com o encontrado no simbolo presente neste escopo; e verifica ele não viola as regras semânticas. Por exemplo, se o parâmetro $\vec{x}$ é declarado como vetor, todo uso de x no corpo da função deve respeitar as operações vetoriais, ou um erro será reportado.



\subsubsection{Chamada de Funções}
Chamadas de função passam por uma validação semelhante: os argumentos fornecidos têm seus tipos inferidos e são comparados com a assinatura da função chamada (\verb"Type_Function"). Por exemplo, no código da \autoref{cod-type-mismatch}, a função $g$ tem a assinatura $\mathbb{R} \times \mathbb{R} \to \mathbb{R}$. A expressão de chamada de função resultante tem o tipo do contradomínio da função chamada. Se, por exemplo, $f$ espera dois números reais como argumentos e um vetor é passado no lugar de um deles, um erro será gerado. A \autoref{fig-type-mismatch} ilustra tal erro, indicando exatamente o argumento incompatível.

Tratamento de tipo vetor (reconhecimento do prefixo \verb|\vec|)
Durante a validação dos parâmetros, cada identificador passa pela inferência de tipo. Parâmetros explicitamente marcados com o prefixo \verb"\vec" recebem o tipo padrão $\mathbb{R}^3$ (vetor tridimensional). Caso contrário, o tipo padrão atribuído é o de número real ($\mathbb{R}$).

A validação de identificadores do corpo da função (lado direito da equação) usa o escopo da função para verificar se o identificador está definido, se seu tipo é compatível com o encontrado no simbolo presente neste escopo; e verifica ele não viola as regras semânticas. Por exemplo, se o parâmetro $\vec{x}$ é declarado como vetor, todo uso de x no corpo da função deve respeitar as operações vetoriais, ou um erro será reportado.




uma validação semelhante
Chamadas de função passam por uma validação semelhante: os argumentos fornecidos têm seus tipos inferidos e são comparados com a assinatura da função chamada (\verb"Type_Function"). Por exemplo, no código da \autoref{cod-type-mismatch}, a função $g$ tem a assinatura $\mathbb{R} \times \mathbb{R} \to \mathbb{R}$. A expressão de chamada de função resultante tem o tipo do contradomínio da função chamada. Se, por exemplo, $f$ espera dois números reais como argumentos e um vetor é passado no lugar de um deles, um erro será gerado. A \autoref{fig-type-mismatch} ilustra tal erro, indicando exatamente o argumento incompatível.

      - Confirma que o identificador refere-se a um símbolo do tipo função.

C
Nessa chamada, é confirmado que identificador do lado esquerdo  refere-se a um símbolo do tipo função.

\begin{itemize}
    \item **Chamadas de Função (\verb`Expr_Function_Call`)**:
        - Verifica se a expressão da esquerda é um identificador válido \verb"check_single_identifier".

      - Garante que o número e os tipos dos argumentos correspondem aos parâmetros esperados.

      Garante que o número e os tipos dos argumentos correspondem aos parâmetros esperados.

 
      - Para cada argumento, chama recursivamente \verb`check_expr`.


\end{itemize}


% \subsection{Validação de Definição e Declaração de Função na Análise Semântica}

\subsubsection{Fase 1: Processamento de Parâmetros}

\subsubsection{Fase 3: Validação do Corpo da Função}


\subsection{Tratamento de Declaração de Equação}
\begin{codigo}[htb]
    \caption{\small Tratamento de declaração de equação.}
    \label{cod-equation-declaration}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]
case ^Decl_Equation:
    check_decl(s)
\end{lstlisting}
\end{codigo}


\subsection*{Validação de Definições de Funções}



\section{Geração de Código (\texttt{emitter})} \label{section-emitter}

especificamente na fase de geração de código, onde as estruturas intermediárias são transformadas em código executável.
O pacote \texttt{emitter} é responsável por transformar a arvore já anotada com a porra toda e gerar código para ser carregado pela ferramenta BRDF da disney.
A AST está completamente anotada com tipos, informações especials, e acessamos esses dados necessarios através dos Simbolo presentes no escopo global, lembre que nós podem ser encontrados na tabela de simbolo, e nesses nós tempso informações dos tipos para geração de funções com exemplo. O Escopo global é a entrada para esse pacote; com ele, é possivel gerar o programa completamente, pois todos os escopo filhos podem ser acessados através deste.
Como chegamos nessa etapa, assume-se corretude do programa, então podemos passar por todos os nós recursivamentes gerar código para cada tipo de nó existente na nossa AST, isso inclue principalmente, definições de funcões e expressões. Uma etapa importante é gerar o LHS de uma equação, que é evolve um pelo menos um identificador e subexpressões e (ex: $f_n+1 = \dots$, no caso de definição de funções, possivelmente parametros. Outro caso é o LHS ser um vetor ou número, nesse caso é apenas  um simbolo no lado esquerdo. 
Esse processo será relatado em \autoref{sec-LHS} Já o lado direito RHS, é sempre uma expressão, isso envolver fazer uma travessia da arvore e usar a tabela de simbolos e o tipo inferido para gerar a expresão equivalente em GLSL, esse processo é discutido em \autoref{sec-RHS}. Um detalhe importante é que toda equação prefica ter uma variavél de nome unico em glsl, isso é elaborado em \autoref{sec-unicidade}.


\subsection{LHS}
Para emissão de código começamos do lado esquerdo da equação possui. Nela existem 3 partes importantes para geração do código. O tipo é aprimeira parte a se resolver, o mapeamento é se temos um número real, então o tipo em GLSL é mapeado para ponto flutuante, \verb`float`. Se for vetor ($\mathbb{R}^3$), será mapeado para \verb`vec3`, que representa um vetor de 3 dimensões em GLSL. No caso de uma definição de função, precisa usar o \verb`Symbol` para buscar os tipos de parametros e retorno que está, para construir uma função em GLSL. Segundo, temos o identificador presente no simbolo que deve ser mapeado, existe algumas regras que devemos seguir, o processo é delineado em \autoref{sec-unicidade}. Por úlimo, temos que gerar o lado esquerdo da função, assim como foi na inferencia de tipos, temos um traversia na AST para fazer uma mapeamento dos nós de expressões para o equilavente em GLSL, como somas, chamadas de cosseno, seno, etc. A emissão de código à partir de um nó expressão é explicada na sessão \autoref{}


\section{Geração de Código (\texttt{emitter})} \label{section-emitter}

especificamente na fase de geração de código, onde as estruturas intermediárias são transformadas em código executável.
O pacote \texttt{emitter} é responsável por transformar a arvore já anotada com a porra toda e gerar código para ser carregado pela ferramenta BRDF da disney.
A AST está completamente anotada com tipos, informações especials, e acessamos esses dados necessarios através dos Simbolo presentes no escopo global, lembre que nós podem ser encontrados na tabela de simbolo, e nesses nós tempso informações dos tipos para geração de funções com exemplo. O Escopo global é a entrada para esse pacote; com ele, é possivel gerar o programa completamente, pois todos os escopo filhos podem ser acessados através deste.
Como chegamos nessa etapa, assume-se corretude do programa, então podemos passar por todos os nós recursivamentes gerar código para cada tipo de nó existente na nossa AST, isso inclue principalmente, definições de funcões e expressões. Uma etapa importante é gerar o LHS de uma equação, que é evolve um pelo menos um identificador e subexpressões e (ex: $f_n+1 = \dots$, no caso de definição de funções, possivelmente parametros. Outro caso é o LHS ser um vetor ou número, nesse caso é apenas  um simbolo no lado esquerdo. 
Esse processo será relatado em \autoref{sec-LHS} Já o lado direito RHS, é sempre uma expressão, isso envolver fazer uma travessia da arvore e usar a tabela de simbolos e o tipo inferido para gerar a expresão equivalente em GLSL, esse processo é discutido em \autoref{sec-RHS}. Um detalhe importante é que toda equação prefica ter uma variavél de nome unico em glsl, isso é elaborado em \autoref{sec-unicidade}.


\subsection{LHS}
Para emissão de código começamos do lado esquerdo da equação possui. Nela existem 3 partes importantes para geração do código. O tipo é aprimeira parte a se resolver, o mapeamento é se temos um número real, então o tipo em GLSL é mapeado para ponto flutuante, \verb`float`. Se for vetor ($\mathbb{R}^3$), será mapeado para \verb`vec3`, que representa um vetor de 3 dimensões em GLSL. No caso de uma definição de função, precisa usar o \verb`Symbol` para buscar os tipos de parametros e retorno que está, para construir uma função em GLSL. Segundo, temos o identificador presente no simbolo que deve ser mapeado, existe algumas regras que devemos seguir, o processo é delineado em \autoref{sec-unicidade}. Por úlimo, temos que gerar o lado esquerdo da função, assim como foi na inferencia de tipos, temos um traversia na AST para fazer uma mapeamento dos nós de expressões para o equilavente em GLSL, como somas, chamadas de cosseno, seno, etc. A emissão de código à partir de um nó expressão é explicada na sessão \autoref{}

e
para gerar o programa completo
,
n
e ainda nós da AST

especificamente na fase de geração de código, onde as estruturas intermediárias são transformadas em código executável.
O pacote \texttt{emitter} é responsável por transformar a arvore já anotada com a porra toda e gerar código para ser carregado pela ferramenta BRDF da disney.
A AST está completamente anotada com tipos, informações especials, e acessamos esses dados necessarios através dos Simbolo presentes no escopo global, lembre que nós podem ser encontrados na tabela de simbolo, e nesses nós tempso informações dos tipos para geração de funções com exemplo. O Escopo global é a entrada para esse pacote; com ele, é possivel gerar o programa completamente, pois todos os escopo filhos podem ser acessados através deste.
Como chegamos nessa etapa, assume-se corretude do programa, então podemos passar por todos os nós recursivamentes gerar código para cada tipo de nó existente na nossa AST, isso inclue principalmente, definições de funcões e expressões. Uma etapa importante é gerar o LHS de uma equação, que é evolve um pelo menos um identificador e subexpressões e (ex: $f_n+1 = \dots$, no caso de definição de funções, possivelmente parametros. Outro caso é o LHS ser um vetor ou número, nesse caso é apenas  um simbolo no lado esquerdo. 

Esse processo será relatado em \autoref{sec-LHS} Já o lado direito RHS, é sempre uma expressão, isso envolver fazer uma travessia da arvore e usar a tabela de simbolos e o tipo inferido para gerar a expresão equivalente em GLSL, esse processo é discutido em \autoref{sec-RHS}. Um detalhe importante é que toda equação prefica ter uma variavél de nome unico em glsl, isso é elaborado em \autoref{sec-unicidade}.

\section{Geração de Código (\texttt{emitter})} \label{section-emitter}

\section{Geração de Código (\texttt{emitter})} \label{section-emitter}


%%%%%%%



\subsection{LHS}
Para emissão de código começamos do lado esquerdo da equação possui. Nela existem 3 partes importantes para geração do código. O tipo é aprimeira parte a se resolver, o mapeamento é se temos um número real, então o tipo em GLSL é mapeado para ponto flutuante, \verb`float`. Se for vetor ($\mathbb{R}^3$), será mapeado para \verb`vec3`, que representa um vetor de 3 dimensões em GLSL. No caso de uma definição de função, precisa usar o \verb`Symbol` para buscar os tipos de parametros e retorno que está, para construir uma função em GLSL. Segundo, temos o identificador presente no simbolo que deve ser mapeado, existe algumas regras que devemos seguir, o processo é delineado em \autoref{sec-unicidade}. Por úlimo, temos que gerar o lado esquerdo da função, assim como foi na inferencia de tipos, temos um traversia na AST para fazer uma mapeamento dos nós de expressões para o equilavente em GLSL, como somas, chamadas de cosseno, seno, etc. A emissão de código à partir de um nó expressão é explicada na sessão \autoref{}

\subsection{Unicidade de variaveis}

Para garantir o comentado em @@checker-chapter. Deve-se também, garantir que as variaveis emitidas são únicas, glsl não permite os caracteres \verb'{,}' em seus identificadores, isso singica que uma euqação definida em latex \verb`f_{1} = 2` não pode ser transformado para um identificador \verb`f_{1} = 2` em glsl, para resolver isso cada simbolo não permitido em glsl é substituido por unmderline \verb'_' gerlando o resultado parical \verb`f__1_`. Isso ainda gera colisão pois outros @@ simbolos poder gerar a mesma indeficiador em glsl, para garantir cada identificador ser realmennte unico um mapeamento é feito entre a string do identificar na equação latex para um inteiro único de 64 bits adicionamos a string "var" + o esse inteiro denomiado ID ao resultado parcial, garantido que todo simbolo de euqação recebe um unico symbolo em glsl. Em contrapartido o compilador permite um máximo de $2^64 - 1$ equações, oq é um número mt bom é possivel permitir mais com big ints, mas para os propositos de cirar BRDFs é suficiente. Uma outra etapa é remover possiveis sequencia de 2 ou mais \verb"_" pois OpenGL reserva nomes contendo \verb"__", ai sim temos a variavel final.

A linguagem GLSL impõe restrições sintáticas na definição de identificadores. Caracteres especiais como '{', '}' são proibidos, o que impossibilita uma transformação direta de notações matemáticas para identificadores de programação. Considere, por exemplo, uma equação em notação LaTeX:


\[ f_{1} = 2 \]

A transformação direta resultaria em um identificador inválido em GLSL.
Para garantir a unicidade e a compatibilidade dos identificadores durante este processo de geração de código foi feitos três tarefas principais:

Segue a revisão para maior coesão e clareza, mantendo a estrutura e formato que você utilizou:



\subsection{LHS}

emissão
Mapeamento de Tipos:
O tipo associado ao identificador é a primeira informação a ser resolvida. Caso seja um número real, ele é mapeado para \verbfloat em GLSL. Para vetores ($\mathbb{R}^3$), o mapeamento é feito para \verbvec3, que representa vetores tridimensionais. Em definições de funções, utiliza-se o \verbSymbol para acessar os tipos de parâmetros e do retorno, construindo assim a assinatura da função no formato GLSL.

\item Identificador (LHS): O identificador associado ao símbolo é traduzido conforme regras específicas que garantem unicidade e conformidade com as restrições do GLSL. Este processo é detalhado em \autoref{sec-unicidade}.

\item Expressões (RHS): No caso de definições de funções, o LHS pode incluir parâmetros e subexpressões. Para isso, realiza-se uma travessia da AST, mapeando nós de expressões (como somas e chamadas de funções trigonométricas) para seu equivalente em GLSL.

Para emissão de código começamos do lado esquerdo da equação possui. Nela existem 3 partes importantes para geração do código. O tipo é aprimeira parte a se resolver, o mapeamento é se temos um número real, então o tipo em GLSL é mapeado para ponto flutuante, \verb`float`. Se for vetor ($\mathbb{R}^3$), será mapeado para \verb`vec3`, que representa um vetor de 3 dimensões em GLSL. No caso de uma definição de função, precisa usar o \verb`Symbol` para buscar os tipos de parametros e retorno que está, para construir uma função em GLSL. Segundo, temos o identificador presente no simbolo que deve ser mapeado, existe algumas regras que devemos seguir, o processo é delineado em \autoref{sec-unicidade}. Por úlimo, temos que gerar o lado esquerdo da função, assim como foi na inferencia de tipos, temos um traversia na AST para fazer uma mapeamento dos nós de expressões para o equilavente em GLSL, como somas, chamadas de cosseno, seno, etc. A emissão de código à partir de um nó expressão é explicada na sessão \autoref{}



%%%

\subsection{Unicidade de variaveis}

1. **Restrição de Caracteres**:  
   O GLSL não permite caracteres especiais, como '{' e '}', em seus identificadores. Por exemplo, uma equação em notação LaTeX:  

   \[
   f_{1} = 2
   \]  

   não pode ser diretamente transformada no identificador \verb`f_{1}`. Para resolver isso, todos os caracteres inválidos são substituídos por sublinhados (\verb`_`), resultando em identificadores como \verb`f__1_`.  

2. **Prevenção de Colisões**:  
   Mesmo após a substituição de caracteres, podem ocorrer colisões. Para resolver isso, mapeia-se cada identificador original para um inteiro único de 64 bits (ID). Esse ID é então concatenado ao identificador com o prefixo \verb`var`, resultando em algo como \verb`f__1_var12345`.  

3. **Remoção de Sequências Reservadas**:  
   O GLSL reserva identificadores que contêm duas ou mais ocorrências consecutivas de \verb`_`. Após a geração inicial, identificadores que contenham essas sequências são corrigidos para atender às restrições do GLSL.  

Essas etapas garantem que cada variável no código GLSL seja única e válida. Apesar da limitação de $2^{64} - 1$ identificadores distintos imposta pelo uso de inteiros de 64 bits, esse valor é mais do que suficiente para o propósito de criação de BRDFs. Caso necessário, a utilização de inteiros maiores poderia ampliar esse limite, embora não seja uma prioridade neste contexto.  

---  

Se precisar de ajustes adicionais, posso refinar ainda mais!

 **Restrição de Caracteres**:  
   O GLSL não permite caracteres especiais, como '{' e '}', em seus identificadores. Por exemplo, uma equação em notação LaTeX:  

   \[
   f_{1} = 2
   \]  

   não pode ser diretamente transformada no identificador \verb`f_{1}`. Para resolver isso, todos os caracteres inválidos são substituídos por sublinhados (\verb`_`), resultando em identificadores como \verb`f__1_`.  

        p

\item **Prevenção de Colisões**:  
   Mesmo após a substituição de caracteres, podem ocorrer colisões. Para resolver isso, mapeia-se cada identificador original para um inteiro único de 64 bits (ID). Esse ID é então concatenado ao identificador com o prefixo \verb`var`, resultando em algo como \verb`f__1_var12345`.  

\item **Remoção de Sequências Reservadas**:  
   O GLSL reserva identificadores que contêm duas ou mais ocorrências consecutivas de \verb`_`. Após a geração inicial, identificadores que contenham essas sequências são corrigidos para atender às restrições do GLSL.  

  

Se precisar de ajustes adicionais, posso refinar ainda mais!

  
  
include
Segue a revisão para maior coesão e clareza, mantendo a estrutura e formato que você utilizou:



A geração de código começa pelo lado esquerdo da equação (LHS). Existem três aspectos principais nesse processo:

\subsection{LHS}

Mapeamento de Tipos:
O tipo associado ao identificador é a primeira informação a ser resolvida. Caso seja um número real, ele é mapeado para \verbfloat em GLSL. Para vetores ($\mathbb{R}^3$), o mapeamento é feito para \verbvec3, que representa vetores tridimensionais. Em definições de funções, utiliza-se o \verbSymbol para acessar os tipos de parâmetros e do retorno, construindo assim a assinatura da função no formato GLSL.

Identificador:
O identificador associado ao símbolo é traduzido conforme regras específicas que garantem unicidade e conformidade com as restrições do GLSL. Este processo é detalhado em \autoref{sec-unicidade}.

Expressões no LHS:
No caso de definições de funções, o LHS pode incluir parâmetros e subexpressões. Para isso, realiza-se uma travessia da AST, mapeando nós de expressões (como somas e chamadas de funções trigonométricas) para seu equivalente em GLSL.


\subsubsection{1. **Substituição de Caracteres Especiais**}
   
   Primeiro todos construimos uma cadeira de caracteres baseado no nó indentificador e todos as subexpressões presente, já que é permitido ver subexpressões como vimos em.Mas Em seguida, todos os caracteres não permitidos em GLSL são substituídos pelo caractere sublinhado (\verb'_'). No exemplo anterior, a transformação inicial seria:

   \[ f\_\_1\_ \]

2. **Prevenção de Colisões de Identificadores**
   
   Para garantir a unicidade absoluta, implementa-se um mapeamento que associa cada identificador original a um inteiro único de 64 bits. A estratégia consiste em:
   
   - Prefixar a string "var"
   - Concatenar um identificador numérico exclusivo
   
   Exemplo, seja $\text{ID}_i$ o identificador único para o símbolo $i$:

   \[ \text{ID}_i = \text{hash}(\text{"var"} + i) \]

3. **Normalização Final**
   
   Remove-se sequências consecutivas de sublinhados, respeitando as convenções do OpenGL que \emph{reservam} identificadores com sequências duplas de sublinhados para uso interno.

O método proposto oferece:

- Espaço de identificadores: $2^{64} - 1$ equações
- Possibilidade de extensão utilizando inteiros de precisão arbitrária

### Considerações Teóricas

Teorema: O algoritmo garante injetividade na transformação de identificadores matemáticos para identificadores GLSL.

\[ \forall x, y \in \mathbb{E}, x \neq y \implies \text{GLSL\_Identifier}(x) \neq \text{GLSL\_Identifier}(y) \]

\subsection{Geração de Expressões}


Esta tarefa é fundamental no processo de compilação e ocupa a maior parte deste pacote \texttt{emitter}.
A emissão de expressões é implementada na função \verb`emit_expr`. Essa função aceita uma nó expressão qualquer e um referencia à uma lista de caracteres (tipo `StringBuilder` disponibilizado pela biblioteca padrão de Odin) onde ira escrever um código GLSL correto. Para isso é realizado a travessia recursiva da (AST), usando \texttt{walker} convertendo todas as expressões binárias, prefixas, chamada de funções,  e operações vetoriais em código GLSL válido. A a função checa o tipo do da expressão em um \verb`switch` discriminado para processar diferentes tipos de nós da AST, um recorte dessa função pode ser vista no \autoref{cod-emit-expr}. As principais categorias de expressões tratadas são:

1. Expressões prefixas (`Expr_Prefix`):
   - Implementa a emissão de funções trigonométricas (sin, cos, tan, asin, acos, atan)
   - Processa operadores unários como negação (-) e raiz quadrada (sqrt)
   - Realiza a conversão de vetores através da construção vec3()
   - Mantém a precedência de operadores através de parênteses apropriados

2. Expressões binárias (`Expr_Infix`):
   - Gerencia operações aritméticas básicas (+, -, *, /)
   - Implementa tratamento especial para multiplicação vetorial, diferenciando:
     * Produto interno entre vetores
     * Multiplicação escalar-vetor
     * Multiplicação escalar-escalar
   - Processa operações vetoriais, a unica que damos suporte é produto vetorial (\verb`cross`).
   - Exponenciação (\veb'x ^ y') é implementada fazendo chamanda a função \verb`pow()` que embutida em GLSL.

3. Expressões Literais e Identificadores:
   - Processa literais numéricos com formatação apropriada para GLSL
   - Gerencia a conversão de identificadores mantendo a consistência com o escopo
   - Implementa a construção de literais vetoriais através do construtor vec3

4. Expressões Agrupadas e Chamadas de Função:
   - Preserva a precedência de operadores através de parênteses
   - Implementa a emissão de chamadas de função com suporte a múltiplos argumentos
   - Mantém a separação adequada de argumentos através de vírgulas

A função utiliza um StringBuilder para construção eficiente, evitando concatenações excessivas durante a emissão do código. O sistema implementa verificações de tipo em tempo de compilação para garantir a corretude das operações vetoriais e escalares, essencial para a geração de código GLSL válido.

Esta implementação consegue traduzir as expressões matemáticas como na \autoref{eq-emit-expr-example} e emitir o \autoref{cod-emit-expr-example} na linguagens de shading.

\begin{subequations}
\begin{equation}
    \rho_{d} = \vec{0,1,1}
\end{equation}

\begin{equation}
    \rho_{s} = \vec{1,0,1}
\end{equation}

\begin{equation}
    n = +2^8
\end{equation}

\begin{equation}
f = \frac{\rho_{d}}{\pi} + \rho_{s} * \frac{n+2}{2*\pi} *
\cos{\theta_{h}}^{n}
\end{equation}
\end{subequations}

\begin{codigo}[htb]
   \caption{\small Exemplo de código de expressão gerado. }
   \label{cod-emit-expr-example}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
  var_12_rho_d = vec3(0.0, 1.0, 1.0);
  var_13_n     = pow(2.0, 8.0);
  var_14_rho_s = vec3(1.0, 0.0, 1.0);
  var_15_f     = ((var_12_rho_d / var_1_pi) +
              ((var_14_rho_s * ((var_13_n + 2.0) / (2.0 * var_1_pi))) *
               pow(cos(var_10_theta_h), var_13_n)));
\end{lstlisting}
\end{codigo}

\begin{codigo}[htb]
   \caption{\small Emitir expressão. }
   \label{cod-emit-expr}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
    case ^Expr_Prefix:
        #partial switch e.op.kind {
        case .ArcSin:
            sbprint(sb, "asin(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        //... Outros casos omissos

        case .Tan:
            sbprint(sb, "tan(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
        case .Exp:
            sbprint(sb, "exp(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
        case .Vec:
            ty_vec, ok := e.ty_inferred.derived.(^ast.Type_Vector)
            assert(ok && ty_vec.dimensions == 3)

            sbprint(sb, "vec3(")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return
    case ^Expr_Infix:
        op: string
        #partial switch e.op.kind {
        case .Plus:  op = "+"
        case .Minus: op = "-"
        case .Mul:
            // Check if both operands are vectors
            if is_vector(e.left.ty_inferred) && is_vector(e.right.ty_inferred) {
                sbprint(sb, "dot(")
                emit_expr(sb, e.left)
                sbprint(sb, ",")
                emit_expr(sb, e.right)
                sbprint(sb, ")")
                return
            } else {
                op = "*"
            }
        case .Frac, .Div:  op = "/"
        // Especially handled because it's not infix in glsl
        case .Caret: op = ""
            sbprint(sb, "pow(")
            emit_expr(sb, e.left)
            sbprint(sb, ",")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        //... Outros casos omissos
        case .Cross: op = ""
            sbprint(sb, "cross(")
            emit_expr(sb, e.left)
            sbprint(sb, ",")
            emit_expr(sb, e.right)
            sbprint(sb, ")")
            return

        sbprint(sb, '(')
        emit_expr(sb, e.left)
        sbprint(sb, op)
        emit_expr(sb, e.right)
        sbprint(sb, ')')


   //... 

\end{lstlisting}
\end{codigo}
---
\subsection{Começo da Emissão}%
\label{sub:start-emitting}

A função \verb`emit` representa o ponto de entrada do processo de emissão de código, implementando a transformação final AST em um shader GLSL analítico. Esta função opera em três fases distintas e cruciais:

1. Fase de Inicialização e Estruturação:
   - Estabelece o formato canônico do shader através da emissão de cabeçalhos específicos
   - Implementa uma seção de parâmetros que permite a parametrização do shader
   - Delimita claramente as seções do código através de marcadores (::begin shader, ::end shader), são necessário para carregar o shading na ferramenta da Disney
   - Emite as declarações de funções embutidas (comumente chamda de \verb`built-in`) necessárias para o funcionamento do shader

2. Fase de Processamento de Símbolos:
   - Itera sobre uma tabela de símbolos ordenada (Scope)
   - Processa três categorias principais de símbolos:
     * Variáveis numéricas escalares (Type_Basic)
     * Definições de funções (Type_Function)
     * Variáveis vetoriais (Type_Vector)
   - Mantém separação entre declarações e definições através de builders distintos
   - Implementa um sistema de buffer duplo onde as equações são acumuladas separadamente das declarações, isso é feito para simular escopo global em GLSL.

3. Fase de Emissão Final:
   - Concatena as declarações de funções em ordem apropriada
   - Emite a função de entrada (entry point) chamado \verb`BRDF`, entrada necessaria para ferramenta Disney.
   - Realiza a escrita do código gerado em arquivo através de operações de I/O seguras
   - Implementa verificação de erros na escrita do arquivo

A função mantém uma clara separação de responsabilidades através de seções comentadas (START OF BUILTINS DECLARATION, START OF USER DECLARED, etc), facilitando a manutenção e depuração do código gerado. O sistema implementa um mecanismo de diferenciação entre símbolos built-in e definidos pelo usuário, garantindo que não haja duplicação de declarações.

Uma característica notável é a utilização de um sistema de builders para construção eficiente de strings, minimizando a sobrecarga de memória durante a geração do código. A função também implementa um sistema de gestão de recursos através do uso de `defer` para limpeza adequada dos builders.

O processo de emissão é crucial para a geração de shaders GLSL válidos, pois mantém a ordem correta de declarações e definições, essencial para a compilação posterior pelo compilador GLSL. A função retorna um booleano indicando o sucesso da operação de escrita, permitindo tratamento adequado de erros em níveis superiores do compilador.

Estas funções implementam a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL, estabelecendo as variáveis fundamentais para computação de interações luz-material. As variaveis enbutidas são aquelas definidas na tabelas @@@, que são a angulo de incidencia, entre outros, a ferramenta disney oferece algumas dessas variaveis embutidas como parametro para função de entrada \verb`BRDF`, mas com convenções de nomes diferentes do estabelicdo neste trabalho. Essas são:
     * `normal_vector`: normal da superfície (N)
     * `omega_i`: direção da luz incidente (L)
     * `omega_o`: direção de visualização (V)
Todas as outras são calculadas por nós e gerado para todas as entradas automaticamente, pronto para uso em qualquer equação. 
Para calcular as embutidas omega_i, theta_d, phi_i, etc.., é foi desenvolvida algumas funções auxiliares de coordenadas esféricas: 

   - A função `phi(v)` calcula o ângulo azimutal (φ) a partir de um vetor:
     * Implementa a conversão de coordenadas cartesianas para esféricas
     * Utiliza atan(sqrt(y² + x²), z) para computar φ
   - A função `theta(v)` calcula o ângulo polar (θ):
     * Implementa atan(y, x) para computação do ângulo no plano xy

Assim podemos podemos fazer declaração das variáveis built-in  ( através da função `emit_builtin_globals_declaration`):
     * `half_vector`: vetor intermediário entre direção de luz e visualização (H)
     * `normal_vector`: normal da superfície (N)
     * `omega_i`: direção da luz incidente (L)
     * `omega_o`: direção de visualização (V)
   
   - Ângulos Esféricos:
     * `theta_h`: ângulo entre H e N
     * `theta_d`: ângulo entre H e L
     * `theta_i`: ângulo polar da luz incidente
     * `theta_o`: ângulo polar da visualização
     * `phi_i`: ângulo azimutal da luz incidente
     * `phi_o`: ângulo azimutal da visualização

E também constantes matemáticas:
     * `pi`: valor de π
     * `epsilon`: valor de precisão numérica


A função `emit_builtin_entry_function` encapsula toda esta lógica na função BRDF principal. 
- Recebe os vetores de entrada (L, V, N, X, Y), X e Y não usados.
- Inicializa todas as variáveis built-in, seu código gerado das variaveis embutidas pode ser visto em \autoref{cod-builtins-emitted}
- Incorpora as equações específicas do usuário
- Retorna o valor final da BRDF como um vec3

Este sistema fornece uma base suficiente para implementação de BRDFs complexas. 
\begin{codigo}[htb]
    \caption{\small Recorte da função BRDF one as variaveis built-ins são inicializadas }
    \label{cod-builtins-emitted}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
  //////////// START OF BUILTINS INITIALIZATION ////////////
  var_0_vec_h = normalize(L + V);
  var_3_vec_n = normalize(N);
  var_1_pi = 3.141592653589793;
  var_2_epsilon = 1.192092896e-07;
  var_4_vec_omega_i = L;
  var_5_theta_i = atan(var_4_vec_omega_i.y, var_4_vec_omega_i.x);
  var_6_phi_i = atan(sqrt(var_4_vec_omega_i.y * var_4_vec_omega_i.y +
                          var_4_vec_omega_i.x * var_4_vec_omega_i.x),
                     var_4_vec_omega_i.z);
  var_7_vec_omega_o = V;
  var_8_theta_o = atan(var_7_vec_omega_o.y, var_7_vec_omega_o.x);
  var_9_phi_o = atan(sqrt(var_7_vec_omega_o.y * var_7_vec_omega_o.y +
                          var_7_vec_omega_o.x * var_7_vec_omega_o.x),
                     var_7_vec_omega_o.z);
  var_10_theta_h = acos(dot(var_0_vec_h, N));
  var_11_theta_d = acos(dot(var_0_vec_h, var_4_vec_omega_i));
  //////////// END OF BUILTINS INITIALIZATION ////////////
\end{lstlisting}
\end{codigo}




---------

Nos resultados eu falo mais XD emissão

Uma coisa imporatnte a se dizer é todas em EquationLang todas as equações podem ser referenciadas em ourtas equações para isso pode ser possivel em GLSL, declarações todas as variaveis primeiro fora da função BRDF, efetivamente deixando-as globais. E só ao entrar na função é que inicializados, isso vale para as variaveis embutidas tbm \autoref{cod-builtins}. Isso é feito principalmente para deixar as variaveis visiveis dentro um função em GLSL assim como semanticamente é possivel em EquationLang. @Diga pra nota em agluma imagem mostrando isso@ Outra coisa é que todas as equaqações estão na ordem correta de avaliação já que isso foi feito através da ordernação topológica feita anteriormente, então as decalarções globais são cosistente, sempre, e vão conseguir rodar no GLSL @informal@.

\subsection{Emissão de Definições de Função}
A emissão de definições de função segue um processo similiar ao de equações, mas o LHS é diferente. Geração de assinatura de função. O RHS sempre é um exp´ressão então a mesma lógica de regração de expresão pode ser usado para o copo dessa função. O mesmo mapeamento de tipos de parâmetros.

\begin{itemize}
   \item Extração de tipo de retorno, extraido pelo campo results em \autoref{thingy}
   \item Processamento de identificadores de função, usando a estratégia citada na \autoref{sec-unicidade}
   \item Geração dos parametros entre parenteses, inclue tipo e nome da variaveis, também na estratégia\autoref{sec-unicidade}  ncparamétrica tipada, seguido
   \item Emissão de corpo de função, que consiste no token '{', seguido da palavra-chave return, agora chamada recursiva para emit_expr, ';' e por fecha chave '}'.
\end{itemize}

A parametrização implementa um mapeamento bijetivo entre tipos inferidos e representações GLSL, garantindo preservação semântica durante a tradução.
Um exemplo de da geração de um definição de função pode ser visto no \autoref{cod-normalize-reflect}, emitido pelas funções de reflexão e normalização definidos na equação \autoref{eq-normalize-reflect}. Note que os nomes gerados seguem a enumeração dita na \autoref{sec-unicidade} e que o retorno pode ser avaliada à uma unica expressão.


\label{eq-normalize-reflect} \begin{subequations}
\begin{equation}
  \text{normalize}(\vec{u}) = \frac{\vec{u}}{\sqrt{\vec{u} \cdot \vec{u}}}
\end{equation}

\begin{equation}
reflect(\vec I, \vec N) =  2*(\vec I \cdot \vec N)*\vec N - \vec I
\end{equation}
\end{subequations}

\begin{codigo}[htb]
   \caption{\small Código GLSL gerado pelo compilador para as funções de normalização e reflexão de vetores. }
   \label{cod-normalize-reflect}
\begin{lstlisting}[language=C, inputencoding=utf8]
//////////// START FUNCTIONS DECLARATIONS ////////////
vec3 var_13_reflect(vec3 var_14_vec_I, vec3 var_15_vec_N) {
    return (((2.0*(dot(var_14_vec_I,var_15_vec_N)))*var_15_vec_N)-var_14_vec_I);
}

vec3 var_17_text_normalize(vec3 var_18_vec_u) {
    return (var_18_vec_u/sqrt(dot(var_18_vec_u,var_18_vec_u)));
}
//////////// END FUNCTIONS DECLARATIONS ////////////

\end{lstlisting}
\end{codigo}

\verb
\verb"
   ")
   ")
   
")
\verb
φ
φ
θ
\verb
π
π
\verb
\verb`
var12345
var12345_f__1_`
, resultado
\verb`var12345_f__1_`.
 
\textbf{
}
  
 
, 
a
a
embora não seja uma prioridade neste contexto.


---  

Para garantir o comentado em @@checker-chapter. Deve-se também, garantir que as variaveis emitidas são únicas, glsl não permite os caracteres \verb'{,}' em seus identificadores, isso singica que uma euqação definida em latex \verb`f_{1} = 2` não pode ser transformado para um identificador \verb`f_{1} = 2` em glsl, para resolver isso cada simbolo não permitido em glsl é substituido por unmderline \verb'_' gerlando o resultado parical \verb`f__1_`. Isso ainda gera colisão pois outros @@ simbolos poder gerar a mesma indeficiador em glsl, 

para garantir cada identificador ser realmennte unico um mapeamento é feito entre a string do identificar na equação latex para um inteiro único de 64 bits adicionamos a string "var" + o esse inteiro denomiado ID ao resultado parcial, garantido que todo simbolo de euqação recebe um unico symbolo em glsl. 

Em contrapartido o compilador permite um máximo de $2^64 - 1$ equações, oq é um número mt bom é possivel permitir mais com big ints, mas para os propositos de cirar BRDFs é suficiente. Uma outra etapa é remover possiveis sequencia de 2 ou mais \verb"_" pois OpenGL reserva nomes contendo \verb"__", ai sim temos a variavel final.

A linguagem GLSL impõe restrições sintáticas na definição de identificadores. Caracteres especiais como '{', '}' são proibidos, o que impossibilita uma transformação direta de notações matemáticas para identificadores de programação. Considere, por exemplo, uma equação em notação LaTeX:

\verb
\verb"{"
{
uma cadeira de caracteres baseado no nó indentificador e todos as subexpressões presente
uma cadeira de caracteres baseado no nó indentificador e todos as subexpressões presente

    
sublinhados 
    

\[ f_{1} = 2 \]

A transformação direta resultaria em um identificador inválido em GLSL.
Para garantir a unicidade e a compatibilidade dos identificadores durante este processo de geração de código foi feitos três tarefas principais:

\subsubsection{1. **Substituição de Caracteres Especiais**}
   
   Primeiro todos construimos , já que é permitido ver subexpressões como vimos em.Mas Em seguida, todos os caracteres não permitidos em GLSL são substituídos pelo caractere sublinhado (\verb'_'). No exemplo anterior, a transformação inicial seria:

   \[ f\_\_1\_ \]

unicidade
\verb`var12345_f__1_`
,
, como .
   
   Para garantir a unicidade absoluta, implementa-se um mapeamento que associa cada identificador original a um inteiro único de 64 bits. A estratégia consiste em:
   
   - Prefixar a string "var"
   - Concatenar um identificador numérico exclusivo
   
   Exemplo, seja $\text{ID}_i$ o identificador único para o símbolo $i$:


2. **Prevenção de Colisões de Identificadores**

   % \[ \text{ID}_i = \text{hash}(\text{"var"} + i) \]

3. **Normalização Final**
   
   Remove-se sequências consecutivas de sublinhados, respeitando as convenções do OpenGL que \emph{reservam} identificadores com sequências duplas de sublinhados para uso interno.

O método proposto oferece:

- Espaço de identificadores: $2^{64} - 1$ equações
- Possibilidade de extensão utilizando inteiros de precisão arbitrária

\subsection{Geração de Expressões}


Esta tarefa é fundamental no processo de compilação e ocupa a maior parte deste pacote \texttt{emitter}.
A emissão de expressões é implementada na função \verb`emit_expr`. Essa função aceita uma nó expressão qualquer e um referencia à uma lista de caracteres (tipo `StringBuilder` disponibilizado pela biblioteca padrão de Odin) onde ira escrever um código GLSL correto. Para isso é realizado a travessia recursiva da (AST), usando \texttt{walker} convertendo todas as expressões binárias, prefixas, chamada de funções,  e operações vetoriais em código GLSL válido. A a função checa o tipo do da expressão em um \verb`switch` discriminado para processar diferentes tipos de nós da AST, um recorte dessa função pode ser vista no \autoref{cod-emit-expr}. As principais categorias de expressões tratadas são:

1. Expressões prefixas (\verb`Expr_Prefix`):
   - Implementa a emissão de funções trigonométricas (sin, cos, tan, asin, acos, atan)
   - Processa operadores unários como negação (-) e raiz quadrada (sqrt)
   - Realiza a conversão de vetores através da construção vec3()
   - Mantém a precedência de operadores através de parênteses apropriados

2. Expressões binárias (\verb`Expr_Infix`):
   - Gerencia operações aritméticas básicas (+, -, *, /)
   - Implementa tratamento especial para multiplicação vetorial, diferenciando:
     * Produto interno entre vetores
     * Multiplicação escalar-vetor
     * Multiplicação escalar-escalar
   - Processa operações vetoriais, a unica que damos suporte é produto vetorial (\verb`cross`).
   - Exponenciação (\verb'x ^ y') é implementada fazendo chamanda a função \verb`pow()` que embutida em GLSL.

3. Expressões Literais e Identificadores:
   - Processa literais numéricos com formatação apropriada para GLSL
   - Gerencia a conversão de identificadores mantendo a consistência com o escopo
   - Implementa a construção de literais vetoriais através do construtor vec3

4. Expressões Agrupadas e Chamadas de Função:
   - Preserva a precedência de operadores através de parênteses
   - Implementa a emissão de chamadas de função com suporte a múltiplos argumentos
   - Mantém a separação adequada de argumentos através de vírgulas

A função utiliza um StringBuilder para construção eficiente, evitando concatenações excessivas durante a emissão do código. O sistema implementa verificações de tipo em tempo de compilação para garantir a corretude das operações vetoriais e escalares, essencial para a geração de código GLSL válido.

Esta implementação consegue traduzir as expressões matemáticas como na \autoref{eq-emit-expr-example} e emitir o \autoref{cod-emit-expr-example} na linguagens de shading.

f_{1} = 2
    \]

% A geração de expressões constitui uma tarefa fundamental no processo de compilação, ocupando a parcela mais significativa do pacote \texttt{emitter}. Esta etapa crítica desempenha um papel central na transformação de expressões matemáticas abstratas em código de shader executável, representando o núcleo da tradução entre linguagens de alto nível e GLSL.

Esta tarefa é fundamental no processo de compilação e ocupa a maior parte deste pacote \texttt{emitter}.

e
g
 
o
em 
à
A implementação é realizada na função \verb`emit_expr`, que recebe um nó de expressão e uma referência a um objeto \verb`StringBuilder` (da biblioteca padrão de Odin). Este objeto é utilizado para construir eficientemente o código GLSL, evitando concatenações excessivas de strings. A travessia da AST é feita de forma recursiva usando \texttt{walker}, convertendo diferentes tipos de expressões, como operações binárias, prefixas, vetoriais e chamadas de função. Para isso, a função utiliza um \verb`switch` discriminado, lidando com cada tipo de nó. A seguir, são detalhadas as principais categorias de expressões tratadas:  

1. **Expressões Prefixas (\verb`Expr_Prefix`)**:  
   Essas expressões incluem operações unárias e funções matemáticas básicas. A implementação:  
   - Emite funções trigonométricas como \verb`sin`, \verb`cos` e \verb`tan`.  
   - Lida com operadores unários, como negação (\verb`-`) e raiz quadrada (\verb`sqrt`).  
   - Constrói vetores usando o construtor \verb`vec3()`.  
   - Mantém a precedência de operadores adicionando parênteses apropriados.  

2. **Expressões Binárias (\verb`Expr_Infix`)**:  
   Operações binárias representam a maior parte das expressões matemáticas. Esta categoria:  
   - Gerencia operações aritméticas básicas (\verb`+`, \verb`-`, \verb`*`, \verb`/`).  
   - Implementa o suporte a multiplicações vetoriais diferenciando:  
     * Produto interno (\verb`dot`).  
     * Multiplicação escalar-vetor.  
     * Multiplicação escalar-escalar.  
   - Suporta o produto vetorial (\verb`cross`).  
   - Processa exponenciação (\verb`x^y`) chamando a função \verb`pow()` do GLSL.  

3. **Expressões Literais e Identificadores**:  
   Nesta categoria, tratamos os valores diretamente utilizados no código e seus identificadores. A função:  
   - Formata literais numéricos para o padrão GLSL.  
   - Converte identificadores de acordo com as regras de escopo.  
   - Constrói vetores literais utilizando \verb`vec3`.  

4. **Expressões Agrupadas e Chamadas de Função**:  
   A emissão de chamadas de função e expressões agrupadas segue regras específicas para garantir a consistência sintática. O processo:  
   - Adiciona parênteses para preservar a precedência de operadores.  
   - Implementa a emissão de chamadas de função com múltiplos argumentos.  
   - Garante a separação correta dos argumentos com vírgulas.  

Para garantir a corretude do código gerado, são realizadas verificações de tipo em tempo de compilação, assegurando a validade de operações vetoriais e escalares. Esse sistema permite traduzir expressões matemáticas como mostrado em \autoref{eq-emit-expr-example}, gerando o código correspondente apresentado em \autoref{cod-emit-expr-example}.  

um recorte dessa função pode ser vista no \autoref{cod-emit-expr}
  
|
|
"
)
A travessia da AST é feita de forma recursiva usando o pacote\texttt{walker}, convertendo diferentes tipos de expressões, como operações binárias, prefixas, vetoriais e chamadas de função. Para isso, a função discrimina o tipo de nó para decidir qual operação é equivalente em GLSL. Um recorte dessa função pode ser vista no \autoref{cod-emit-expr}, onde podemos observar a discriminação feita pela palavra chave \texttt{case} e a escrita de string de funlões trignonometria na instancia de string builder d através da função \verb"sbprint". A seguir, são detalhadas as principais categorias de expressões tratadas:

dessa 

A travessia da AST é feita de forma recursiva usando o pacote\texttt{walker}, convertendo diferentes tipos de expressões, como operações binárias, prefixas, vetoriais e chamadas de função. Para isso, a função discrimina o tipo de nó para decidir qual operação é equivalente em GLSL. Um recorte dessa função pode ser vista no \autoref{cod-emit-expr}, onde podemos observar a discriminação feita pela palavra chave \texttt{case} e a escrita de string de funlões trignonometria na instancia de string builder d através da função \verb"sbprint". A seguir, são detalhadas as principais categorias de expressões tratadas:

  
.
  
  
  
)
(
\sqrt{-2}
o
            \item Multiplicação escalar-escalar.  

            \item Produto interno (\verb|dot|).

        \item Implementa o suporte a multiplicações vetoriais diferenciando:  
        \begin{itemize}

        \end{itemize}

            \item Produto interno (\verb|dot|).

    
\verb"\vec{n} \cdot 2" equivalente à \verb"(vec3(n)*2)".
 
*
\omega_i
vec3(var_1_n)
1
1
  
    Nesta categoria, tratamos os valores diretamente utilizados no código e seus identificadores. A função:  
    \begin{itemize}
        \item Formata literais numéricos para o padrão GLSL.  

        \item Converte identificadores de acordo com as regras de escopo.  

  
        \item Constrói vetores literais utilizando \verb|vec3|.  

 literais utilizando \verb|vec3|.  
  
        \item Adiciona parênteses para preservar a precedência de operadores.  

    \begin{itemize}
        \item Implementa a emissão de chamadas de função com múltiplos argumentos.  

    A emissão de chamadas de função e expressões agrupadas segue regras específicas para garantir a consistência sintática. O processo:  

|
\
 
separação correta dos argumentos com vírgulas.  
        case ^Expr_Function_Call:
        emit_expr(sb, e.left)
        sbprint(sb, '(')
        for arg, idx in e.exprs {
            emit_expr(sb, arg)
            if idx < (len(e.exprs) -1)  {
                sbprint(sb, ',')
            }
        }
        sbprint(sb, ')')

title
cod-emission-func
        case ^Expr_Function_Call:
        emit_expr(sb, e.left)
        sbprint(sb, '(')
        for arg, idx in e.exprs {
            emit_expr(sb, arg)
            if idx < (len(e.exprs) -1)  {
                sbprint(sb, ',')
            }
        }
        sbprint(sb, ')')

A emissão de expressões é implementada na função \verb`emit_expr`. Essa função aceita uma nó expressão qualquer e um referencia à uma lista de caracteres (tipo `StringBuilder` disponibilizado pela biblioteca padrão de Odin) onde ira escrever um código GLSL correto. Para isso é realizado a travessia recursiva da (AST), usando \texttt{walker} convertendo todas as expressões binárias, prefixas, chamada de funções,  e operações vetoriais em código GLSL válido. A a função checa o tipo do da expressão em um \verb`switch` discriminado para processar diferentes tipos de nós da AST, . As principais categorias de expressões tratadas são:

1. Expressões prefixas (\verb`Expr_Prefix`):
   - Implementa a emissão de funções trigonométricas (sin, cos, tan, asin, acos, atan)
   - Processa operadores unários como negação (-) e raiz quadrada (sqrt)
   - Realiza a conversão de vetores através da construção vec3()
   - Mantém a precedência de operadores através de parênteses apropriados

2. Expressões binárias (\verb`Expr_Infix`):
   - Gerencia operações aritméticas básicas (+, -, *, /)
   - Implementa tratamento especial para multiplicação vetorial, diferenciando:
     * Produto interno entre vetores
     * Multiplicação escalar-vetor
     * Multiplicação escalar-escalar
   - Processa operações vetoriais, a unica que damos suporte é produto vetorial (\verb`cross`).
   - Exponenciação (\verb'x ^ y') é implementada fazendo chamanda a função \verb`pow()` que embutida em GLSL.

3. Expressões Literais e Identificadores:
   - Processa literais numéricos com formatação apropriada para GLSL
   - Gerencia a conversão de identificadores mantendo a consistência com o escopo
   - Implementa a construção de literais vetoriais através do construtor vec3

4. Expressões Agrupadas e Chamadas de Função:
   - Preserva a precedência de operadores através de parênteses
   - Implementa a emissão de chamadas de função com suporte a múltiplos argumentos
   - Mantém a separação adequada de argumentos através de vírgulas

A função utiliza um StringBuilder para construção eficiente, evitando concatenações excessivas durante a emissão do código. O sistema implementa verificações de tipo em tempo de compilação para garantir a corretude das operações vetoriais e escalares, essencial para a geração de código GLSL válido.

Esta implementação consegue traduzir as expressões matemáticas como na \autoref{eq-emit-expr-example} e emitir o \autoref{cod-emit-expr-example} na linguagens de shading.


\subsection{Começo da Emissão}%
\label{sub:start-emitting}

A função \verb`emit` representa o ponto de entrada do processo de emissão de código, implementando a transformação final AST em um shader GLSL analítico. Esta função opera em três fases distintas e cruciais:

1. Fase de Inicialização e Estruturação:
   - Estabelece o formato canônico do shader através da emissão de cabeçalhos específicos
   - Implementa uma seção de parâmetros que permite a parametrização do shader
   - Delimita claramente as seções do código através de marcadores (::begin shader, ::end shader), são necessário para carregar o shading na ferramenta da Disney
   - Emite as declarações de funções embutidas (comumente chamda de \verb`built-in`) necessárias para o funcionamento do shader

2. Fase de Processamento de Símbolos:
   - Itera sobre uma tabela de símbolos ordenada (\verb"Scope")
   - Processa três categorias principais de símbolos:
     * Variáveis numéricas escalares (\verb"Type_Basic")
     * Definições de funções (\verb"Type_Function")
     * Variáveis vetoriais (\verb"Type_Vector")
   - Mantém separação entre declarações e definições através de builders distintos
   - Implementa um sistema de buffer duplo onde as equações são acumuladas separadamente das declarações, isso é feito para simular escopo global em GLSL.

3. Fase de Emissão Final:
   - Concatena as declarações de funções em ordem apropriada
   - Emite a função de entrada (entry point) chamado \verb`BRDF`, entrada necessaria para ferramenta Disney.
   - Realiza a escrita do código gerado em arquivo através de operações de I/O seguras
   - Implementa verificação de erros na escrita do arquivo

A função mantém uma clara separação de responsabilidades através de seções comentadas (START OF BUILTINS DECLARATION, START OF USER DECLARED, etc), facilitando a manutenção e depuração do código gerado. O sistema implementa um mecanismo de diferenciação entre símbolos built-in e definidos pelo usuário, garantindo que não haja duplicação de declarações.

Uma característica notável é a utilização de um sistema de builders para construção eficiente de strings, minimizando a sobrecarga de memória durante a geração do código. A função também implementa um sistema de gestão de recursos através do uso de `defer` para limpeza adequada dos builders.

O processo de emissão é crucial para a geração de shaders GLSL válidos, pois mantém a ordem correta de declarações e definições, essencial para a compilação posterior pelo compilador GLSL. A função retorna um booleano indicando o sucesso da operação de escrita, permitindo tratamento adequado de erros em níveis superiores do compilador.

Estas funções implementam a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL, estabelecendo as variáveis fundamentais para computação de interações luz-material. As variaveis enbutidas são aquelas definidas na tabelas @@@, que são a angulo de incidencia, entre outros, a ferramenta disney oferece algumas dessas variaveis embutidas como parametro para função de entrada \verb`BRDF`, mas com convenções de nomes diferentes do estabelicdo neste trabalho. Essas são:
      \verb`normal_vector`: normal da superfície (N)
      \verb`omega_i`: direção da luz incidente (L)
      \verb`omega_o`: direção de visualização (V)
Todas as outras são calculadas por nós e gerado para todas as entradas automaticamente, pronto para uso em qualquer equação.
Para calcular as embutidas \verb"omega_i", \verb"theta_d", \verb"phi_i", etc.., é foi desenvolvida algumas funções auxiliares de coordenadas esféricas:

   - A função \verb`phi(v)` calcula o ângulo azimutal ($\phi$) a partir de um vetor:
     - Implementa a conversão de coordenadas cartesianas para esféricas
     - Utiliza \verb"\atan(sqrt(y² + x²), z)" para computar $\phi$
   - A função \verb`theta(v)` calcula o ângulo polar ($\theta$):
     - Implementa atan(y, x) para computação do ângulo no plano xy

Assim podemos podemos fazer declaração das variáveis built-in  ( através da função \verb`emit_builtin_globals_declaration`):
     - \verb`half_vector`: vetor intermediário entre direção de luz e visualização (H)
     - \verb`normal_vector`: normal da superfície (N)
     - \verb`omega_i`: direção da luz incidente (L)
     - \verb`omega_o`: direção de visualização (V)
   
   - Ângulos Esféricos:
     - \verb`theta_h`: ângulo entre H e N
     - \verb`theta_d`: ângulo entre H e L
     - \verb`theta_i`: ângulo polar da luz incidente
     - \verb`theta_o`: ângulo polar da visualização
     - \verb`phi_i`: ângulo azimutal da luz incidente
     - \verb`phi_o`: ângulo azimutal da visualização

E também constantes matemáticas:
     - \verb`pi`: valor de $\pi$
     - \verb`epsilon`: valor de precisão numérica


A função \verb`emit_builtin_entry_function` encapsula toda esta lógica na função BRDF principal. 
- Recebe os vetores de entrada (L, V, N, X, Y), X e Y não usados.
- Inicializa todas as variáveis built-in, seu código gerado das variaveis embutidas pode ser visto em \autoref{cod-builtins-emitted}
- Incorpora as equações específicas do usuário
- Retorna o valor final da BRDF como um vec3

Este sistema fornece uma base suficiente para implementação de BRDFs complexas. 
\begin{codigo}[htb]
    \caption{\small Recorte da função BRDF one as variaveis built-ins são inicializadas }
    \label{cod-builtins-emitted}
\begin{lstlisting}[language=C, frame=none, inputencoding=utf8]
  //////////// START OF BUILTINS INITIALIZATION ////////////
  var_0_vec_h = normalize(L + V);
  var_3_vec_n = normalize(N);
  var_1_pi = 3.141592653589793;
  var_2_epsilon = 1.192092896e-07;
  var_4_vec_omega_i = L;
  var_5_theta_i = atan(var_4_vec_omega_i.y, var_4_vec_omega_i.x);
  var_6_phi_i = atan(sqrt(var_4_vec_omega_i.y * var_4_vec_omega_i.y +
                          var_4_vec_omega_i.x * var_4_vec_omega_i.x),
                     var_4_vec_omega_i.z);
  var_7_vec_omega_o = V;
  var_8_theta_o = atan(var_7_vec_omega_o.y, var_7_vec_omega_o.x);
  var_9_phi_o = atan(sqrt(var_7_vec_omega_o.y * var_7_vec_omega_o.y +
                          var_7_vec_omega_o.x * var_7_vec_omega_o.x),
                     var_7_vec_omega_o.z);
  var_10_theta_h = acos(dot(var_0_vec_h, N));
  var_11_theta_d = acos(dot(var_0_vec_h, var_4_vec_omega_i));
  //////////// END OF BUILTINS INITIALIZATION ////////////
\end{lstlisting}
\end{codigo}




---------

Nos resultados eu falo mais XD emissão

Uma coisa imporatnte a se dizer é todas em EquationLang todas as equações podem ser referenciadas em ourtas equações para isso pode ser possivel em GLSL, declarações todas as variaveis primeiro fora da função BRDF, efetivamente deixando-as globais. E só ao entrar na função é que inicializados, isso vale para as variaveis embutidas tbm \autoref{cod-builtins}. Isso é feito principalmente para deixar as variaveis visiveis dentro um função em GLSL assim como semanticamente é possivel em EquationLang. @Diga pra nota em agluma imagem mostrando isso@ Outra coisa é que todas as equaqações estão na ordem correta de avaliação já que isso foi feito através da ordernação topológica feita anteriormente, então as decalarções globais são cosistente, sempre, e vão conseguir rodar no GLSL @informal@.

A função \verb`emit` representa o ponto de entrada do processo de emissão de código, implementando a transformação final AST em um shader GLSL analítico. Esta função opera em três fases distintas e cruciais:




Essa abordagem assegura consistência entre as declarações e a lógica subsequente, replicando o comportamento semântico de EquationLang no GLSL.

    \item \textbf{Ordenação Topológica}: Declarações globais são sempre consistentes e organizadas para avaliação sequencial no GLSL.


1. Fase de Inicialização e Estruturação:
   - Estabelece o formato canônico do shader através da emissão de cabeçalhos específicos
   - Implementa uma seção de parâmetros que permite a parametrização do shader
   - Delimita claramente as seções do código através de marcadores (::begin shader, ::end shader), são necessário para carregar o shading na ferramenta da Disney
   - Emite as declarações de funções embutidas (comumente chamda de \verb`built-in`) necessárias para o funcionamento do shader

2. Fase de Processamento de Símbolos:
   - Itera sobre uma tabela de símbolos ordenada (\verb"Scope")
   - Processa três categorias principais de símbolos:
     * Variáveis numéricas escalares (\verb"Type_Basic")
     * Definições de funções (\verb"Type_Function")
     * Variáveis vetoriais (\verb"Type_Vector")
   - Mantém separação entre declarações e definições através de builders distintos
   - Implementa um sistema de buffer duplo onde as equações são acumuladas separadamente das declarações, isso é feito para simular escopo global em GLSL.

3. Fase de Emissão Final:
   - Concatena as declarações de funções em ordem apropriada
   - Emite a função de entrada (entry point) chamado \verb`BRDF`, entrada necessaria para ferramenta Disney.
   - Realiza a escrita do código gerado em arquivo através de operações de I/O seguras
   - Implementa verificação de erros na escrita do arquivo

\subsubsection{Construção e Gestão de Recursos}
O sistema utiliza builders eficientes para minimizar a sobrecarga de memória durante a geração do código. Além disso, o uso de \texttt{defer} garante a limpeza automática de recursos, evitando problemas de vazamento.



:
Uma característica notável é a utilização de um sistema de builders para construção eficiente de strings, minimizando a sobrecarga de memória durante a geração do código. A função também implementa um sistema de gestão de recursos através do uso de `defer` para limpeza adequada dos builders.



mesmo mapeamento de tipos de parâmetros.

a
um exp´ressão então a mesma lógica de regração de expresão pode ser usado para o copo dessa função. O 
   \item Extração de tipo de retorno, extraido pelo campo results em \autoref{thingy}

usando a estratégia citada na \autoref{sec-unicidade}
\begin{itemize}
   \item Processamento de identificadores de função, 
   \item Geração dos parametros entre parenteses, inclue tipo e nome da variaveis, também na estratégia \autoref{sec-unicidade}  ncparamétrica tipada, seguido
   % \item Emissão de corpo de função, que consiste no token `\verb{`, seguido da palavra-chave return, agora chamada recursiva para \verb`emit_expr`, \verb`;` e por fecha chave \verb`}`.
\end{itemize}


A parametrização implementa um mapeamento bijetivo entre tipos inferidos e representações GLSL, garantindo preservação semântica durante a tradução.

A parametrização implementa um mapeamento bijetivo entre tipos inferidos e representações GLSL, garantindo preservação semântica durante a tradução.

²
²
²
e
I
- 
-
- Ângulos Esféricos:

:
:
    \item 

 \item

9323846264338327950288
\
    \begin{itemize}

    ck

    \begin{itemize}

(
)
  
(
        \begin{itemize}

    \end{itemize}



O mapeamento entre tipos inferidos em \texttt{EquantionLang} e representações GLSL é bijetivo garantindo preservação semântica durante a tradução.
A parametrização implementa um mapeamento bijetivo entre tipos inferidos e representações GLSL, garantindo preservação semântica durante a tradução.


em \texttt{EquantionLang}
 \\
l
tabela
variáveis sejam declaradas globalmente
    \item \textbf{Simulação de Escopo Global}: Acumulação de equações em um buffer separado, permitindo que , mas inicializadas dentro da função BRDF.

s
A função \verb`emit_builtin_entry_function` encapsula toda esta lógica na função BRDF principal. 

emit_builtin
 Inicializa todas as variáveis built-in, seu código gerado das variaveis embutidas pode ser visto em \autoref{cod-builtins-emitted}

Estas variáveis são inicializadas de forma automática e padronizada dentro da função BRDF, garantindo compatibilidade com a entrada da ferramenta Disney.

A função mantém uma clara separação de responsabilidades através de seções comentadas (START OF BUILTINS DECLARATION, START OF USER DECLARED, etc), facilitando a manutenção e depuração do código gerado. 

Estas funções implementam a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL, estabelecendo as variáveis fundamentais para computação de interações luz-material. As variaveis enbutidas são aquelas definidas na tabelas @@@, que são a angulo de incidencia, entre outros, a ferramenta disney oferece algumas dessas variaveis embutidas como parametro para função de entrada \verb`BRDF`, mas com convenções de nomes diferentes do estabelicdo neste trabalho. Essas são: \verb`normal_vector`, normal da superfície (N); \verb`omega_i`, direção da luz incidente (L); \verb`omega_o`, direção de visualização (V). Todas as outras são calculadas por nós e gerado para todas as entradas automaticamente, pronto para uso em qualquer equação.

Estas funções implementam a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL, estabelecendo as variáveis fundamentais para computação de interações luz-material.
As variaveis enbutidas são aquelas definidas na tabelas @@@, que são a angulo de incidencia, entre outros, a ferramenta disney oferece algumas dessas variaveis embutidas como parametro para função de entrada \verb`BRDF`, mas com convenções de nomes diferentes do estabelicdo neste trabalho. Essas são: \verb`normal_vector`, normal da superfície (N); \verb`omega_i`, direção da luz incidente (L); \verb`omega_o`, direção de visualização (V). Todas as outras são calculadas por nós e gerado para todas as entradas automaticamente, pronto para uso em qualquer equação.

A função mantém uma clara separação de responsabilidades através de seções comentadas (START OF BUILTINS DECLARATION, START OF USER DECLARED, etc), facilitando a manutenção e depuração do código gerado.



Estas variáveis são inicializadas de forma automática e padronizada dentro da função BRDF, garantindo compatibilidade com a entrada da ferramenta Disney.

E também constantes matemáticas: \verb`pi`: valor de $\pi$, como ponto flutuante $3.1415926535897$ e \verb`epsilon`: valor de precisão numérica $1.192092896^-07$.



\verb`epsilon`
`
`
:
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Variável} & \textbf{Descrição} \\
        \hline
        N & Número de amostras \\
        \hline
        $\theta_i$ & Ângulo de elevação da direção da luz incidente \\
        \hline
        $\theta_o$ & Ângulo de elevação da direção da luz refletida \\
        \hline
        $\phi_i$ & Ângulo azimutal da direção da luz incidente \\
        \hline
        $\phi_o$ & Ângulo azimutal da direção da luz refletida \\
        \hline
        $\omega_i = (\theta_i, \phi_i)$ & Direção da luz incidente em coordenadas polares \\
        \hline
        $\omega_o = (\theta_o, \phi_o)$ & Direção da luz refletida em coordenadas polares \\
        \hline
        $\theta_{is}$ & $\theta_i$ da sth amostra de reflectância \\
        \hline
        $p_s$ & Parâmetros para recuperar a sth amostra de um BRDF específico, incluindo $\omega_i$ e $\omega_o$ para esta amostra \\
        \hline
        $f_R$ & BRDF de referência \\
        \hline
        $f_A$ & BRDF aproximada \\
        \hline
        $w$ & Termo de correção do ângulo sólido \\
        \hline
    \end{tabular}
    \caption{Tabela de variáveis e suas descrições}
    \label{tab-variaveis-builtins}
\end{table}

        $\theta_{is}$ & $\theta_i$ da sth amostra de reflectância \\
        \hline

        $p_s$ & Parâmetros para recuperar a sth amostra de um BRDF específico, incluindo $\omega_i$ e $\omega_o$ para esta amostra \\

        \hline
        $f_A$ & BRDF aproximada \\

        \hline
        $w$ & Termo de correção do ângulo sólido \\

        \hline

\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Variável} & \textbf{Descrição} \\
        \hline
        N & Número de amostras \\
        \hline
        $\theta_i$ & Ângulo de elevação da direção da luz incidente \\
        \hline
        $\theta_o$ & Ângulo de elevação da direção da luz refletida \\
        \hline
        $\phi_i$ & Ângulo azimutal da direção da luz incidente \\
        \hline
        $\phi_o$ & Ângulo azimutal da direção da luz refletida \\
        \hline
        $\omega_i = (\theta_i, \phi_i)$ & Direção da luz incidente em coordenadas polares \\
        \hline
        $\omega_o = (\theta_o, \phi_o)$ & Direção da luz refletida em coordenadas polares \\
        \hline
        $f$ & BRDF de referência \\
        \hline
    \end{tabular}
    \caption{Tabela de variáveis e suas descrições}
    \label{tab-variaveis-builtins}
\end{table}


\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Variável} & \textbf{Descrição} \\
        \hline
        N & Número de amostras \\
        \hline
        $\theta_i$ & Ângulo de elevação da direção da luz incidente \\
        \hline
        $\theta_o$ & Ângulo de elevação da direção da luz refletida \\
        \hline
        $\phi_i$ & Ângulo azimutal da direção da luz incidente \\
        \hline
        $\phi_o$ & Ângulo azimutal da direção da luz refletida \\
        \hline
        $\omega_i = (\theta_i, \phi_i)$ & Direção da luz incidente em coordenadas polares \\
        \hline
        $\omega_o = (\theta_o, \phi_o)$ & Direção da luz refletida em coordenadas polares \\
        \hline
        $f$ & BRDF de referência \\
        \hline
    \end{tabular}
    \caption{Tabela de variáveis e suas descrições}
    \label{tab-variaveis-builtins}
\end{table}

:
        \hline
        N & Número de amostras \\

tab-conventions
        \hline
        $\theta_{is}$ & $\theta_i$ da sth amostra de reflectância \\

        \hline
        $p_s$ & Parâmetros para recuperar a sth amostra de um BRDF específico, incluindo $\omega_i$ e $\omega_o$ para esta amostra \\

        \hline
        $f_A$ & BRDF aproximada \\

w
r
i
        $\vec{n}$ & Vetor normal à superfície \\
        \hline

n
n
        $\theta_i$ & Ângulo de elevação da direção da luz incidente \\

        \hline
        $\theta_i$ & Ângulo de elevação da direção da luz incidente \\

i
        \hline
        $\theta_d$ & Ângulo entre \\

d
$\omega_o$ e $\omega_i$
o
        $\theta_h$ & Ângulo entre $\omega_i$ e $\vec{h}$ \\

        \hline
        $\theta_h$ & Ângulo entre $\omega_i$ e $\vec{h}$ \\

h
c
s
Simbolo
i
    \begin{tabular}{|c|l|}

\begin{table}[h]
    \centering
    % \begin{tabular}{|c|l|}
    \begin{tabular}{c|l}
        \hline
        \textbf{Símbolo} & \textbf{Descrição} \\
        \hline
        $\theta_i$ & Ângulo de elevação da direção da luz incidente \\
        \hline
        $\theta_o$ & Ângulo de elevação da direção da luz refletida \\
        \hline
        $\phi_i$ & Ângulo azimutal da direção da luz incidente \\
        \hline
        $\phi_o$ & Ângulo azimutal da direção da luz refletida \\
        \hline
        $\omega_i$ & Direção da luz incidente  \\
        \hline
        $\omega_o$ & Direção da luz refletida  \\
        \hline
        $f$ & BRDF de referência \\
        \hline
        $\vec{n}$ & Vetor normal à superfície \\
        \hline
        $\vec{h}$ & Vetor do meio entre $\omega_o$ e $\omega_i$ \\
        \hline
        $\theta_h$ & Ângulo entre $\vec{n}$ e $\vec{h}$ \\
        \hline
        $\theta_d$ & Ângulo entre $\omega_i$ e $\vec{h}$ \\
        \hline
    \end{tabular}
    % \caption{Tabela de simbolos e seu descrições}
    \label{tab-conventions}
\end{table}

gi
Ângulo de elevação da direção da luz incidente
Ângulo de elevação da direção da luz incidente
% $3.1415926535897$ e : valor de precisão numérica $1.192092896^-07$.
\begin{itemize}
    \item \verb`half_vector`: vetor intermediário entre direção de luz e visualização (H)
    \item \verb`normal_vector`: normal da superfície (N)
    \item \verb`omega_i`: direção da luz incidente (L)
    \item \verb`omega_o`: direção de visualização (V)
    \item \verb`theta_h`: ângulo entre H e N
    \item \verb`theta_d`: ângulo entre H e L
    \item \verb`theta_i`: ângulo polar da luz incidente
    \item \verb`theta_o`: ângulo polar da visualização
    \item \verb`phi_i`: ângulo azimutal da luz incidente
    \item \verb`phi_o`: ângulo azimutal da visualização
\end{itemize}

Ângulo de elevação da direção da luz refletida
Ângulo azimutal da direção da luz incidente
        \hline

Vetor normal à superfície
Ângulo entre $\vec{n}$ e $\vec{h}$
N
Ângulo entre $\omega_i$ e $\vec{h}$
        \hline
        $\theta_d$ & acos(dot(vec_h , omega_i)) \\
        \hline

        \hline



        $\pi$ & acos(dot(vec_h , omega_i)) \\
        \hline

3.141592653589793
1.192092896e-07
        var_1_pi =  ;

;
 
 
=
 
n
     var_2_epsilo



::end parameters
::begin parameters 
::end parameters
e
'
Essas variaveis disponibilizam a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL. A ferramenta Disney oferece algumas dessas variáveis embutidas como parâmetros para a função de entrada \verb"BRDF", mas com convenções de nomes diferentes das estabelecidas neste trabalho. Essas parametros são: \verb"N" que representa a normal da superfície; \verb"L" que indica a direção da luz incidente (L); \verb"V", que representa a direção de visualização. Todas as outras variáveis são calculadas por nós e geradas automaticamente para todas as entradas, prontas para uso em qualquer equação.


Para calcular as embutidas \verb"omega_i", \verb"theta_d", \verb"phi_i", etc.., é foi desenvolvida algumas funções auxiliares de coordenadas esféricas, retornam uma cadeia de caracteres válida em GLSL, e sua entrada é uma string "v" para ser substituida no corpo da string de retrono.
\begin{itemize}
    \item A função \verb`phi(v)` calcula o ângulo azimutal ($\phi$) a partir de um vetor. Utiliza \verb"atan(sqrt(v.y*v.y + v.x*v.x), v.z)" para computar $\phi$ em GLSL.
    \item A função \verb`theta(v)` calcula o ângulo polar ($\theta$) através da expressão \verb"atan(v.y, v.x)" valida em GLSL.
\end{itemize}


Assim podemos podemos fazer declaração das variáveis built-in  ( através da função \verb`emit_builtin_globals_declaration`) E também constantes matemáticas: \verb`pi`: valor de $\pi$ e $\epsilon$, que são implementadas como ponto flutuante, na tabela \autoref{2@@@} vemos o tipo. para ter clareza, removeos o prefixo das variaveis discutido em na sessão de unicidade (\autoref{sec-unicidade}).

Essas variaveis disponibilizam a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL. A ferramenta Disney oferece algumas dessas variáveis embutidas como parâmetros para a função de entrada \verb"BRDF", mas com convenções de nomes diferentes das estabelecidas neste trabalho. Essas parametros são: \verb"N" que representa a normal da superfície; \verb"L" que indica a direção da luz incidente (L); \verb"V", que representa a direção de visualização. Todas as outras variáveis são calculadas por nós e geradas automaticamente para todas as entradas, prontas para uso em qualquer equação.


Para calcular as embutidas \verb"omega_i", \verb"theta_d", \verb"phi_i", etc.., é foi desenvolvida algumas funções auxiliares de coordenadas esféricas, retornam uma cadeia de caracteres válida em GLSL, e sua entrada é uma string "v" para ser substituida no corpo da string de retrono.
\begin{itemize}
    \item A função \verb`phi(v)` calcula o ângulo azimutal ($\phi$) a partir de um vetor. Utiliza \verb"atan(sqrt(v.y*v.y + v.x*v.x), v.z)" para computar $\phi$ em GLSL.
    \item A função \verb`theta(v)` calcula o ângulo polar ($\theta$) através da expressão \verb"atan(v.y, v.x)" valida em GLSL.
\end{itemize}


Assim podemos podemos fazer declaração das variáveis built-in  ( através da função \verb`emit_builtin_globals_declaration`) E também constantes matemáticas: \verb`pi`: valor de $\pi$ e $\epsilon$, que são implementadas como ponto flutuante, na tabela \autoref{2@@@} vemos o tipo. para ter clareza, removeos o prefixo das variaveis discutido em na sessão de unicidade (\autoref{sec-unicidade}).

Se precisar de mais ajustes ou complementos, é só pedir!


Segue uma versão aprimorada e mais coesa:  


Essas parametros são: \verb"N" que representa a normal da superfície; \verb"L" que indica a direção da luz incidente (L); \verb"V", que representa a direção de visualização. Todas as outras variáveis são calculadas por nós e geradas automaticamente para todas as entradas, prontas para uso em qualquer equação.

- \verb`N`: normal da superfície.  
- \verb`L`: direção da luz incidente.  
- \verb`V`: direção de visualização.  


Todas as outras variáveis são calculadas por nós e geradas automaticamente para todas as entradas, prontas para uso em qualquer equação.

Todas as outras variáveis são calculadas por nós e geradas automaticamente para todas as entradas, prontas para uso em qualquer equação.

  
\verb`phi(v)`**: Calcula o ângulo azimutal ($\phi$) usando a fórmula \verb`atan(sqrt(v.y*v.y + v.x*v.x), v.z)`.  
\verb`theta(v)`: Calcula o ângulo polar ($\theta$) com a expressão \verb`atan(v.y, v.x)`.  
  
  
- **
- 


tab-conventions
,
o
Para maior clareza
.
O
---  

Essas variaveis disponibilizam a infraestrutura necessária para cálculos de reflectância bidirecional em shaders GLSL. A ferramenta Disney oferece algumas dessas variáveis embutidas como parâmetros para a função de entrada \verb"BRDF", mas com convenções de nomes diferentes das estabelecidas neste trabalho. 

Para calcular as embutidas \verb"omega_i", \verb"theta_d", \verb"phi_i", etc.., é foi desenvolvida algumas funções auxiliares de coordenadas esféricas, retornam uma cadeia de caracteres válida em GLSL, e sua entrada é uma string "v" para ser substituida no corpo da string de retrono.
\begin{itemize}
    \item A função \verb`phi(v)` calcula o ângulo azimutal ($\phi$) a partir de um vetor. Utiliza \verb"atan(sqrt(v.y*v.y + v.x*v.x), v.z)" para computar $\phi$ em GLSL.
    \item A função \verb`theta(v)` calcula o ângulo polar ($\theta$) através da expressão \verb"atan(v.y, v.x)" valida em GLSL.
\end{itemize}


Assim podemos podemos fazer declaração das variáveis built-in  ( através da função \verb`emit_builtin_globals_declaration`) E também constantes matemáticas: \verb`pi`: valor de $\pi$ e $\epsilon$, que são implementadas como ponto flutuante, na tabela \autoref{2@@@} vemos o tipo. para ter clareza, removeos o prefixo das variaveis discutido em na sessão de unicidade (\autoref{sec-unicidade}).





\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Variável} & \textbf{Descrição} \\
        \hline
        N & Número de amostras \\
        \hline
        $\theta_i$ & Ângulo de elevação da direção da luz incidente \\
        \hline
        $\theta_o$ & Ângulo de elevação da direção da luz refletida \\
        \hline
        $\phi_i$ & Ângulo azimutal da direção da luz incidente \\
        \hline
        $\phi_o$ & Ângulo azimutal da direção da luz refletida \\
        \hline
        $\omega_i = (\theta_i, \phi_i)$ & Direção da luz incidente em coordenadas polares \\
        \hline
        $\omega_o = (\theta_o, \phi_o)$ & Direção da luz refletida em coordenadas polares \\
        \hline
        $f$ & BRDF de referência \\
        \hline
    \end{tabular}
    \caption{Tabela de variáveis e suas descrições}
    \label{tab-variaveis-builtins}
\end{table}




emit_builtin_entry_function
A função \verb`emit_builtin_entry_function` encapsula toda esta lógica na função BRDF principal. 
Recebe os vetores de entrada (L, V, N, X, Y), X e Y não usados. Inicializa todas as variáveis built-in, seu código gerado das variaveis embutidas pode ser visto em \autoref{cod-builtins-emitted}
- Incorpora as equações específicas do usuário
- Retorna o valor final da BRDF como um vec3



o
é
