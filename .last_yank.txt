O
antes de avan√ßar para uma linguagem mais complexa. O cap√≠tulo tamb√©m descreve os testes elaborados para validar a implementa√ß√£o. Al√©m disso, ele apresenta o 
\subsection{Mecanismo de Reflex√£o de Raios}
% \include{Pos_Textual/Apendices}
Chapter
\subsection{Mecanismo de Reflex√£o de Raios}
\section{Desenvolvimento}
@{}
d
\begin{codigo}[H]
  \caption{\small Exemplo GLSL de \textit{shader} de v√©rtice.}
 \label{vertex_code1}
\begin{lstlisting}
#version 330 core
layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inNormal;
uniform mat4 modelViewProjection;
out vec3 fragNormal;
void main() {
    vec3 manipulatedPosition = inPosition + (sin(gl_VertexID * 0.1) * 0.1);
    fragNormal = inNormal;
    gl_Position = modelViewProjection * vec4(manipulatedPosition, 1.0);
}
\end{lstlisting}
\end{codigo}
√©
Anteriormente, na \autoref{lexer-subexpression}, foi comentado que o \textit{parser} √© capaz de lidar com identificadores aninhados, como, por exemplo, \( x_{i_1} \) (\verb"x_{i_1}"). No \autoref{cod-expression-ident-recursive}, apresentamos como esses identificadores s√£o criados recursivamente. O c√≥digo mostrado faz parte de uma fun√ß√£o maior, sendo um recorte de um \texttt{switch}\footnote{\texttt{switch} e \texttt{case} em Odin funcionam da mesma forma que na linguagem de programa√ß√£o \texttt{C}} sobre a enumera√ß√£o descrita no \autoref{enum-token-kind}. Dentro desse \texttt{switch}, temos um \texttt{case} que reconhece \textit{tokens} de identificador ou s√≠mbolos especiais (\( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \)). Ao fazer uma chamada recursiva √† fun√ß√£o \texttt{parse\_expr}, o \textit{parser} permite a inclus√£o de sub√≠ndices num√©ricos, subexpres√µes de identificadores ou at√© express√µes bin√°rias, como \( n+1 \) em \( f_{n+1} \).

Isso confere maior flexibilidade na hora de expressar fun√ß√µes e equa√ß√µes para descrever as BRDFs, sendo muito comum o uso de sub√≠ndices num√©ricos. Na etapa de gera√ß√£o de c√≥digo, essa capacidade de distinguir identificadores com sub√≠ndices √© crucial, pois permite tratar sem√¢nticamente \textit{tokens} aparentemente iguais de maneira diferenciada. Por exemplo, embora o primeiro \textit{token} seja \( f \), \( f_1 \) e \( f_2 \) s√£o semanticamente distintos, permitindo uma distin√ß√£o precisa entre s√≠mbolos com o mesmo nome base, mas com significados diferentes devido aos seus √≠ndices.

Anteriormente
N
Anteriormente, na \autoref{lexer-subexpression}, foi comentado que o \textit{parser} √© capaz de lidar com identificadores aninhados, como, por exemplo, \( x_{i_1} \) (\verb"x_{i_1}"). No \autoref{cod-expression-ident-recursive}, apresentamos como esses identificadores s√£o criados recursivamente. O c√≥digo mostrado faz parte de uma fun√ß√£o maior, sendo um recorte de um \texttt{switch}\footnote{\texttt{switch} e \texttt{case} em Odin funcionam da mesma forma que na linguagem de programa√ß√£o \texttt{C}} sobre a enumera√ß√£o descrita no \autoref{enum-token-kind}. Dentro desse \texttt{switch}, temos um \texttt{case} que reconhece \textit{tokens} de identificador ou s√≠mbolos especiais (\( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \)). Ao fazer uma chamada recursiva √† fun√ß√£o \texttt{parse\_expr}, o \textit{parser} permite a inclus√£o de sub√≠ndices num√©ricos, subexpres√µes de identificadores ou at√© express√µes bin√°rias, como \( n+1 \) em \( f_{n+1} \).

Isso confere maior flexibilidade na hora de expressar fun√ß√µes e equa√ß√µes para descrever as BRDFs, sendo muito comum o uso de sub√≠ndices num√©ricos. Na etapa de gera√ß√£o de c√≥digo, essa capacidade de distinguir identificadores com sub√≠ndices √© crucial, pois permite tratar sem√¢nticamente \textit{tokens} aparentemente iguais de maneira diferenciada. Por exemplo, embora o primeiro \textit{token} seja \( f \), \( f_1 \) e \( f_2 \) s√£o semanticamente distintos, permitindo uma distin√ß√£o precisa entre s√≠mbolos com o mesmo nome base, mas com significados diferentes devido aos seus √≠ndices.

O \autoref{cod-expression-ident-recursive}, j√° apresentado, serve como exemplo para outras express√µes recursivas, como express√µes infixas (opera√ß√µes bin√°rias). Para identificar o \textit{token} atual, utilizamos a fun√ß√£o \texttt{peek()}, que permite visualizar um ou dois \textit{tokens} √† frente e, com isso, decidir qual n√≥ da AST (√Årvore de Sintaxe Abstrata) deve ser constru√≠do. Ap√≥s identificar o token, calculamos a vari√°vel \texttt{prec}, que indica a preced√™ncia do \textit{token} atual. Com base nessa preced√™ncia, fazemos uma ou mais chamadas recursivas √† fun√ß√£o \texttt{parse\_expr} para processar os campos que requerem express√µes aninhadas.

Uma vez que todos os campos necess√°rios estejam preenchidos, a express√£o completa √© retornada. Esse processo √© repetido at√© que a sub√°rvore de express√µes de uma dada equa√ß√£o esteja completamente constru√≠da. A an√°lise sint√°tica √© conclu√≠da quando todas as equa√ß√µes forem adicionadas √† AST. Essa estrutura hier√°rquica das express√µes √© ent√£o anotada com tipos e validada pelo pacote \texttt{checker}, conforme discutido na \autoref{secion-checker}.

No entanto, antes que a valida√ß√£o ocorra, √© necess√°rio implementar m√©todos para realizar a travessia dessa estrutura. O processo de travessia da AST √© discutido na se√ß√£o \autoref{secion-walker}, onde s√£o apresentadas as t√©cnicas para percorrer a √°rvore e acessar os dados nela contidos, facilitando a an√°lise sem√¢ntica e a gera√ß√£o de c√≥digo subsequente.

necess√°rio
essencial
%%%%%

O \autoref{cod-expression-ident-recursive}, j√° apresentado, serve como exemplo para outras express√µes recursivas, como express√µes infixas (opera√ß√µes bin√°rias). Para identificar o \textit{token} atual, utilizamos a fun√ß√£o \texttt{peek()}, que permite visualizar um ou dois \textit{tokens} √† frente e, com isso, decidir qual n√≥ da AST (√Årvore de Sintaxe Abstrata) deve ser constru√≠do. Ap√≥s identificar o token, calculamos a vari√°vel \texttt{prec}, que indica a preced√™ncia do \textit{token} atual. Com base nessa preced√™ncia, fazemos uma ou mais chamadas recursivas √† fun√ß√£o \texttt{parse\_expr} para processar os campos que requerem express√µes aninhadas.

Uma vez que todos os campos necess√°rios estejam preenchidos, a express√£o completa √© retornada. Esse processo √© repetido at√© que a sub√°rvore de express√µes de uma dada equa√ß√£o esteja completamente constru√≠da. A an√°lise sint√°tica √© conclu√≠da quando todas as equa√ß√µes forem adicionadas √† AST. Essa estrutura hier√°rquica das express√µes √© ent√£o anotada com tipos e validada pelo pacote \texttt{checker}, conforme discutido na \autoref{secion-checker}.

No entanto, antes que a valida√ß√£o ocorra, √© necess√°rio implementar m√©todos para realizar a travessia dessa estrutura. O processo de travessia da AST √© discutido na se√ß√£o \autoref{secion-walker}, onde s√£o apresentadas as t√©cnicas para percorrer a √°rvore e acessar os dados nela contidos, facilitando a an√°lise sem√¢ntica e a gera√ß√£o de c√≥digo subsequente.




\label{section-checker}
secion-checker
 Essa abordagem permite que a l√≥gica de manipula√ß√£o da AST seja flex√≠vel e extens√≠vel
e
subsection-svg
SVG
√©
a
A estrutura \texttt{Visitor} (\autoref{cod-visitor-struct}) encapsula uma fun√ß√£o de visita polim√≥rfica (\texttt{visit}) que pode ser invocada em cada n√≥ da AST. A fun√ß√£o \texttt{visit} pode ser definida nessa estrutura para realizar opera√ß√µes transforma√ß√£o de n√≥s, como mudar o campo \texttt{ty\_inferred} do n√≥ do tipo \texttt{Expr}; tamb√©m √© permitido remo√ß√£o ou adici√ß√£o de n√≥s. Al√©m disso, a estrutura permite que o visitante mantenha um estado interno (\texttt{data}), que pode ser modificado dinamicamente durante a travessia. Como exemplo, esse estado √© usado para manter um inteiro indicando a profundidade atual para gerar um arquivo no formato SVG da arv√≥res (\autoref{subsection-svg}), ou uma lista de indentificadores usados para fazer resolu√ß√£o de simbolos pelo pacote \texttt{checker}, entre outros usos.

A estrutura \texttt{Visitor} (\autoref{cod-visitor-struct}) encapsula uma fun√ß√£o de visita polim√≥rfica (\texttt{visit}) que pode ser invocada em cada n√≥ da AST. A fun√ß√£o \texttt{visit} pode ser definida nessa estrutura para realizar opera√ß√µes transforma√ß√£o de n√≥s, como mudar o campo \texttt{ty\_inferred} do n√≥ do tipo \texttt{Expr}; tamb√©m √© permitido remo√ß√£o ou adici√ß√£o de n√≥s. Al√©m disso, a estrutura permite que o visitante mantenha um estado interno (\texttt{data}), que pode ser modificado dinamicamente durante a travessia. Como exemplo, esse estado √© usado para manter um inteiro indicando a profundidade atual para gerar um arquivo no formato SVG da arv√≥res (\autoref{subsection-svg}), ou uma lista de indentificadores usados para fazer resolu√ß√£o de simbolos pelo pacote \texttt{checker}, entre outros usos.

%%%

% A estrutura \texttt{Visitor} (\autoref{cod-visitor-struct}) encapsula uma fun√ß√£o de visita polim√≥rfica que pode ser chamada para cada tipo de n√≥, possibilitando um processamento flex√≠vel e extens√≠vel, onde o visitante pode modificar seu pr√≥prio estado durante a travessia, decidir continuar ou interromper o caminhamento, e realizar opera√ß√µes arbitr√°rias como transforma√ß√£o, an√°lise sem√¢ntica, gera√ß√£o de c√≥digo ou depura√ß√£o.



\begin{itemize}

\begin{enumerate}

item 
O controle de parada em \texttt{walk} √© essencial para evitar chamadas recursivas desnecess√°rias ou opera√ß√µes em n√≥s inv√°lidos. Este controle √© realizado por meio de duas verifica√ß√µes principais

A fun√ß√£o \texttt{walk} (\autoref{cod-visitor-walk}) implementa a travessia profunda (\textit{depth-first}) da AST usando as estrutura genericas de visitar. Essa fun√ß√£o percorre todos os n√≥s, incluindo declara√ß√µes, express√µes e equa√ß√µes e defini√ß√£o de fun√ß√µes, aplicando a fun√ß√£o \texttt{visit} antes e depois de explorar cada sub√°rvore. Isso √© especialmente √∫til para criar \textit{visitors} personalizados para tarefas como:

\begin{itemize}
    \item Checagem de tipos: Verifica a consist√™ncia dos tipos em diferentes n√≥s da √°rvore.
    \item Parentiza√ß√£o de express√µes: Modifica n√≥s para assegurar preced√™ncia correta de operadores.
    \item Gera√ß√£o de gr√°ficos: Produz uma representa√ß√£o visual em arquivo no formato SVG da AST.
    \item Gera√ß√£o de c√≥digo: Traduz a AST para uma linguagem GLSL.
\end{itemize}

% O controle de parada em \texttt{walk} √© essencial para evitar chamadas recursivas desnecess√°rias ou opera√ß√µes em n√≥s inv√°lidos. Este controle √© realizado por meio de duas verifica√ß√µes principais

O controle de parada em \texttt{walk} √© realizado por meio de duas verifica√ß√µes principais:

\begin{enumerate}

    \item Verifica√ß√£o de nulidade: A fun√ß√£o verifica se o visitante (\texttt{v}) ou o n√≥ (\texttt{node}) atual s√£o nulos antes de proceder. Isso garante que a execu√ß√£o n√£o tente operar em dados inexistentes.

    \item Interrup√ß√£o de travessia: Ap√≥s cada chamada √† fun√ß√£o \texttt{visit}, verifica-se o retorno do visitante. Se for nulo, a travessia √© interrompida, permitindo que o \textit{visitor} decida dinamicamente se deseja continuar ou parar; adaptando-se a diferentes cen√°rios de an√°lise e manipula√ß√£o da AST.

\end{enumerate}


A fun√ß√£o \texttt{walk} (\autoref{cod-visitor-walk}) implementa a travessia profunda (\textit{depth-first}) da AST usando as estrutura genericas de visitar. Essa fun√ß√£o percorre todos os n√≥s, incluindo declara√ß√µes, express√µes e equa√ß√µes e defini√ß√£o de fun√ß√µes, aplicando a fun√ß√£o \texttt{visit} antes e depois de explorar cada sub√°rvore. Isso √© especialmente √∫til para criar \textit{visitors} personalizados para tarefas como:

\begin{itemize}
    \item Checagem de tipos: Verifica a consist√™ncia dos tipos em diferentes n√≥s da √°rvore.
    \item Parentiza√ß√£o de express√µes: Modifica n√≥s para assegurar preced√™ncia correta de operadores.
    \item Gera√ß√£o de gr√°ficos: Produz uma representa√ß√£o visual em arquivo no formato SVG da AST.
    \item Gera√ß√£o de c√≥digo: Traduz a AST para uma linguagem GLSL.
\end{itemize}

%%%%%%%

% O controle de parada em \texttt{walk} √© essencial para evitar chamadas recursivas desnecess√°rias ou opera√ß√µes em n√≥s inv√°lidos. Este controle √© realizado por meio de duas verifica√ß√µes principais



,
O controle de parada em \texttt{walk} √© realizado por meio de duas verifica√ß√µes principais:

\begin{enumerate}

    \item Verifica√ß√£o de nulidade: A fun√ß√£o verifica se o visitante (\texttt{v}) ou o n√≥ (\texttt{node}) atual s√£o nulos antes de proceder. Isso garante que a execu√ß√£o n√£o tente operar em dados inexistentes.

    \item Interrup√ß√£o de travessia: Ap√≥s cada chamada √† fun√ß√£o \texttt{visit}, verifica-se o retorno do visitante. Se for nulo, a travessia √© interrompida, permitindo que o \textit{visitor} decida dinamicamente se deseja continuar ou parar; adaptando-se a diferentes cen√°rios de an√°lise e manipula√ß√£o da AST.

\end{enumerate}





\begin{codigo}[!ht]
    \caption{\small Estrutura polim√≥rfica \texttt{Visitor}}
        \label{cod-visitor-struct}
\begin{lstlisting}[language = C]

// Estrutura polim√≥rfica, aceita um tipo qualquer, chamado de DataType, como estrada para criar um tipo concreto.
Visitor :: struct (DataType: typeid) {
    visit: proc(visitor: ^Visitor(DataType), node: ^ast.Node) -> ^Visitor(DataType),
    data:  DataType,
}
\end{lstlisting}
\end{codigo}

Utilizamos o pacote \texttt{walker} para validar a preced√™ncia dos operadores na AST gerada pelo \texttt{parser}. A fun√ß√£o de parentiza√ß√£o implementa a inser√ß√£o de par√™nteses para capturar a preced√™ncia original das express√µes da AST. Dessa forma, a representa√ß√£o textual resultante reflete corretamente a ordem de avalia√ß√£o das express√µes matem√°ticas.

Durante a travessia da AST, o algoritmo processa todos os tipos de express√µes, como prefixas, bin√°rias e chamadas de fun√ß√£o, inserindo par√™nteses sempre que necess√°rio. Isso garante que a hierarquia das opera√ß√µes seja explicitamente representada, permitindo verificar se a constru√ß√£o da AST durante o parsing respeitou corretamente as regras de preced√™ncia matem√°ticas.

Os testes de preced√™ncia consistem em comparar o texto original de uma express√£o com sua vers√£o esperada, na qual os par√™nteses refletem a ordem de avalia√ß√£o correta (\autoref{cod-test-paren}). Casos mais complexos, como a combina√ß√£o de operadores associativos √† direita (como a exponencia√ß√£o) com operadores de diferentes preced√™ncias, s√£o inclu√≠dos para abranger cen√°rios que envolvem todas as opera√ß√µes aritm√©ticas suportadas. Al√©m disso, as express√µes podem conter sub-express√µes aninhadas, chamadas de fun√ß√µes e express√µes como par√¢metros na defini√ß√£o de fun√ß√µes.

√Ä medida que o compilador foi sendo desenvolvido, esses testes se mostraram √∫teis para evitar regress√µes. Sempre que uma nova funcionalidade era adicionada, os testes garantiam que funcionalidades j√° existentes n√£o fossem quebradas.


%%%%

√Ä medida que o compilador foi sendo desenvolvido, esses testes se mostraram √∫teis para evitar regress√µes. Sempre que uma nova funcionalidade era adicionada, os testes garantiam que funcionalidades j√° existentes n√£o fossem quebradas.

√Ä medida que o compilador foi sendo desenvolvido, esses testes se mostraram √∫teis para evitar regress√µes. Sempre que uma nova funcionalidade era adicionada, os testes garantiam que funcionalidades j√° existentes n√£o fossem quebradas.

n√£o fossem quebradas
permanecessem intactas
√Ä medida que o compilador foi sendo desenvolvido, esses testes se mostraram √∫teis para evitar regress√µes. Sempre que uma nova funcionalidade era adicionada, os testes garantiam que funcionalidades j√° existentes n√£o fossem quebradas.

Esses testes foram essenciais para evitar regress√µes durante o desenvolvimento do compilador, garantindo que novas funcionalidades n√£o quebrem as existentes.



Durante a travessia da AST, o algoritmo processa todos os tipos de express√µes, adicionando par√™nteses quando necess√°rio.
processa todos os tipos de express√µes
quando necess√°rio
implita
(sem parentiza)
A fun√ß√µes e esturura de traversia foram usadas para validar a preced√™ncia dos operadores na AST gerada pelo \texttt{parser}. A fun√ß√£o de parentiza√ß√£o processa todos os tipos de express√µes na traversia da AST e insere par√™nteses nas express√µes para preservar a  preced√™ncia implita original(sem parentizas). garantindo que a representa√ß√£o textual reflita corretamente a ordem de avalia√ß√£o das opera√ß√µes matem√°ticas. Isso assegura que a hierarquia das opera√ß√µes seja explicitamente representada e que as regras de preced√™ncia sejam respeitadas no parsing.

√†
A fun√ß√µes e esturura de traversia foram usadas para validar a preced√™ncia dos operadores na AST gerada pelo \texttt{parser}. A fun√ß√£o de parentiza√ß√£o processa todos os tipos de express√µes na traversia da AST e insere par√™nteses nas express√µes para preservar a  preced√™ncia implita original(sem parentizas). garantindo que a representa√ß√£o textual reflita corretamente a ordem de avalia√ß√£o das opera√ß√µes matem√°ticas. Isso assegura que a hierarquia das opera√ß√µes seja explicitamente representada e que as regras de preced√™ncia sejam respeitadas no parsing.





%%%%%%%%%%%%%%

Utilizamos o pacote \texttt{walker} para validar a preced√™ncia dos operadores na AST gerada pelo \texttt{parser}. A fun√ß√£o de parentiza√ß√£o implementa a inser√ß√£o de par√™nteses para capturar a preced√™ncia original das express√µes da AST. Dessa forma, a representa√ß√£o textual resultante reflete corretamente a ordem de avalia√ß√£o das express√µes matem√°ticas.

Durante a travessia da AST, o algoritmo processa todos os tipos de express√µes, como prefixas, bin√°rias e chamadas de fun√ß√£o, inserindo par√™nteses sempre que necess√°rio. Isso garante que a hierarquia das opera√ß√µes seja explicitamente representada, permitindo verificar se a constru√ß√£o da AST durante o parsing respeitou corretamente as regras de preced√™ncia matem√°ticas.

Os testes de preced√™ncia consistem em comparar o texto original de uma express√£o com sua vers√£o esperada, na qual os par√™nteses refletem a ordem de avalia√ß√£o correta (\autoref{cod-test-paren}). Casos mais complexos, como a combina√ß√£o de operadores associativos √† direita (como a exponencia√ß√£o) com operadores de diferentes preced√™ncias, s√£o inclu√≠dos para abranger cen√°rios que envolvem todas as opera√ß√µes aritm√©ticas suportadas. Al√©m disso, as express√µes podem conter sub-express√µes aninhadas, chamadas de fun√ß√µes e express√µes como par√¢metros na defini√ß√£o de fun√ß√µes.






%%%%





        % \includegraphics[width=\textwidth, scale=1.1]{./Imagens/svg.png}
        % \includegraphics[scale=0.9]{./Imagens/svg.png}

        \includegraphics[scale=0.65]{./Imagens/svg.pdf} % Best outta of them all, because it gets to indefinitely zoom in
        % \includesvg[scale=0.9]{./Imagens/svg.svg}

        % Best outta of them all, because it gets to indefinitely zoom in
        % \includesvg[scale=0.9]{./Imagens/svg.svg}

5
Al√©m disso, √© poss√≠vel remover ou adicionar n√≥s. A estrutura tamb√©m permite que o visitante mantenha um estado interno (\texttt{data}), que pode ser alterado dinamicamente durante a travessia. Um exemplo de uso desse estado √© o acompanhamento da profundidade atual para gerar um arquivo SVG da √°rvore (\autoref{subsection-svg}), ou a manuten√ß√£o de uma lista de identificadores usados para a resolu√ß√£o de s√≠mbolos pelo pacote \texttt{checker}, entre outros.

subsection-svg
\texttt{Visitor}
Visitor
remover ou adicionar
remover ou adicionar n√≥s. 
.
.
remover ou adicionar n√≥s;
.
√†
 
        // ...
        // casos OMITIDOS aqui Tamb√©m
        // ...

        case ^Decl_Equation:
            walk(v, n.field)


        // ...

        // ...



        // ...

H
- Remova abordagem

H
"
\begin{codigo}[!h]
    \caption{\small Valida√ß√£o de precendencia por parentiza√ß√£o de express√µes. }
        \label{cod-test-paren}
  \begin{lstlisting}[language = C]
    test_paren(
        "a = 1+2", // Entrada
        "a=(1+2)"  // Sa√≠da Esperada
    );

    test_paren(
        "a = \exp 1 + 2^3", // Entrada
        "a=(\exp(1)+(2^3))" // Sa√≠da Esperada
    );

    // ...
    // Outros Testes
    // ...

    test_paren(
        "a = a(1*2 ^ 4 +  \sqrt 4^8 , 2)", // Entrada
        "a=a(((1*(2^4))+(\sqrt(4)^8)),2)"  // Sa√≠da Esperada
    );
  \end{lstlisting}
\end{codigo}

Para valida√ß√£o visual, foi implementado uma fun√ß√£o que gera uma imagem da AST no formato SVG, que √© textual e f√°cil de manipular. Cada n√≥ da AST √© representado por um retangulo com textos associados que fornecem informa√ß√µes, como o tipo de operador, o tipo do n√≥ e a string do identificador, se aplicavel. Anteriormente, utiliz√°vamos a fun√ß√£o \texttt{print\_ast}, que imprimia os n√≥s e seus atributos com indenta√ß√£o correspondente √† profundidade. Essa abordagem se tornou limitada √† medida que a AST crescia em complexidade, demandando uma solu√ß√£o mais robusta para depura√ß√£o.

Na \autoref{fig-svg}, apresentamos a visualiza√ß√£o gerada para a equa√ß√£o \autoref{eq-svg}. Observamos que os n√≥s de opera√ß√µes bin√°rias, como \texttt{+} e \texttt{-}, localizados pr√≥ximos √† raiz, s√£o avaliados posteriormente, enquanto os n√≥s mais pr√≥ximos das folhas, como \texttt{*} e \texttt{\^}, t√™m maior preced√™ncia e s√£o resolvidos primeiro. Al√©m disso, o SVG inclui informa√ß√µes adicionais, como o tipo das express√µes. Por exemplo, o identificador \( f \) √© anotado como pertencente ao tipo \( \mathbb{R} \), o que √© determinado na etapa de valida√ß√£o sem√¢ntica (\texttt{checker}), como ser√° discutido posteriormente.

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

Os n√≥s da AST s√£o heterog√™neos, e o modo de acessar seus filhos varia conforme o tipo do n√≥, j√° que os campos podem ter nomes ou posi√ß√µes diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma fun√ß√£o chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferen√ßas entre os tipos de n√≥s e retorna, para qualquer n√≥, uma lista uniforme de seus filhos.
Essa fun√ß√£o simplifica o c√≥digo de gera√ß√£o do SVG, permitindo que a fun√ß√£o opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de n√≥ individualmente.

h
Para valida√ß√£o visual, foi implementado uma fun√ß√£o que gera uma imagem da AST no formato SVG, que √© textual e f√°cil de manipular. Cada n√≥ da AST √© representado por um retangulo com textos associados que fornecem informa√ß√µes, como o tipo de operador, o tipo do n√≥ e a string do identificador, se aplicavel. Anteriormente, utiliz√°vamos a fun√ß√£o \texttt{print\_ast}, que imprimia os n√≥s e seus atributos com indenta√ß√£o correspondente √† profundidade. Essa abordagem se tornou limitada √† medida que a AST crescia em complexidade, demandando uma solu√ß√£o mais robusta para depura√ß√£o.

Na \autoref{fig-svg}, apresentamos a visualiza√ß√£o gerada para a equa√ß√£o \autoref{eq-svg}. Observamos que os n√≥s de opera√ß√µes bin√°rias, como \texttt{+} e \texttt{-}, localizados pr√≥ximos √† raiz, s√£o avaliados posteriormente, enquanto os n√≥s mais pr√≥ximos das folhas, como \texttt{*} e \texttt{\^}, t√™m maior preced√™ncia e s√£o resolvidos primeiro. Al√©m disso, o SVG inclui informa√ß√µes adicionais, como o tipo das express√µes. Por exemplo, o identificador \( f \) √© anotado como pertencente ao tipo \( \mathbb{R} \), o que √© determinado na etapa de valida√ß√£o sem√¢ntica (\texttt{checker}), como ser√° discutido posteriormente.

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

Os n√≥s da AST s√£o heterog√™neos, e o modo de acessar seus filhos varia conforme o tipo do n√≥, j√° que os campos podem ter nomes ou posi√ß√µes diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma fun√ß√£o chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferen√ßas entre os tipos de n√≥s e retorna, para qualquer n√≥, uma lista uniforme de seus filhos.
Essa fun√ß√£o simplifica o c√≥digo de gera√ß√£o do SVG, permitindo que a fun√ß√£o opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de n√≥ individualmente.

Os n√≥s da AST s√£o heterog√™neos, e o modo de acessar seus filhos varia conforme o tipo do n√≥, j√° que os campos podem ter nomes ou posi√ß√µes diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma fun√ß√£o chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferen√ßas entre os tipos de n√≥s e retorna, para qualquer n√≥, uma lista uniforme de seus filhos.
Essa fun√ß√£o simplifica o c√≥digo de gera√ß√£o do SVG, permitindo que a fun√ß√£o opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de n√≥ individualmente.

%%
Para valida√ß√£o visual, foi implementado uma fun√ß√£o que gera uma imagem da AST no formato SVG, que √© textual e f√°cil de manipular. Cada n√≥ da AST √© representado por um retangulo com textos associados que fornecem informa√ß√µes, como o tipo de operador, o tipo do n√≥ e a string do identificador, se aplicavel. Anteriormente, utiliz√°vamos a fun√ß√£o \texttt{print\_ast}, que imprimia os n√≥s e seus atributos com indenta√ß√£o correspondente √† profundidade. Essa abordagem se tornou limitada √† medida que a AST crescia em complexidade, demandando uma solu√ß√£o mais robusta para depura√ß√£o.

Na \autoref{fig-svg}, apresentamos a visualiza√ß√£o gerada para a equa√ß√£o \autoref{eq-svg}. Observamos que os n√≥s de opera√ß√µes bin√°rias, como \texttt{+} e \texttt{-}, localizados pr√≥ximos √† raiz, s√£o avaliados posteriormente, enquanto os n√≥s mais pr√≥ximos das folhas, como \texttt{*} e \texttt{\^}, t√™m maior preced√™ncia e s√£o resolvidos primeiro. Al√©m disso, o SVG inclui informa√ß√µes adicionais, como o tipo das express√µes. Por exemplo, o identificador \( f \) √© anotado como pertencente ao tipo \( \mathbb{R} \), o que √© determinado na etapa de valida√ß√£o sem√¢ntica (\texttt{checker}), como ser√° discutido posteriormente.

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

Os n√≥s da AST s√£o heterog√™neos, e o modo de acessar seus filhos varia conforme o tipo do n√≥, j√° que os campos podem ter nomes ou posi√ß√µes diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma fun√ß√£o chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferen√ßas entre os tipos de n√≥s e retorna, para qualquer n√≥, uma lista uniforme de seus filhos.
Essa fun√ß√£o simplifica o c√≥digo de gera√ß√£o do SVG, permitindo que a fun√ß√£o opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de n√≥ individualmente.

%%
Para valida√ß√£o visual, foi implementado uma fun√ß√£o que gera uma imagem da AST no formato SVG, que √© textual e f√°cil de manipular. Cada n√≥ da AST √© representado por um retangulo com textos associados que fornecem informa√ß√µes, como o tipo de operador, o tipo do n√≥ e a string do identificador, se aplicavel. Anteriormente, utiliz√°vamos a fun√ß√£o \texttt{print\_ast}, que imprimia os n√≥s e seus atributos com indenta√ß√£o correspondente √† profundidade. Essa abordagem se tornou limitada √† medida que a AST crescia em complexidade, demandando uma solu√ß√£o mais robusta para depura√ß√£o.

Na \autoref{fig-svg}, apresentamos a visualiza√ß√£o gerada para a equa√ß√£o \autoref{eq-svg}. Observamos que os n√≥s de opera√ß√µes bin√°rias, como \texttt{+} e \texttt{-}, localizados pr√≥ximos √† raiz, s√£o avaliados posteriormente, enquanto os n√≥s mais pr√≥ximos das folhas, como \texttt{*} e \texttt{\^}, t√™m maior preced√™ncia e s√£o resolvidos primeiro. Al√©m disso, o SVG inclui informa√ß√µes adicionais, como o tipo das express√µes. Por exemplo, o identificador \( f \) √© anotado como pertencente ao tipo \( \mathbb{R} \), o que √© determinado na etapa de valida√ß√£o sem√¢ntica (\texttt{checker}), como ser√° discutido posteriormente.

\begin{equation} \label{eq-svg}
   f =  1*2 ^ 4 +  \sqrt 4^8
\end{equation}

Os n√≥s da AST s√£o heterog√™neos, e o modo de acessar seus filhos varia conforme o tipo do n√≥, j√° que os campos podem ter nomes ou posi√ß√µes diferentes nas estruturas. Para lidar com essa heterogeneidade, o pacote \texttt{walker} oferece uma fun√ß√£o chamada \texttt{children} (\autoref{cod-childre-signature}), que abstrai as diferen√ßas entre os tipos de n√≥s e retorna, para qualquer n√≥, uma lista uniforme de seus filhos.
Essa fun√ß√£o simplifica o c√≥digo de gera√ß√£o do SVG, permitindo que a fun√ß√£o opere sobre a AST de maneira uniforme, sem a necessidade de tratar cada tipo de n√≥ individualmente.




\texttt{\^}
tab-conventions
tabela-variaveis
a
,
,
Al√©m disso, vari√°veis como a normal \( \vec{n} \) s√£o frequentemente fornecidas como entrada para o \textit{shader} de fragmentos ou declaradas como vari√°veis uniformes. Por isso, elas n√£o est√£o explicitamente definidas na fun√ß√£o \texttt{cook\_torrance} do \autoref{cod-glsl-esperado}, sendo consideradas vari√°veis impl√≠citas. Uma lista completa dessas vari√°veis impl√≠citas podem ser encontrada no mapeamento de conve√ß√µes para c√≥digo GLSL na \autoref{tab-conventions}.

    Por isso, elas n√£o est√£o explicitamente definidas na fun√ß√£o \texttt{cook\_torrance} do \autoref{cod-glsl-esperado}, sendo consideradas vari√°veis impl√≠citas. Uma lista completa dessas vari√°veis impl√≠citas podem ser encontrada no mapeamento de conve√ß√µes para c√≥digo GLSL na \autoref{tab-conventions}.

e atenda aos requisitos do pipeline gr√°fic
e atenda aos requisitos do pipeline gr√°fico
e
o
a
Conclu√≠mos que os experimentos realizados t√™m resultados satisfat√≥rios. O compilador desenvolvido demonstra flexibilidade ao capturar nuances das diferentes BRDFs, inclusive em materiais com estruturas complexas. O sistema permite diversas parametriza√ß√µes e equa√ß√µes alteranivas para representar comportamentos da superf√≠cie.

Os resultados obtidos n√£o apenas validam a abordagem metodol√≥gica adotada, mas tamb√©m abrem perspectivas para futuras extens√µes e refinamentos da ferramenta. Ap√≥s o √∫ltimo experimento, passamos diretamente para o cap√≠tulo de conclus√£o (\autoref{chapter-conclusion}), onde √© discutido as potenciais dire√ß√µes deste trabalho.

passamos

Os resultados obtidos n√£o apenas validam a abordagem metodol√≥gica adotada, mas tamb√©m abrem perspectivas para futuras extens√µes e refinamentos da ferramenta. Ap√≥s o √∫ltimo experimento, passamos diretamente para o cap√≠tulo de conclus√£o (\autoref{chapter-conclusion}), onde √© discutido as potenciais dire√ß√µes deste trabalho.

Conclu√≠mos que os experimentos realizados t√™m resultados satisfat√≥rios. O compilador desenvolvido demonstra flexibilidade ao capturar nuances das diferentes BRDFs, inclusive em materiais com estruturas complexas. O sistema permite diversas parametriza√ß√µes e equa√ß√µes alteranivas para representar comportamentos da superf√≠cie.



Al√©m disso, foi implementada uma etapa de an√°lise sem√¢ntica por meio do pacote chamado \texttt{checker}. Essa etapa √© criar os escopos e tabela de simbolo e anotar a AST com informa√ß√µes como o tipos de dados dos n√≥s, incluindo fun√ß√µes com seus dom√≠nios e contradom√≠nios, vetores reais e suas dimens√µes, ou n√∫meros reais.

Al√©m disso, foi implementada uma etapa de an√°lise sem√¢ntica por meio do pacote chamado \texttt{checker}. Essa etapa √© criar os escopos e tabela de simbolo e anotar a AST com informa√ß√µes como o tipos de dados dos n√≥s, incluindo fun√ß√µes com seus dom√≠nios e contradom√≠nios, vetores reais e suas dimens√µes, ou n√∫meros reais.

m
a
a

Ainda, definimos s√≠mbolos operadores: ``$*$'' indica zero ou mais ocorr√™ncias; ``$()$'' indica agrupamento para aplicar um operador ao mesmo; ``$|$'' simboliza o in√≠cio de uma regra alternativa para o mesmo n√£o-terminal, ou se estiver dentro de um agrupamento, como por exemplo``$(a|b)$'', significa que aceita $a$ ou $b$; e ``$=$'' indica uma produ√ß√£o. Essa mesmta sintaxe de gram√°tica √© utilizada na an√°lise sint√°tica, onde cada regra √© faz bije√ß√£o com os tipos de n√≥ da AST, como detalhado na \autoref{section-parser}. Na etapa de an√°lise sint√°tica, √© usada a mesma sintaxed para a gramatica, mas alfabeto passa a ser composto pelo conjunto de \textit{tokens} gerados pelo \texttt
[
a
a
a
a
a
A estrutura \texttt{Position}, detalhada na \autoref{lexer-structs}
, uma funcionalidade essencial para a gera√ß√£o de relat√≥rios de erro
Durante a itera√ß√£o sobre o \texttt{input}, o processo de tokeniza√ß√£o mant√©m algumas vari√°veis de controle para monitorar o estado do fluxo de caracteres. Quebras de linha s√£o contadas ao encontrar sequ√™ncias como \verb|"\n"| ou \verb|"\n\r"|. √â mantida a coluna atual que rastreia a posi√ß√£o horizontal do caractere em uma linha. O cursor √© o √≠ndice que aponta para o caractere atualmente em processamento. Essas informa√ß√µes s√£o usadas para preencher o campo \texttt{position} de cada \textit{token}. A estrutura \texttt{Position}, detalhada na \autoref{lexer-structs}, √© essencial para garantir a precis√£o no rastreamento de problemas e gera√ß√£o de relat√≥rios de erro.

A estrutura \texttt{Position}, detalhada na \autoref{lexer-structs}, √© essencial para garantir a precis√£o no rastreamento de problemas e gera√ß√£o de relat√≥rios de erro.

gera√ß√£o
LogicalOrExpr
LogicalOrExpr
PrimaryExpr
PrimaryExpr
PrimaryExpr
PrimaryExpr
Express√µes prim√°rias


expr;   ---  Igualdade
      |
relational_expr
relational_expr
rel_expr
         
        
        
        
       
       
       
   
 --- regra de identifier est√° omitida
       
      
    
 |
| rel_expr;   ---  Igualdade
  
  
   
      
---  Compara√ß√£o
---  Igualdade
    --- regra de identifier est√° omitida

Para formalizar a gram√°tica da linguagem de entrada (\texttt{EquationLang}), t√™m suas regras detalhadas nos \autoref{grammar-ast-pt1} e \autoref{grammar-ast-pt2}. √â apresentado um exemplo de c√≥digo-fonte de tr√™s equa√ß√µes v√°lidas nesta linguagem no \autoref{code-gramatica}, cuja renderiza√ß√£o correspondente em \LaTeX{} √© ilustrada em \autoref{code-gramatica-rendered}. Nesse exemplo, a primeira equa√ß√£o ($\rho_{d}$) √© gerado pela regra \verb"expr_vector_literal". A segunda ($\rho_{s}$), √© uma express√£o bin√°rio derivada pela regra \verb"expr_infix". J√° a √∫ltima representa uma equa√ß√£o que necessitou de mais regras como \verb"expr_grouped" e \verb"expr_prefix".

Conclu√≠mos que os experimentos realizados apresentaram resultados satisfat√≥rios. O compilador desenvolvido demonstra flexibilidade ao capturar as nuances das diferentes BRDFs, inclusive em materiais com estruturas complexas. O sistema permite diversas parametriza√ß√µes e equa√ß√µes alternativas para representar os comportamentos da superf√≠cie.



Os resultados obtidos n√£o apenas validam a abordagem metodol√≥gica adotada, mas tamb√©m abrem perspectivas para futuras extens√µes e refinamentos da ferramenta. Ap√≥s o √∫ltimo experimento, seguimos diretamente para o cap√≠tulo de conclus√£o (\autoref{chapter-conclusion}), onde s√£o discutidas as poss√≠veis dire√ß√µes para a continuidade deste trabalho.

Nesse exemplo, a primeira equa√ß√£o (
ùúå
ùëë
œÅ 
d
‚Äã
 ) √© gerada pela regra \verb"expr_vector_literal". A segunda (
ùúå
ùë†
œÅ 
s
‚Äã
 ) √© uma express√£o bin√°ria derivada da regra \verb"expr_infix". J√° a √∫ltima equa√ß√£o utiliza m√∫ltiplas regras, como \verb"expr_grouped" e \verb"expr_prefix".

√© uma express√£o bin√°rio derivada pela regra \verb"expr_infix". J√° a √∫ltima representa uma equa√ß√£o que necessitou de mais regras como \verb"expr_grouped" e \verb"expr_prefix".

A gram√°tica definida nesta se√ß√£o abrange regras para express√µes, atribui√ß√µes, agrupamento, literais num√©ricos e vetores, chamadas de fun√ß√µes, defini√ß√µes de fun√ß√µes e diversos operadores, como \texttt{expr\_prefix} e \texttt{expr\_infix}. O objetivo √© fornecer uma linguagem capaz de expressar a sintaxe necess√°ria para defini√ß√µes de BRDFs em \LaTeX{}. 

A tabela de operadores (\autoref{tab-token-precedence}) usada no Pratt Parsing √© representada pela fun√ß√£o \texttt{precedence\_from\_token}, que mapeia um \textit{token} para um valor inteiro que representa sua preced√™ncia: quanto maior o valor, maior a preced√™ncia do operador. √â importante observar que alguns \textit{tokens} podem ser usados tanto como prefixos quanto como infixos, dependendo do contexto. Por exemplo, o \textit{token} \texttt{(} pode ser um prefixo em uma express√£o de agrupamento, como em \textbf{(}$2*3$\textbf{)}, mas tamb√©m pode ser infixo em uma chamada de fun√ß√£o, como em $f$\textbf{(}$x$\textbf{)}. O mesmo comportamento ocorre com o \textit{token} \texttt{-}, que pode atuar como operador prefixo de nega√ß√£o ou infixo para subtra√ß√£o.

A gram√°tica definida nesta se√ß√£o abrange regras para express√µes, atribui√ß√µes, agrupamento, literais num√©ricos e vetores, chamadas de fun√ß√µes, defini√ß√µes de fun√ß√µes e diversos operadores, como \texttt{expr\_prefix} e \texttt{expr\_infix}. O objetivo √© fornecer uma linguagem capaz de expressar a sintaxe necess√°ria para defini√ß√µes de BRDFs em \LaTeX{}. 



$f$\textbf{(}$x$\textbf{)}
(
ùëì









H
"

    expr_identifier =
        --- Ex: `\text{id}`
        token_text token_opencurly expr_identifier token_closecurly
        --- Ex: `\vec{id}`
        token_vec token_opencurly expr_identifier token_closecurly
        --- Ex: `id_n`
        | expr_identifier token_underline expr_identifier
        --- Ex: `id_2`
        | expr_identifier token_underline token_number
        --- Ex: `id_{n+1}`
        | expr_identifier token_underline token_opencurly expr token_closecurly
        --- Token especiais como \phi ou \alpha
        | token_identifier
        | token_omega
        | token_theta   | token_phi
        | token_rho     | token_alpha
        | token_beta    | token_sigma
        | token_pi      | token_epsilon
        | token_max     | token_min
    ;



 % Adjust this value as needed


        lineskip=-1pt,

small
    expr_identifier =
        --- Ex: `\text{id}`
        token_text token_opencurly expr_identifier token_closecurly
        --- Ex: `\vec{id}`
        token_vec token_opencurly expr_identifier token_closecurly
        --- Ex: `id_n`
        | expr_identifier token_underline expr_identifier
        --- Ex: `id_2`
        | expr_identifier token_underline token_number
        --- Ex: `id_{n+1}`
        | expr_identifier token_underline token_opencurly expr token_closecurly
        --- Token especiais como \phi ou \alpha
        | token_identifier
        | token_omega
        | token_theta   | token_phi
        | token_rho     | token_alpha
        | token_beta    | token_sigma
        | token_pi      | token_epsilon
        | token_max     | token_min
    ;

basicstyle=\small
scriptsize
footnotesize
small
small
footnotesize
small




        




\begin{lstlisting}[language=haskell, basicstyle=\footnotesize, numbers=none, inputencoding=utf8]

basicstyle=\fontsize{10}{12}\selectfont
basicstyle=\footnotesize
\ttfamily\small,
\selectfont
    basicstyle=\ttfamily\small,

8
basicstyle=\ttfamily\footnotesize
\footnotesize
A tabela de operadores (\autoref{tab-token-precedence}), usada no Pratt Parsing, √© implementada pela fun√ß√£o \texttt{precedence\_from\_token}, que associa cada \textit{token} a um valor inteiro indicando sua preced√™ncia: valores maiores indicam maior prioridade. Alguns \textit{tokens} assumem diferentes fun√ß√µes conforme o contexto, e podem mudar suas precedencia. Por exemplo, \texttt{(} pode ser um prefixo em express√µes agrupadas, \textbf{(}$2*3$\textbf{)}, ou um infixo em chamadas de fun√ß√£o, $f$\textbf{(}$x$\textbf{)}. O mesmo vale para \texttt{-}, que pode atuar como operador de nega√ß√£o (prefixo) ou subtra√ß√£o (infixo).

    % basicstyle=\fontsize{6}{7.2}\selectfont\ttfamily

,
demonstrando a flexibilidade contextual dos \textit{tokens} no processo de parsing.
Alguns \textit{tokens} assumem diferentes fun√ß√µes conforme o contexto, e podem mudar suas precedencia. Por exemplo, \texttt{(} pode ser um prefixo em express√µes agrupadas, \textbf{(}$2*3$\textbf{)}, ou um infixo em chamadas de fun√ß√£o, $f$\textbf{(}$x$\textbf{)}. O mesmo vale para \texttt{-}, que pode atuar como operador de nega√ß√£o (prefixo) ou subtra√ß√£o (infixo).



% A tabela de operadores (\autoref{tab-token-precedence}) usada no Pratt Parsing √© representada pela fun√ß√£o \texttt{precedence\_from\_token}, que mapeia um \textit{token} para um valor inteiro que representa sua preced√™ncia: quanto maior o valor, maior a preced√™ncia do operador. √â importante observar que alguns \textit{tokens} podem ser usados tanto como prefixos quanto como infixos, dependendo do contexto. Por exemplo, o \textit{token} \texttt{(} pode ser um prefixo em uma express√£o de agrupamento, como em \textbf{(}$2*3$\textbf{)}, mas tamb√©m pode ser infixo em uma chamada de fun√ß√£o, como em . O mesmo comportamento ocorre com o \textit{token} \texttt{-}, que pode atuar como operador prefixo de nega√ß√£o ou infixo para subtra√ß√£o.



a
Nesta se√ß√£o, apresentamos os tipos de n√≥s que comp√µem a AST utilizada no compilador da linguagem \texttt{EquationLang}. Cada estrutura de n√≥ capturam os diferentes elementos da sintaxe da linguagem. Diferente da gram√°tica definida no \autoref{lst-gramatica}, os n√≥s aqui s√£o representados em n√≠vel de c√≥digo, e esses nomes ser√£o utilizados nas se√ß√µes posteriores para explicar o desenvolvimento.

√â importante destacar que o n√≥ \texttt{Expr}, sendo o mais gen√©rico, possui um campo adicional,\verb"ty_inferred", utilizado na etapa de an√°lise sem√¢ntica e na gera√ß√£o de c√≥digo. A seguir, apresentamos uma descri√ß√£o sem√¢ntica das principais estruturas de n√≥s da AST:


%%%
Nesta se√ß√£o, apresentamos os tipos de n√≥s que comp√µem a AST utilizada no compilador da linguagem \texttt{EquationLang}. Cada estrutura de n√≥ capturam os diferentes elementos da sintaxe da linguagem. Diferente da gram√°tica definida no \autoref{lst-gramatica}, os n√≥s aqui s√£o representados em n√≠vel de c√≥digo, e esses nomes ser√£o utilizados nas se√ß√µes posteriores para explicar o desenvolvimento.

√â importante destacar que o n√≥ \texttt{Expr}, sendo o mais gen√©rico, possui um campo adicional,\verb"ty_inferred", utilizado na etapa de an√°lise sem√¢ntica e na gera√ß√£o de c√≥digo. A seguir, apresentamos uma descri√ß√£o sem√¢ntica das principais estruturas de n√≥s da AST:

Anteriormente, na \autoref{lexer-subexpression}, discutiu-se que o \textit{parser} √© capaz de lidar com identificadores aninhados, como \( x_{i_1} \) (\verb"x_{i_1}"). Esse suporte √© demonstrado no c√≥digo apresentado na \autoref{cod-expression-ident-recursive}, que ilustra como identificadores desse tipo s√£o processados de forma recursiva. O trecho mostrado faz parte de uma fun√ß√£o maior e √© extra√≠do de um \texttt{switch}\footnote{Os comandos \texttt{switch} e \texttt{case} na linguagem Odin funcionam de forma semelhante aos da linguagem C.}, aplicado sobre a enumera√ß√£o descrita na \autoref{enum-token-kind}. Dentro desse \texttt{switch}, h√° um \texttt{case} espec√≠fico que reconhece \textit{tokens} de identificadores ou s√≠mbolos especiais, como \( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \).

A tabela de operadores (\autoref{tab-token-precedence}), usada no Pratt Parsing, √© implementada pela fun√ß√£o \texttt{precedence\_from\_token}, que associa cada \textit{token} a um valor inteiro indicando sua preced√™ncia: valores maiores indicam maior prioridade. 



o
e
Nesta se√ß√£o, √© apresentado os tipos de n√≥s que comp√µem a AST do compilador da linguagem \texttt{EquationLang}. Cada estrutura de n√≥ captura as diferentes regras de produ√ß√£o da sintaxe da linguagem em n√≠vel de c√≥digo, e esses nomes ser√£o utilizados nas se√ß√µes posteriores para explicar o desenvolvimento. √â importante destacar que o n√≥ \texttt{Expr}, sendo o mais gen√©rico, possui um campo importante, o \verb"ty_inferred", que representa o tipo da express√£o que √© preenchido pela an√°lise sem√¢ntica para uso na gera√ß√£o de c√≥digo.

Cada estrutura de n√≥ captura as diferentes regras de produ√ß√£o da sintaxe da linguagem em n√≠vel de c√≥digo
Cada n√≥ corresponde a uma regra da sintaxe da linguagem, servindo como base para explica√ß√µes nas se√ß√µes seguintes
Nesta se√ß√£o, √© apresentado os tipos de n√≥s que comp√µem a AST do compilador da linguagem \texttt{EquationLang}. Cada estrutura de n√≥ captura as diferentes regras de produ√ß√£o da sintaxe da linguagem em n√≠vel de c√≥digo, e esses nomes ser√£o utilizados nas se√ß√µes posteriores para explicar o desenvolvimento. √â importante destacar que o n√≥ \texttt{Expr}, sendo o mais gen√©rico, possui um campo importante, o \verb"ty_inferred", que representa o tipo da express√£o que √© preenchido pela an√°lise sem√¢ntica para uso na gera√ß√£o de c√≥digo.



Anteriormente, na \autoref{lexer-subexpression}, discutiu-se que o \textit{parser} √© capaz de lidar com identificadores aninhados, como \( x_{i_1} \) (\verb"x_{i_1}"). Esse suporte √© demonstrado no c√≥digo apresentado na \autoref{cod-expression-ident-recursive}, que ilustra como identificadores desse tipo s√£o processados de forma recursiva. O trecho mostrado faz parte de uma fun√ß√£o maior e √© extra√≠do de um \texttt{switch}\footnote{Os comandos \texttt{switch} e \texttt{case} na linguagem Odin funcionam de forma semelhante aos da linguagem C.}, aplicado sobre a enumera√ß√£o descrita na \autoref{enum-token-kind}. Dentro desse \texttt{switch}, h√° um \texttt{case} espec√≠fico que reconhece \textit{tokens} de identificadores ou s√≠mbolos especiais, como \( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \).

A funcionalidade recursiva √© habilitada por chamadas √† fun√ß√£o \texttt{parse\_expr}, permite a inclus√£o de sub√≠ndices num√©ricos, subexpress√µes de identificadores, ou at√© mesmo express√µes mais complexas, como \( n+1 \) em \( f_{n+1} \). Isso amplia a flexibilidade na representa√ß√£o de equa√ß√µes de BRDFs, onde o uso de sub√≠ndices num√©ricos √© bastante comum.

,
Com chamadas recursivas √† fun√ß√£o \texttt{parse_expr}, o \textit{parser} permite incluir sub√≠ndices num√©ricos, subexpress√µes ou at√© express√µes mais complexas, como 
ùëõ
+
1
n+1 em 
ùëì
ùëõ
+
1
f 
n+1
‚Äã

 . Isso garante maior flexibilidade na representa√ß√£o de equa√ß√µes de BRDFs, onde sub√≠ndices num√©ricos s√£o frequentemente usados.

a
por 
i
√†
s
Anteriormente, na \autoref{lexer-subexpression}, foi discutido que o \textit{parser} √© capaz de lidar com identificadores aninhados, como \( x_{i_1} \) (\verb"x_{i_1}"). Esse suporte √© demonstrado no \autoref{cod-expression-ident-recursive}, que processa identificadores de forma recursiva. O trecho faz parte de uma fun√ß√£o maior onde um \texttt{switch}\footnote{Os comandos \texttt{switch} e \texttt{case} na linguagem Odin funcionam de forma semelhante aos da linguagem C.} √© aplicado sobre a enumera√ß√£o descrita na \autoref{enum-token-kind}. Dentro desse \texttt{switch}, h√° um \texttt{case} espec√≠fico que reconhece \textit{tokens} de identificadores ou s√≠mbolos especiais, como \( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \).


A recursividade, feita pela chamada a fun√ß√£o \texttt{parse\_expr}, permite a inclus√£o de sub√≠ndices num√©ricos, subexpress√µes de identificadores, ou at√© mesmo express√µes mais complexas, como \( n+1 \) em \( f_{n+1} \). Isso amplia a flexibilidade na representa√ß√£o de equa√ß√µes de BRDFs, onde o uso de sub√≠ndices num√©ricos √© bastante comum.

%%%%%%%%
Anteriormente, na \autoref{lexer-subexpression}, foi discutido que o \textit{parser} √© capaz de lidar com identificadores aninhados, como \( x_{i_1} \) (\verb"x_{i_1}"). Esse suporte √© demonstrado no \autoref{cod-expression-ident-recursive}, que processa identificadores de forma recursiva. O trecho faz parte de uma fun√ß√£o maior onde um \texttt{switch}\footnote{Os comandos \texttt{switch} e \texttt{case} na linguagem Odin funcionam de forma semelhante aos da linguagem C.} √© aplicado sobre a enumera√ß√£o descrita na \autoref{enum-token-kind}. Dentro desse \texttt{switch}, h√° um \texttt{case} espec√≠fico que reconhece \textit{tokens} de identificadores ou s√≠mbolos especiais, como \( \omega, \theta, \phi, \rho, \alpha, \beta, \sigma, \pi, \epsilon \).


A recursividade, feita pela chamada a fun√ß√£o \texttt{parse\_expr}, permite a inclus√£o de sub√≠ndices num√©ricos, subexpress√µes de identificadores, ou at√© mesmo express√µes mais complexas, como \( n+1 \) em \( f_{n+1} \). Isso amplia a flexibilidade na representa√ß√£o de equa√ß√µes de BRDFs, onde o uso de sub√≠ndices num√©ricos √© bastante comum.



% Essa capacidade do \textit{parser} √© essencial na etapa de gera√ß√£o de c√≥digo, pois permite distinguir semanticamente identificadores que, √† primeira vista, podem parecer id√™nticos. Por exemplo, embora o identificador base seja \( f \), os s√≠mbolos \( f_1 \) e \( f_2 \) s√£o tratados como semanticamente distintos devido aos seus √≠ndices. Essa distin√ß√£o √© crucial para o correto mapeamento e interpreta√ß√£o dos elementos durante a an√°lise sem√¢ntica e a gera√ß√£o de c√≥digo GLSL.





%%%%%




Essa mesma l√≥gica exemplifica o processamento todas as outras express√µes recursivas, como opera√ß√µes bin√°rias. Para identificar o \textit{token} atual, utilizamos a fun√ß√£o \texttt{peek()}, que permite visualizar um ou dois \textit{tokens} √† frente e decidir qual n√≥ da AST ser√° constru√≠do. Ap√≥s identificar o \textit{token}, calcula-se a vari√°vel \texttt{prec}, que determina a preced√™ncia do operador. Com base nessa preced√™ncia, s√£o realizadas chamadas recursivas √† fun√ß√£o \texttt{parse\_expr} para processar express√µes aninhadas.

Ap√≥s preencher todos os campos necess√°rios, a express√£o completa √© retornada. Esse processo √© repetido at√© que toda a sub√°rvore de express√µes de uma equa√ß√£o seja constru√≠da. A an√°lise sint√°tica √© conclu√≠da quando todas as equa√ß√µes s√£o adicionadas √† AST.

Em seguida, essa estrutura hier√°rquica √© anotada com tipos e validada pelo pacote \texttt{checker}, como descrito na \autoref{section-checker}. Antes da valida√ß√£o, √© necess√°rio implementar m√©todos para a travessia da √°rvore. Esse processo √© detalhado na \autoref{section-walker}, que apresenta t√©cnicas para percorrer a √°rvore, acessar seus dados e facilitar as etapas subsequentes de an√°lise sem√¢ntica e gera√ß√£o de c√≥digo.

% Essa mesma l√≥gica exemplifica o processamento todas as outras express√µes recursivas, como opera√ß√µes bin√°rias. Para identificar o \textit{token} atual, utilizamos a fun√ß√£o \texttt{peek()}, que permite visualizar um ou dois \textit{tokens} √† frente e decidir qual n√≥ da AST ser√° constru√≠do. Ap√≥s identificar o \textit{token}, calcula-se a vari√°vel \texttt{prec}, que determina a preced√™ncia do operador. Com base nessa preced√™ncia, s√£o realizadas chamadas recursivas √† fun√ß√£o \texttt{parse\_expr} para processar express√µes aninhadas.
%
% Ap√≥s preencher todos os campos necess√°rios, a express√£o completa √© retornada. Esse processo √© repetido at√© que toda a sub√°rvore de express√µes de uma equa√ß√£o seja constru√≠da. A an√°lise sint√°tica √© conclu√≠da quando todas as equa√ß√µes s√£o adicionadas √† AST.
%
% Em seguida, essa estrutura hier√°rquica √© anotada com tipos e validada pelo pacote \texttt{checker}, como descrito na \autoref{section-checker}. Antes da valida√ß√£o, √© necess√°rio implementar m√©todos para a travessia da √°rvore. Esse processo √© detalhado na \autoref{section-walker}, que apresenta t√©cnicas para percorrer a √°rvore, acessar seus dados e facilitar as etapas subsequentes de an√°lise sem√¢ntica e gera√ß√£o de c√≥digo.

As fun√ß√µes e a estrutura de travessia foram utilizadas para validar a preced√™ncia dos operadores na AST gerada pelo \texttt{parser}. Foi implementada uma fun√ß√£o de parentiza√ß√£o, que processa todos os tipos de express√µes durante a travessia da AST, inserindo par√™nteses para preservar a preced√™ncia impl√≠cita original (sem par√™nteses). Isso garante que a representa√ß√£o textual reflita corretamente a ordem de avalia√ß√£o das opera√ß√µes matem√°ticas, assegurando que a hierarquia das opera√ß√µes foram corretamente representada na √°rvore gerada.

Os testes de preced√™ncia comparam o texto original de uma express√£o com sua vers√£o esperada, onde os par√™nteses refletem a ordem correta de avalia√ß√£o (\autoref{cod-test-paren}). Casos mais complexos, como operadores associativos √† direita (ex: exponencia√ß√£o) combinados com outros operadores de diferentes preced√™ncias, tamb√©m s√£o testados. Express√µes aninhadas e fun√ß√µes tamb√©m s√£o consideradas para abranger todos os cen√°rios.

,
assegurando que a hierarquia das opera√ß√µes foram corretamente representada na √°rvore gerada.

garantindo que a hierarquia das opera√ß√µes seja respeitada.

e
As fun√ß√µes e a estrutura de travessia foram utilizadas para validar a preced√™ncia dos operadores na AST gerada pelo \texttt{parser}. Foi implementada uma fun√ß√£o de parentiza√ß√£o, que processa todos os tipos de express√µes durante a travessia da AST, inserindo par√™nteses para preservar a preced√™ncia impl√≠cita original (sem par√™nteses). Isso garante que a representa√ß√£o textual reflita corretamente a ordem de avalia√ß√£o das opera√ß√µes matem√°ticas, 

Os testes de preced√™ncia comparam o texto original de uma express√£o com sua vers√£o esperada, onde os par√™nteses refletem a ordem correta de avalia√ß√£o (\autoref{cod-test-paren}). Casos mais complexos, como operadores associativos √† direita (ex: exponencia√ß√£o) combinados com outros operadores de diferentes preced√™ncias, tamb√©m s√£o testados. Express√µes aninhadas e fun√ß√µes tamb√©m s√£o consideradas para abranger todos os cen√°rios.

subsection-type-inference
subsection-type-inference
subsection-inferencia-tipos
subsection-type-inference
subsection-inferencia-tipos


*
        \item Os argumentos de uma fun√ß√£o perten√ßam ao dom√≠nio da fun√ß√£o. Por exemplo, se a fun√ß√£o $\texttt{normalize}(\vec{u})$ retorna um vetor tridimensional ($\mathbb{R}^3$), us√°-lo como argumento para funl√ß√£o seno, que espera um n√∫mero escalar ($\mathbb{R}$). Ent√£o, $\sin(\texttt{normalize}(\vec{u}))$ seria inv√°lido.
        \item O tipo do valor de retorno de uma fun√ß√£o seja adequado ao contexto onde √© utilizado.

        \item Os argumentos de uma fun√ß√£o perten√ßam ao dom√≠nio da fun√ß√£o. Por exemplo, se a fun√ß√£o $\texttt{normalize}(\vec{u})$ retorna um vetor tridimensional ($\mathbb{R}^3$), us√°-lo como argumento para funl√ß√£o seno, que espera um n√∫mero escalar ($\mathbb{R}$). Ent√£o, $\sin(\texttt{normalize}(\vec{u}))$ seria inv√°lido.
        \item O tipo do valor de retorno de uma fun√ß√£o seja adequado ao contexto onde √© utilizado.

        \item Os argumentos de uma fun√ß√£o perten√ßam ao dom√≠nio da fun√ß√£o. Por exemplo, se a fun√ß√£o $\texttt{normalize}(\vec{u})$ retorna um vetor tridimensional ($\mathbb{R}^3$), us√°-lo como argumento para funl√ß√£o seno, que espera um n√∫mero escalar ($\mathbb{R}$). Ent√£o, $\sin(\texttt{normalize}(\vec{u}))$ seria inv√°lido.
        \item O tipo do valor de retorno de uma fun√ß√£o seja adequado ao contexto onde √© utilizado.



    // node:   ^Expr_Procedure,


    /* Easy comparison, types aren't equal if they are not even the same odin typeid */

Type_Vector
Type_Basic
Type_Function
sec-symbol-resolution
subsection-sym-resolution
sec-symbol-resolution
cod-symbol-graph
cod-symbol-graph
cod-grafo-simbol-deps
cod-grafo-simbol-deps
a
        \item Verifica√ß√£o do ponto de entrada

        \item Valida√ß√£o de defini√ß√£o de fun√ß√µes com uso de escopo

 idk yet @LOOK
    /*
     . It does not need to be a pointer to a map
     . because we don't ever copy a Scope we have only one scope
     . per map elements, and we access this ONLY scope value trought a pointer
    */




SCOPES := Scope_Table{}


    \item \texttt{scope\_reset}: redefine a tabela de s√≠mbolos limpando todos os escopos.

A fun√ß√£o \verb`infer_type` serve para determinar o tipo de uma express√£o sint√°tica (representada por \verb`expr`) na AST durante a an√°lise sem√¢ntica. √â usado um conjunto de regras para inferir e atribuir tipos √† express√µes. A base das regras s√£o matematicas, como multiplica√ß√£o entre numero real e vetor, produtor vetorial dentre dois vetores, assinatura de fun√ß√µes definidas, entre outras.


Essa fun√ß√£o √© projetada para lidar com todas constru√ß√µes que s√£o express√µes em \texttt{EquationLang}, como identificadores, operadores prefixados e infixados, chamadas de fun√ß√£o e literais.

Inicialmente, a fun√ß√£o verifica se o tipo da express√£o j√° foi inferido (\verb"expr.ty_inferred"). Se sim, retorna o tipo previamente inferido, evitando processamento redundante. Caso contr√°rio, prossegue com a infer√™ncia. O bloco central da fun√ß√£o √© um \verb"switch" que analisa os diferentes tipos de express√µes derivadas de \verb"expr". Um trecho relevante dessa implementa√ß√£o est√° no \autoref{cod-type-inference}, onde √© possivel ver a discrimi√ß√£o dos tipos e a valida√ß√£o.

v
v
Um trecho relevante dessa implementa√ß√£o est√° no \autoref{cod-type-inference}
Um exemplo desse processo est√° no 
ndo
%%%
A fun√ß√£o \verb`infer_type` serve para determinar o tipo de uma express√£o sint√°tica (representada por \verb`expr`) na AST durante a an√°lise sem√¢ntica. √â usado um conjunto de regras para inferir e atribuir tipos √† express√µes. A base das regras s√£o matematicas, como multiplica√ß√£o entre numero real e vetor, produtor vetorial dentre dois vetores, assinatura de fun√ß√µes definidas, entre outras.


Essa fun√ß√£o √© projetada para lidar com todas constru√ß√µes que s√£o express√µes em \texttt{EquationLang}, como identificadores, operadores prefixados e infixados, chamadas de fun√ß√£o e literais.

Inicialmente, a fun√ß√£o verifica se o tipo da express√£o j√° foi inferido (\verb"expr.ty_inferred"). Se sim, retorna o tipo previamente inferido, evitando processamento redundante. Caso contr√°rio, prossegue com a infer√™ncia. O bloco central da fun√ß√£o √© um \verb"switch" que analisa os diferentes tipos de express√µes derivadas de \verb"expr". Um trecho relevante dessa implementa√ß√£o est√° no \autoref{cod-type-inference}, onde √© possivel ver a discrimi√ß√£o dos tipos e a valida√ß√£o.



    \item Opera√ß√µes entre dois n√∫meros resultam em um n√∫mero.

√†
basicstyle=\ttfamily\footnotesize
Esse processo tamb√©m verifica redefini√ß√µes de s√≠mbolos, prevenindo m√∫ltiplas declara√ß√µes do mesmo identificador no mesmo escopo.

Declara√ß√µes de equa√ß√µes s√£o validadas ap√≥s a etapa de coleta e ordena√ß√£o descrita em \autoref{subsection-sym-resolution}, portanto assume-se que o lado esquerdo das equa√ß√µes deve ser um identificador v√°lido ou a defini√ß√£o de uma fun√ß√£o.

Todas as viola√ß√µes sem√¢nticas, como incompatibilidades de tipos ou uso de valores escalares onde vetores s√£o esperados, s√£o reportadas ao usu√°rio, juntamente com informa√ß√µes detalhadas sobre o contexto e o local do erro, como descrito na \autoref{subsection-erros}.

A fun√ß√£o \verb"check_expr" realiza uma traversia similiar a interencia de tipos e √© ser respons√°vel por chamar \texttt{infer\_type}. Nessa fun√ß√£o, a an√°lise de express√µes que \texttt{infer\_type} deixou de fazer s√£o feitas para todas os tipos de express√µes, alguns dessas valida√ß√µes est√£o listado logo ap√≥s este paragrafo. O recorte dessa traversia pode ser visto no \autoref{eq-function-check-expr}.

portanto assume-
portanto assume-se
com a exig√™ncia de

Declara√ß√µes de equa√ß√µes s√£o validadas ap√≥s a etapa de coleta e ordena√ß√£o descrita em \autoref{subsection-sym-resolution}, portanto assume-se que o lado esquerdo das equa√ß√µes deve ser um identificador v√°lido ou a defini√ß√£o de uma fun√ß√£o.

Todas as viola√ß√µes sem√¢nticas, como incompatibilidades de tipos ou uso de valores escalares onde vetores s√£o esperados, s√£o reportadas ao usu√°rio, juntamente com informa√ß√µes detalhadas sobre o contexto e o local do erro, como descrito na \autoref{subsection-erros}.


%%%%

A fun√ß√£o \verb"check_expr" realiza uma traversia similiar a interencia de tipos e √© ser respons√°vel por chamar \texttt{infer\_type}. Nessa fun√ß√£o, a an√°lise de express√µes que \texttt{infer\_type} deixou de fazer s√£o feitas para todas os tipos de express√µes, alguns dessas valida√ß√µes est√£o listado logo ap√≥s este paragrafo. O recorte dessa traversia pode ser visto no \autoref{eq-function-check-expr}.








    \item \verb`Expr_Function_Call`: Verifica se estamos fazendo a chamada com um identificador, pode ocorrer o caso de tentar fazer a chamada com um n√∫mero $123(x,y)$, e isso est√° incorreto.

\begin{itemize}
    \item \verb`Expr_Function_Call`: Verifica se estamos fazendo a chamada com um identificador, pode ocorrer o caso de tentar fazer a chamada com um n√∫mero $123(x,y)$, e isso est√° incorreto. Ou que o n√∫mero de argumentos √© diferente do n√∫mero de paraemtros esperados
    \item \verb`Expr_Prefix`: Verifica operadores (\verb`-`, \verb`+`) e fun√ß√µes como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compat√≠veis, gerando erro caso contr√°rio, como aceitar um vetor no seno seria incorreto.
    \item Literais de Vetor \verb`Expr_Vector_Literal`: Garante que vetores tenham exatamente 3 dimens√µes, reportando erros para formatos inv√°lidos.
\end{itemize}

\begin{itemize}
    \item \verb`Expr_Function_Call`: Verifica se estamos fazendo a chamada com um identificador, pode ocorrer o caso de tentar fazer a chamada com um n√∫mero $123(x,y)$, e isso est√° incorreto. Ou que o n√∫mero de argumentos √© diferente do n√∫mero de paraemtros esperados
    \item \verb`Expr_Prefix`: Verifica operadores (\verb`-`, \verb`+`) e fun√ß√µes como \verb`sqrt(x)` e \verb`sin(x)`. Certifica que os tipos sejam compat√≠veis, gerando erro caso contr√°rio, como aceitar um vetor no seno seria incorreto.
    \item Literais de Vetor \verb`Expr_Vector_Literal`: Garante que vetores tenham exatamente 3 dimens√µes, reportando erros para formatos inv√°lidos.
\end{itemize}

a
,
a
    `\max`,

basicstyle=\ttfamily\footnotesize
            
    
        // C√≥digo omitido de preambulo
        // Partimos checar os casos para cada tipo de express√£o

    

            if !fn_sym_ok {
                error(e.open,  "Tried to call`%v`, which is not defined in this scope.", fn_string)
            }









    // Partimos checar os casos para cada tipo de express√£o



            // The name of the function stores the functon type with argments type and returns



    // Primeiro inferimos o tipo

    






O procedimento \verb"check_function_definition" implementa a valida√ß√£o para defini√ß√µes de fun√ß√£o, garantindo seguran√ßa de tipos e consist√™ncia de par√¢metros. Ela √© respons√°vel pelas tarefas √† seguir:

\begin{enumerate}
    \item Inferir os tipos para cada par√¢metro
    \item Inferir o tipo de retorno com base na express√£o final.
    \item Construir o tipo completo da fun√ß√£o, incluindo par√¢metros e retorno.
    \item Garantir que todos os identificadores utilizados estejam consistentes com seus tipos declarados.
    \item Validar todas as express√µes no corpo da fun√ß√£o.
    \item Criar um novo escopo para os par√¢metros da fun√ß√£\textbackslash{}o
\end{enumerate}
%%%

O processo come√ßa com o processamento dos par√¢metros e o gerenciamento do escopo, como aparece no \autoref{cod-func-defn}. Quando uma fun√ß√£o √© definida, o sistema cria um novo escopo para armazenar informa√ß√µes dos par√¢metros e da pr√≥pria fun√ß√£o em forma de s√≠mbolos a serem adicionados ao escopo atrelado a essa defini√ß√£o.

Esse escopo com simbolos s√£o essencial para validar tanto as chamadas de fun√ß√£o quanto as express√µes no corpo da fun√ß√£o. Cada fun√ß√£o tem seu pr√≥prio escopo, cujo escopo pai √© o global, prevenindo conflitos de identificadores.

O controle de visibilidade de s√≠mbolos √© feito de forma espec√≠fica. Na defini√ß√£o de escopo, se o $x$ existe nos par√¢metros, primeiro √© usado o $x$ do par√¢metro antes de tentar acessar um $x$ global. Isso √© chamado de \textit{shadowing} ou sombreamento do s√≠mbolo, como no caso da equa√ß√£o \autoref{eq-shadowing}, o resultado de $f$ √© 3 e n√£o 2.

√®
O procedimento \verb"check_function_definition" implementa a valida√ß√£o para defini√ß√µes de fun√ß√£o, garantindo seguran√ßa de tipos e consist√™ncia de par√¢metros. Ela √© respons√°vel pelas tarefas √† seguir:

\begin{enumerate}
    \item Inferir os tipos para cada par√¢metro
    \item Inferir o tipo de retorno com base na express√£o final.
    \item Construir o tipo completo da fun√ß√£o, incluindo par√¢metros e retorno.
    \item Garantir que todos os identificadores utilizados estejam consistentes com seus tipos declarados.
    \item Validar todas as express√µes no corpo da fun√ß√£o.
    \item Criar um novo escopo para os par√¢metros da fun√ß√£\textbackslash{}o
\end{enumerate}
%%%

%%%%%%%


O processo come√ßa com o processamento dos par√¢metros e o gerenciamento do escopo, como aparece no \autoref{cod-func-defn}. Quando uma fun√ß√£o √© definida, o sistema cria um novo escopo para armazenar informa√ß√µes dos par√¢metros e da pr√≥pria fun√ß√£o em forma de s√≠mbolos a serem adicionados ao escopo atrelado a essa defini√ß√£o.

Esse escopo com simbolos s√£o essencial para validar tanto as chamadas de fun√ß√£o quanto as express√µes no corpo da fun√ß√£o. Cada fun√ß√£o tem seu pr√≥prio escopo, cujo escopo pai √© o global, prevenindo conflitos de identificadores.

O controle de visibilidade de s√≠mbolos √© feito de forma espec√≠fica. Na defini√ß√£o de escopo, se o $x$ existe nos par√¢metros, primeiro √© usado o $x$ do par√¢metro antes de tentar acessar um $x$ global. Isso √© chamado de \textit{shadowing} ou sombreamento do s√≠mbolo, como no caso da equa√ß√£o \autoref{eq-shadowing}, o resultado de $f$ √© 3 e n√£o 2.

%%%

cod-parametros-validation
cod-func-
defn
A valida√ß√£o de identificadores no corpo da fun√ß√£o utiliza o escopo da fun√ß√£o para realizar tr√™s verifica√ß√µes principais: confirmar se o identificador est√° definido, verificar a compatibilidade do seu tipo com o s√≠mbolo no escopo e garantir que n√£o haja viola√ß√£o das regras sem√¢nticas.



./Imagens/error-type-mismatch.png
\begin{codigo}[htb]
    \caption{\small Equa√ß√£o com uso incorreto de tipos na chamada de fun√ß√£o. }
    \label{cod-type-mismatch}
\begin{lstlisting}[language=tex, numbers=none, frame=none, inputencoding=latin1]
\begin{equation}
    g(a, x) = a*x*x
\end{equation}

\begin{equation}
    f = g(1, \vec{1,1,1})
\end{equation}

\end{lstlisting}
\end{codigo}

f
,
A fun√ß√£o $g$ espera dois n√∫meros reais como argumentos, mas na equa√ß√£o $f$, um vetor foi passado no lugar de um numero, assim um erro ser√° gerado. A \autoref{fig-type-mismatch} ilustra esse erro, indicando fun√ß√£o que teve o argumento incompat√≠vel. Na hora de passar os argumentos tamb√©m validamos que o quantidade de argumentos correspondem ao numero de par√¢metros esperados.

ùëî
$g$
%%
ùëì

A fun√ß√£o $g$ espera dois n√∫meros reais como argumentos, mas na equa√ß√£o $f$, um vetor foi passado no lugar de um numero, assim um erro ser√° gerado. A \autoref{fig-type-mismatch} ilustra esse erro, indicando fun√ß√£o que teve o argumento incompat√≠vel. Na hora de passar os argumentos tamb√©m validamos que o quantidade de argumentos correspondem ao numero de par√¢metros esperados.







cod-check-single-ident
cod-check-single-ident
\begin{codigo}[htb]
    \caption{\small Valida√ß√£o de um un√≠co identificador dentro de contexto de parametros de uma fun√ß√£o. }
    \label{cod-check-single-ident}
\begin{lstlisting}[language=C, numbers=none, frame=none, inputencoding=latin1]

check_single_identifier :: proc(parameters: []^ast.Expr_Identifier, ident: ^ast.Expr_Identifier) {
    infer_type(ident)
    ident_key := key_from_identifier(ident)
    // Validates type consistency between declaration and usage
    if !is_type_equal(ident.ty_inferred, p.ty_inferred) {
        error(ident.identifier, "Parameter `%v` being use as type `%v` when the expected type is `%v`", ...)
    }
    // C√≥digo omitido por brevidade ..
}
\end{lstlisting}
\end{codigo}




cod-scope-management
basicstyle=\ttfamily\footnotesize

A fase de gera√ß√£o de c√≥digo √© respons√°vel por transformar as estruturas intermedi√°rias, como a AST anotada, em c√≥digo de \textit{shading} GLSL. O pacote \texttt{emitter} realiza essa transforma√ß√£o, emitindo c√≥digo compat√≠vel com a ferramenta da Disney BRDF Explorer.

A entrada principal para esse processo √© o escopo global, que cont√©m todas as informa√ß√µes necess√°rias para gerar o programa completo, como escopos filhos, simbolos, assinatura de fun√ß√µes e tipos. Nesta etapa, a AST est√° completamente anotada com tipos e informa√ß√µes auxiliares, acess√≠veis por meio dos s√≠mbolos presentes na tabela de s√≠mbolos que ser√° usado gera√ß√£o de fun√ß√µes e express√µes no formato apropriado.

Como o programa j√° foi validado anteriormente, assume-se sua corretude sem√¢ntica, permitindo a travessia recursiva de todos os simbolos e n√≥s, sem fazer nenhuma valida√ß√£o extra. A traversia abrange a gera√ß√£o de c√≥digo para defini√ß√µes de fun√ß√µes, express√µes e elementos espec√≠ficos, como os lados esquerdo (LHS do ingl√™s left hand side) e direito (RHS do ingl√™s right hand side) das equa√ß√µes.

O lado esquerdo (LHS) pode envolver identificadores com subexpress√µes (e.g., $f_{n+1} = \dots$), par√¢metros em defini√ß√µes de fun√ß√µes ou simplesmente s√≠mbolos como vetores ou n√∫meros. A abordagem detalhada para o LHS √© apresentada na \autoref{sec-LHS}. J√° o lado direito (RHS) √© sempre uma express√£o, exigindo o uso do pacote \texttt{walker} para fazer a traversia da √°rvore para traduzir as opera√ß√µes e tipos inferidos para o equivalente em GLSL. Esse processo √© explorado em \autoref{sec-RHS}.

Um ponto crucial √© a necessidade de garantir que cada vari√°vel tenha um nome √∫nico no c√≥digo GLSL, conforme detalhado em \autoref{sec-unicidade}.

,
c√≥digo compat√≠vel com a Disney BRDF Explorer
A fase de gera√ß√£o de c√≥digo √© realizada pelo pacote \texttt{emitter}, criando um c√≥digo compat√≠vel com a Disney BRDF Explorer. O processo come√ßa com o escopo global, que cont√©m informa√ß√µes essenciais como escopos, s√≠mbolos, assinaturas de fun√ß√µes e tipos. A AST j√° est√° completamente anotada, e a travessia recursiva dos s√≠mbolos e n√≥s √© realizada sem valida√ß√µes adicionais, pois a sem√¢ntica j√° foi validada.

A fase de gera√ß√£o de c√≥digo √© realizada pelo pacote \texttt{emitter}, criando um c√≥digo compat√≠vel com a Disney BRDF Explorer. O processo come√ßa com o escopo global, que cont√©m informa√ß√µes essenciais como escopos, s√≠mbolos, assinaturas de fun√ß√µes e tipos. A AST j√° est√° completamente anotada, e a travessia recursiva dos s√≠mbolos e n√≥s √© realizada sem valida√ß√µes adicionais, pois a sem√¢ntica j√° foi validada.
%%
A fase de gera√ß√£o de c√≥digo √© respons√°vel por transformar as estruturas intermedi√°rias, como a AST anotada, em c√≥digo de \textit{shading} GLSL. O pacote \texttt{emitter} realiza essa transforma√ß√£o, emitindo c√≥digo compat√≠vel com a ferramenta da Disney BRDF Explorer.

A entrada principal para esse processo √© o escopo global, que cont√©m todas as informa√ß√µes necess√°rias para gerar o programa completo, como escopos filhos, simbolos, assinatura de fun√ß√µes e tipos. Nesta etapa, a AST est√° completamente anotada com tipos e informa√ß√µes auxiliares, acess√≠veis por meio dos s√≠mbolos presentes na tabela de s√≠mbolos que ser√° usado gera√ß√£o de fun√ß√µes e express√µes no formato apropriado.




Um ponto crucial √© a necessidade de garantir que cada vari√°vel tenha um nome √∫nico no c√≥digo GLSL, conforme detalhado em \autoref{sec-unicidade}.

A fase de gera√ß√£o de c√≥digo √© realizada pelo pacote \texttt{emitter}, que cria um c√≥digo compat√≠vel com a Disney BRDF Explorer. O processo iniciae no escopo global, que cont√©m informa√ß√µes essenciais, como escopos, s√≠mbolos, assinaturas de fun√ß√µes e tipos. A AST j√° est√° completamente anotada, e a travessia recursiva dos s√≠mbolos e n√≥s ocorre sem valida√ß√µes adicionais, uma vez que a etapa sem√¢ntica j√° foi validada.

A gera√ß√£o de c√≥digo abrange tanto os lados esquerdo (LHS) quanto direito (RHS) das equa√ß√µes. O LHS pode incluir identificadores, par√¢metros de fun√ß√µes ou s√≠mbolos simples. O RHS √© sempre uma express√£o, que √© processada pelo pacote \texttt{walker} para traduzir opera√ß√µes e tipos para o formato GLSL.

Al√©m disso, √© fundamental garantir que cada vari√°vel tenha um nome √∫nico no c√≥digo GLSL, conforme descrito em \autoref{sec-unicidade}.

%%%%%%
Como o programa j√° foi validado anteriormente, assume-se sua corretude sem√¢ntica, permitindo a travessia recursiva de todos os simbolos e n√≥s, sem fazer nenhuma valida√ß√£o extra. A traversia abrange a gera√ß√£o de c√≥digo para defini√ß√µes de fun√ß√µes, express√µes e elementos espec√≠ficos, como os lados esquerdo (LHS do ingl√™s left hand side) e direito (RHS do ingl√™s right hand side) das equa√ß√µes.

O lado esquerdo (LHS) pode envolver identificadores com subexpress√µes (e.g., $f_{n+1} = \dots$), par√¢metros em defini√ß√µes de fun√ß√µes ou simplesmente s√≠mbolos como vetores ou n√∫meros. A abordagem detalhada para o LHS √© apresentada na \autoref{sec-LHS}. J√° o lado direito (RHS) √© sempre uma express√£o, exigindo o uso do pacote \texttt{walker} para fazer a traversia da √°rvore para traduzir as opera√ß√µes e tipos inferidos para o equivalente em GLSL. Esse processo √© explorado em \autoref{sec-RHS}.

%%%
A fase de gera√ß√£o de c√≥digo √© realizada pelo pacote \texttt{emitter}, que cria um c√≥digo compat√≠vel com a Disney BRDF Explorer. O processo iniciae no escopo global, que cont√©m informa√ß√µes essenciais, como escopos, s√≠mbolos, assinaturas de fun√ß√µes e tipos. A AST j√° est√° completamente anotada, e a travessia recursiva dos s√≠mbolos e n√≥s ocorre sem valida√ß√µes adicionais, uma vez que a etapa sem√¢ntica j√° foi validada.

A gera√ß√£o de c√≥digo abrange tanto os lados esquerdo (LHS) quanto direito (RHS) das equa√ß√µes. O LHS pode incluir identificadores, par√¢metros de fun√ß√µes ou s√≠mbolos simples. O RHS √© sempre uma express√£o, que √© processada pelo pacote \texttt{walker} para traduzir opera√ß√µes e tipos para o formato GLSL.

Al√©m disso, √© fundamental garantir que cada vari√°vel tenha um nome √∫nico no c√≥digo GLSL, conforme descrito em \autoref{sec-unicidade}.

%%%%%%
Como o programa j√° foi validado anteriormente, assume-se sua corretude sem√¢ntica, permitindo a travessia recursiva de todos os simbolos e n√≥s, sem fazer nenhuma valida√ß√£o extra. A traversia abrange a gera√ß√£o de c√≥digo para defini√ß√µes de fun√ß√µes, express√µes e elementos espec√≠ficos, como os lados esquerdo (LHS do ingl√™s left hand side) e direito (RHS do ingl√™s right hand side) das equa√ß√µes.

O lado esquerdo (LHS) pode envolver identificadores com subexpress√µes (e.g., $f_{n+1} = \dots$), par√¢metros em defini√ß√µes de fun√ß√µes ou simplesmente s√≠mbolos como vetores ou n√∫meros. A abordagem detalhada para o LHS √© apresentada na \autoref{sec-LHS}. J√° o lado direito (RHS) √© sempre uma express√£o, exigindo o uso do pacote \texttt{walker} para fazer a traversia da √°rvore para traduzir as opera√ß√µes e tipos inferidos para o equivalente em GLSL. Esse processo √© explorado em \autoref{sec-RHS}.

%%%
A fase de gera√ß√£o de c√≥digo √© realizada pelo pacote \texttt{emitter}, que cria um c√≥digo compat√≠vel com a Disney BRDF Explorer. O processo iniciae no escopo global, que cont√©m informa√ß√µes essenciais, como escopos, s√≠mbolos, assinaturas de fun√ß√µes e tipos. A AST j√° est√° completamente anotada, e a travessia recursiva dos s√≠mbolos e n√≥s ocorre sem valida√ß√µes adicionais, uma vez que a etapa sem√¢ntica j√° foi validada.

A gera√ß√£o de c√≥digo abrange tanto os lados esquerdo (LHS) quanto direito (RHS) das equa√ß√µes. O LHS pode incluir identificadores, par√¢metros de fun√ß√µes ou s√≠mbolos simples. O RHS √© sempre uma express√£o, que √© processada pelo pacote \texttt{walker} para traduzir opera√ß√µes e tipos para o formato GLSL.

Al√©m disso, √© fundamental garantir que cada vari√°vel tenha um nome √∫nico no c√≥digo GLSL, conforme descrito em \autoref{sec-unicidade}.

%%%%%%
Como o programa j√° foi validado anteriormente, assume-se sua corretude sem√¢ntica, permitindo a travessia recursiva de todos os simbolos e n√≥s, sem fazer nenhuma valida√ß√£o extra. A traversia abrange a gera√ß√£o de c√≥digo para defini√ß√µes de fun√ß√µes, express√µes e elementos espec√≠ficos, como os lados esquerdo (LHS do ingl√™s left hand side) e direito (RHS do ingl√™s right hand side) das equa√ß√µes.

O lado esquerdo (LHS) pode envolver identificadores com subexpress√µes (e.g., $f_{n+1} = \dots$), par√¢metros em defini√ß√µes de fun√ß√µes ou simplesmente s√≠mbolos como vetores ou n√∫meros. A abordagem detalhada para o LHS √© apresentada na \autoref{sec-LHS}. J√° o lado direito (RHS) √© sempre uma express√£o, exigindo o uso do pacote \texttt{walker} para fazer a traversia da √°rvore para traduzir as opera√ß√µes e tipos inferidos para o equivalente em GLSL. Esse processo √© explorado em \autoref{sec-RHS}.

l
\subsection{Emiss√£o de Equa√ß√µes}

A emiss√£o de c√≥digo come√ßa pelo lado esquerdo da equa√ß√£o. Existem tr√™s aspectos principais nesse processo:
\begin{enumerate}
    \item Mapeamento de Tipos (LHS): O tipo associado ao identificador √© a primeira informa√ß√£o a ser resolvida. Caso seja um n√∫mero real, ele √© mapeado para \verb"float" em GLSL. Para vetores ($\mathbb{R}^3$), o mapeamento √© feito para \verb"vec3". Em defini√ß√µes de fun√ß√µes, utiliza-se o simbolo da fun√ß√£o para acessar os tipos de par√¢metros e do retorno, construindo assim a assinatura da fun√ß√£o no formato GLSL.

    \item Identificador (LHS): O identificador associado ao s√≠mbolo √© traduzido conforme regras espec√≠ficas que garantem unicidade e conformidade com as restri√ß√µes do GLSL. Este processo √© detalhado em \autoref{sec-unicidade}.

    \item Express√µes (RHS): No caso do lado direito da equa√ß√£o, tanto fun√ß√µes quanto de variaveis, s√£o express√µes. Para gerar isso, realiza-se uma travessia da AST, mapeando n√≥s de express√µes (como somas e chamadas de fun√ß√µes trigonom√©tricas) para seu equivalente em GLSL. Detalhes adicionais sobre a emiss√£o de c√≥digo para express√µes est√£o na \autoref{}.
\end{enumerate}


\label{sec-RHS}
A gera√ß√£o de express√µes √© uma das etapas mais importantes no processo de compila√ß√£o e ocupa uma parte substancial do pacote \texttt{emitter}. Essa tarefa consiste em emitir c√≥digo paras todas as express√µes do lado direito das equa√ß√µes em c√≥digo GLSL v√°lido usando a AST anotada com tipos inferidos.

A implementa√ß√£o √© realizada na fun√ß√£o \verb"emit_expr", que recebe um n√≥ de express√£o e uma refer√™ncia a um objeto \verb"StringBuilder" (da biblioteca padr√£o de Odin). Este objeto √© utilizado para construir a cadeia de caracteres que corresponde a express√£o equivalente em GLSL, evitando concatena√ß√µes excessivas de strings.

A travessia da AST √© realizada de forma recursiva utilizando o pacote \texttt{walker}, que converte diferentes tipos de express√µes, incluindo opera√ß√µes bin√°rias, prefixas, vetoriais e chamadas de fun√ß√£o para c√≥digo GLSL. Para isso, a fun√ß√£o discrimina o tipo de n√≥, determinando qual opera√ß√£o correspondente deve ser utilizada em GLSL. 

Um recorte dessa fun√ß√£o pode ser observado no \autoref{cod-emit-expr}, onde a discrimina√ß√£o dos tipos √© feita √© feita (\texttt{case}), e a constru√ß√£o de strings para fun√ß√µes trigonom√©tricas √© realizada na inst√¢ncia de \texttt{StringBuilder} atrav√©s da fun√ß√£o \verb|sbprint|. A seguir, s√£o enumeradas as principais categorias de express√µes tratadas:

A
A gera√ß√£o de express√µes √© uma das etapas mais importantes no processo de compila√ß√£o e ocupa uma parte substancial do pacote \texttt{emitter}. Essa tarefa consiste em emitir c√≥digo paras todas as express√µes do lado direito das equa√ß√µes em c√≥digo GLSL v√°lido usando a AST anotada com tipos inferidos.

A implementa√ß√£o √© realizada na fun√ß√£o \verb"emit_expr", que recebe um n√≥ de express√£o e uma refer√™ncia a um objeto \verb"StringBuilder" (da biblioteca padr√£o de Odin). Este objeto √© utilizado para construir a cadeia de caracteres que corresponde a express√£o equivalente em GLSL, evitando concatena√ß√µes excessivas de strings.

Um exemplo dessa fun√ß√£o est√° no \autoref{cod-emit-expr}, que demonstra como os tipos s√£o discriminados (\texttt{case}) e strings para fun√ß√µes trigonom√©tricas s√£o geradas usando \verb|sbprint|. As principais categorias de express√µes tratadas incluem opera√ß√µes matem√°ticas e chamadas de fun√ß√µes.
%%%


A travessia da AST √© realizada de forma recursiva utilizando o pacote \texttt{walker}, que converte diferentes tipos de express√µes, incluindo opera√ß√µes bin√°rias, prefixas, vetoriais e chamadas de fun√ß√£o para c√≥digo GLSL. Para isso, a fun√ß√£o discrimina o tipo de n√≥, determinando qual opera√ß√£o correspondente deve ser utilizada em GLSL. 



recorte

Um recorte dessa fun√ß√£o pode ser observado no \autoref{cod-emit-expr}, onde a discrimina√ß√£o dos tipos √© feita √© feita (\texttt{case}), e a constru√ß√£o de strings para fun√ß√µes trigonom√©tricas √© realizada na inst√¢ncia de \texttt{StringBuilder} atrav√©s da fun√ß√£o \verb|sbprint|. 




,
identificadores e par√¢metros de fun√ß√µes
o lado esquerdo
√© explorado em \autoref{sec-RHS}
A fase de gera√ß√£o de c√≥digo √© realizada pelo pacote \texttt{emitter}, que cria um \textit{shader} compat√≠vel com a ferramenta Disney BRDF Explorer. O processo come√ßa no escopo global, contendo informa√ß√µes essenciais como escopos, s√≠mbolos, assinaturas de fun√ß√µes e tipos. A AST j√° est√° completamente anotada, e a travessia recursiva dos s√≠mbolos e n√≥s ocorre sem valida√ß√µes adicionais, uma vez que a etapa sem√¢ntica j√° foi validada.

A gera√ß√£o de c√≥digo abrange o lado esquerdo da equa√ß√£o, que inclue identificadores e par√¢metros de fun√ß√µes e o direito que √© sempre uma express√£o, tal que que sua emiss√£o √© √© explorado em \autoref{sec-RHS}.

Al√©m disso, √© essencial garantir que cada vari√°vel tenha um nome √∫nico no c√≥digo GLSL, conforme descrito em \autoref{sec-unicidade}.





    \item \textbf{Express√µes Chamadas de Fun√ß√£o}:
        Na gera√ß√£o de uma chamada de fun√ß√£o, ocorre a chamada recursiva para emitir a express√£o do indentificador dessa fun√ß√£o, depois abre parentesis \verb"(", e emite uma express√£o para cada argumentos separado por virgula e, por fim, fecha o parentesis. Demonstrado no recorte do \autoref{cod-emission-func}.

     
parentesis
par√™ntese
parentesis
    \item \textbf{Express√µes Chamadas de Fun√ß√£o}:
        Na gera√ß√£o de uma chamada de fun√ß√£o, ocorre a chamada recursiva para emitir a express√£o do indentificador dessa fun√ß√£o, depois abre parentesis \verb"(", e emite uma express√£o para cada argumentos separado por virgula e, por fim, fecha o parentesis. Demonstrado no recorte do \autoref{cod-emission-func}.



√©
eq-emit-expr-example
tab-conventions
tab-conventions-metodologia
tab-conventions
tab-conventions
i
---

:
sub-start-emitting
o
,
sub-start-
tab-conventions-metodologia
va trabalhar na tabela
